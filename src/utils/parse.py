#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Copyright (c) 2025 OfficeCowork Research Group.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

JSON parsing and fixing utilities.

This module contains utility functions for parsing and fixing malformed JSON strings,
particularly those generated by language models that may contain escape issues or
structural problems.

Migrated from tool_executor.py for better code organization and reusability.
"""

import json
import re
from typing import Dict, Any, Optional, List, Tuple


def _log_warning(message: str) -> None:
    """
    Simple logging function to replace print_current dependency.
    
    Args:
        message: Warning message to log
    """
    try:
        # Try to import print_current if available
        from tools.print_system import print_current
        print_current(message)
    except ImportError:
        # Fallback to standard print if print_current is not available
        print(message)


def _log_debug(message: str) -> None:
    """
    Simple logging function to replace print_debug dependency.
    
    Args:
        message: Debug message to log
    """
    try:
        # Try to import print_debug if available
        from tools.print_system import print_debug
        print_debug(message)
    except ImportError:
        # Fallback to standard print if print_debug is not available
        print(message)


def fix_json(json_str: str) -> str:
    """
    Smart method to escape unescaped quotes in JSON values while preserving JSON structure.

    Optimized version: For very long text (>5000 chars), directly use the more reliable character-level state machine method.
    For short text, use regular expressions for a faster fix.

    Args:
        json_str: Raw JSON string that may have unescaped quotes in values

    Returns:
        JSON string with properly escaped quotes in values
    """
    # For very long strings, use the more reliable method directly
    if len(json_str) > 5000:
        return fix_json_advanced(json_str)

    try:
        # For short strings, use optimized regular expression approach
        def escape_value_content(content: str) -> str:
            """
            Escape unescaped characters inside string values.
            Uses character-level handling to avoid regular expression performance issues on long text.
            """
            result = []
            i = 0
            escape_count = 0

            while i < len(content):
                char = content[i]

                # Count consecutive backslashes
                if char == '\\':
                    j = i
                    while j < len(content) and content[j] == '\\':
                        j += 1
                    escape_count = j - i

                    # If odd number of backslashes, current backslash is part of an escape sequence
                    if escape_count % 2 == 1:
                        result.append(char)
                        i += 1
                        continue
                    else:
                        # Even number of backslashes, treat as literal
                        result.append('\\\\' * (escape_count // 2))
                        i = j
                        continue

                # Reset escape count
                escape_count = 0

                # Escape unescaped quotes
                if char == '"':
                    # Check for preceding backslashes
                    prev_pos = i - 1
                    backslash_count = 0
                    while prev_pos >= 0 and content[prev_pos] == '\\':
                        backslash_count += 1
                        prev_pos -= 1

                    if backslash_count % 2 == 0:
                        # Unescaped quote, escape it
                        result.append('\\"')
                    else:
                        result.append(char)
                elif ord(char) < 32:  # Control characters
                    # Check for preceding backslashes
                    prev_pos = i - 1
                    backslash_count = 0
                    while prev_pos >= 0 and content[prev_pos] == '\\':
                        backslash_count += 1
                        prev_pos -= 1

                    if backslash_count % 2 == 0:
                        # Unescaped control character, escape it
                        if char == '\n':
                            result.append('\\n')
                        elif char == '\r':
                            result.append('\\r')
                        elif char == '\t':
                            result.append('\\t')
                        elif char == '\b':
                            result.append('\\b')
                        elif char == '\f':
                            result.append('\\f')
                        else:
                            result.append(f'\\u{ord(char):04x}')
                    else:
                        result.append(char)
                else:
                    result.append(char)

                i += 1

            return ''.join(result)

        # Improved pattern: Match "field": "value" format
        # Uses more precise end-token detection
        pattern = r'("[^"]*"\s*:\s*")(.*?)(?="\s*[,}\n])'

        def escape_value_quotes(match):
            prefix = match.group(1)  # "field": "
            content = match.group(2)  # content that may contain quotes, newlines, etc.

            # Escape using character-based handling
            escaped_content = escape_value_content(content)

            return f'{prefix}{escaped_content}"'

        fixed_json = re.sub(pattern, escape_value_quotes, json_str, flags=re.DOTALL)

        # If regex approach did not fix, use the more reliable fallback
        if fixed_json == json_str:
            return fix_json_advanced(json_str)

        # Validate that the fixed JSON is indeed valid
        try:
            json.loads(fixed_json)
            return fixed_json
        except json.JSONDecodeError:
            # If still invalid, fallback to more reliable method
            return fix_json_advanced(json_str)

    except Exception as e:
        _log_warning(f"⚠️ Error in smart quote escaping: {e}")
        # On any error, fallback to the more reliable method
        return fix_json_advanced(json_str)
def fix_json_advanced(json_str: str) -> str:
    """
    Fix JSON string values using a character-level state machine, for more reliable handling
    of very long and complexly nested strings.

    Improved version: Refined escape character handling, particularly for \n and other control characters.
    Uses a more reliable string boundary detection algorithm to correctly process long text.

    This function parses the string character by character, which is more reliable than regular expressions,
    especially for:
    - Very long strings with many unescaped newlines
    - Strings containing XML/SVG code
    - Strings with quotes, braces, and other special characters

    Args:
        json_str: JSON string that may contain unescaped characters

    Returns:
        The fixed JSON string
    """
    if not json_str:
        return json_str

    # First try to parse directly - if successful, no fix needed
    try:
        json.loads(json_str)
        return json_str
    except json.JSONDecodeError:
        # Continue to attempt fix
        pass

    # Character-level state machine fix
    result = []
    i = 0
    in_string = False
    next_char_escaped = False  # Whether next character is escaped
    brace_depth = 0            # Curly brace nesting, helps detect string boundaries
    bracket_depth = 0          # Square bracket nesting

    while i < len(json_str):
        char = json_str[i]

        # Handle escape sequences
        if next_char_escaped:
            # Current character is escaped, add as is
            result.append(char)
            next_char_escaped = False
            i += 1
            continue

        # Count consecutive backslashes
        if char == '\\':
            j = i
            while j < len(json_str) and json_str[j] == '\\':
                j += 1
            backslash_count = j - i

            # If not in a string value, backslash should be preserved (might be structural)
            if not in_string:
                result.append(char)
                i += 1
                continue

            # Inside a string: decide if this is an escape or a literal
            if backslash_count % 2 == 1:
                # Odd number of backslashes: next char will be escaped
                result.append(char)
                next_char_escaped = True
                i += 1
                continue
            else:
                # Even number of backslashes: all are literal
                result.append('\\\\' * (backslash_count // 2))
                i = j
                continue

        # Handle start/end of a string
        if char == '"':
            if not in_string:
                # Begin string
                in_string = True
                result.append(char)
            else:
                # Check if this is the end of a string
                is_string_end = _is_string_end(json_str, i, brace_depth, bracket_depth)

                if is_string_end:
                    in_string = False
                    result.append(char)
                else:
                    # It's an inner quote, needs escaping
                    result.append('\\"')
            i += 1
            continue

        # Update nesting depths (when not in a string)
        if not in_string:
            if char == '{':
                brace_depth += 1
            elif char == '}':
                brace_depth -= 1
            elif char == '[':
                bracket_depth += 1
            elif char == ']':
                bracket_depth -= 1

        # Inside a string: escape control and special characters
        if in_string:
            # Escape all control chars (JSON does not allow unescaped)
            # If next_char_escaped is True, it was already escaped above so not here
            if ord(char) < 32:  # control character
                if char == '\n':
                    result.append('\\n')
                elif char == '\r':
                    result.append('\\r')
                elif char == '\t':
                    result.append('\\t')
                elif char == '\b':
                    result.append('\\b')
                elif char == '\f':
                    result.append('\\f')
                else:
                    result.append(f'\\u{ord(char):04x}')
            else:
                result.append(char)
        else:
            # Not in string, keep char as is
            result.append(char)

        i += 1

    fixed_json = ''.join(result)

    # Validate the fixed JSON
    try:
        json.loads(fixed_json)
        return fixed_json
    except json.JSONDecodeError:
        # If it's still not valid, just return the original string for other fixers
        return json_str


def _is_string_end(json_str: str, quote_pos: int, brace_depth: int, bracket_depth: int) -> bool:
    """
    Determine if a quote is the end of a string.

    Uses multiple strategies:
    1. Check if the content after quote matches JSON structure
    2. Check brace/bracket depth
    3. Check for clear end markers (comma, right brace, etc)

    Args:
        json_str: The JSON string
        quote_pos: The position of the quote
        brace_depth: Current curly brace nesting depth
        bracket_depth: Current square bracket nesting depth

    Returns:
        True if this is the string's end quote, False if it's an inner quote
    """
    if quote_pos + 1 >= len(json_str):
        # At end of string: definitely end of string
        return True

    # Skip any whitespace after the quote
    next_pos = quote_pos + 1
    while next_pos < len(json_str) and json_str[next_pos] in ' \t\n\r':
        next_pos += 1

    if next_pos >= len(json_str):
        return True

    next_char = json_str[next_pos]

    # If next char is a clear end marker, probably the end of the string
    if next_char in ',}':
        # If brace depth is 0 or 1 and next is }, it's likely the end of a string
        if next_char == '}' and brace_depth <= 1:
            return True
        if next_char == ',':
            return True

    # Special fix: If next char is a colon, this is probably a key end
    if next_char == ':':
        return True

    # Look for patterns like }\n} or }\n  } afterwards (common for tool_name/parameters blocks)
    remaining = json_str[quote_pos + 1:]
    remaining_stripped = remaining.lstrip(' \t\n\r')

    if remaining_stripped.startswith('}\n}') or remaining_stripped.startswith('}\n  }'):
        return True

    # For very long content, expand lookahead
    if len(json_str) > 1000:
        lookahead_size = min(200, len(json_str) - quote_pos - 1)
        lookahead = json_str[quote_pos + 1:quote_pos + 1 + lookahead_size]

        # Check for }\n} or }\n  } pattern
        if '}\n}' in lookahead or '}\n  }' in lookahead:
            first_brace_pos = lookahead.find('}')
            if first_brace_pos > 0:
                before_brace = lookahead[:first_brace_pos]
                quote_count = before_brace.count('"')
                # If there are very few quotes before }, likely string end
                if quote_count <= 2:
                    return True

    # If next char is a plain ASCII/Chinese character, probably not string end
    if next_char.isalnum() or '\u4e00' <= next_char <= '\u9fff':
        return False

    # If next is a quote: could be "key": "value", or could be a quoted string inner quote
    # Conservative: Treat as an inner quote (not end)
    if next_char == '"':
        return False

    # Default: treat as string end if it's a common end marker
    return next_char in ',}]'




def generate_tools_prompt_from_json(tool_definitions: Dict[str, Any], language: str = 'en') -> str:
    """
    Generate tools prompt string from JSON tool definitions for chat-based models.
    
    Args:
        tool_definitions: Dictionary of tool definitions loaded from JSON
        language: Language code ('zh' for Chinese, 'en' for English)
        
    Returns:
        Formatted string containing tool descriptions for chat-based models
    """
    try:
        # For safety, import print_current here to avoid circular imports
        try:
            from tools.print_system import print_current
        except ImportError:
            def print_current(msg):
                print(msg)
        
        if not tool_definitions:
            return ""
        
        prompt_parts = []
        
        # Add header
        prompt_parts.append("## Available Tools")
        prompt_parts.append("")
        prompt_parts.append("Following is the tools you can use to complete tasks. Please call tools using JSON format:")
        prompt_parts.append("")
        prompt_parts.append("```json")
        prompt_parts.append("{")
        prompt_parts.append('  "tool_name": "tool_name",')
        prompt_parts.append('  "parameters": {')
        prompt_parts.append('    "param_name": "param_value"')
        prompt_parts.append("  }")
        prompt_parts.append("}")
        prompt_parts.append("```")
        prompt_parts.append("")
        prompt_parts.append("### Tool List:")
        prompt_parts.append("")
        
        # Add each tool's description
        for tool_name, tool_def in tool_definitions.items():
            description = tool_def.get('description', 'No description available')
            parameters = tool_def.get('parameters', {})
            properties = parameters.get('properties', {})
            required = parameters.get('required', [])
            
            # Tool header
            prompt_parts.append(f"#### {tool_name}")
            prompt_parts.append(f"**Description**: {description}" if language == 'zh' else f"**Description**: {description}")
            prompt_parts.append("")
            
            # Parameters
            if properties:
                prompt_parts.append("**Parameters**:" if language == 'zh' else "**Parameters**:")
                for param_name, param_def in properties.items():
                    param_type = param_def.get('type', 'string')
                    param_desc = param_def.get('description', 'No description')
                    param_required = param_name in required
                    required_marker = " (Required)" if language == 'zh' else " (required)" if param_required else ""
                    
                    # Handle array type
                    if param_type == 'array':
                        items_type = param_def.get('items', {}).get('type', 'string')
                        param_type = f"array[{items_type}]"
                    
                    prompt_parts.append(f"- `{param_name}` ({param_type}){required_marker}: {param_desc}")
                
                prompt_parts.append("")
            else:
                prompt_parts.append("**Parameters**: None" if language == 'zh' else "**Parameters**: None")
                prompt_parts.append("")
            
            # Example usage
            prompt_parts.append("**Example Usage**:")
            
            # Generate example based on tool
            example_params = {}
            for param_name, param_def in properties.items():
                if param_name in required:
                    param_type = param_def.get('type', 'string')
                    if param_type == 'string':
                        example_params[param_name] = "example_value"
                    elif param_type == 'integer':
                        example_params[param_name] = 1
                    elif param_type == 'boolean':
                        example_params[param_name] = True
                    elif param_type == 'array':
                        example_params[param_name] = ["item1", "item2"]
                    elif param_type == 'object':
                        example_params[param_name] = {"key": "value"}
            
            prompt_parts.append("```json")
            prompt_parts.append("{")
            prompt_parts.append(f'  "tool_name": "{tool_name}",')
            prompt_parts.append('  "parameters": {')
            
            if example_params:
                param_lines = []
                for key, value in example_params.items():
                    if isinstance(value, str):
                        param_lines.append(f'    "{key}": "{value}"')
                    else:
                        import json
                        param_lines.append(f'    "{key}": {json.dumps(value)}')
                prompt_parts.append(',\n'.join(param_lines))
            
            prompt_parts.append("  }")
            prompt_parts.append("}")
            prompt_parts.append("```")
            prompt_parts.append("")
            prompt_parts.append("---")
            prompt_parts.append("")
        
        # Add footer instructions
        prompt_parts.append("### Important Notes:")
        prompt_parts.append("1. Please strictly follow the JSON format above for tool calls")
        prompt_parts.append("2. Tool names must match exactly")
        prompt_parts.append("3. Required parameters cannot be omitted")
        prompt_parts.append("4. Parameter types must be correct")
        prompt_parts.append("5. Multiple tools can be called simultaneously")
        
        return "\n".join(prompt_parts)
        
    except Exception as e:
        # For safety, import print_current here to avoid circular imports
        try:
            from tools.print_system import print_current
        except ImportError:
            def print_current(msg):
                print(msg)
                
        print_current(f"⚠️  Error generating tools prompt from JSON: {e}")
        return ""


def generate_tools_prompt_from_xml(tool_definitions: Dict[str, Any], language: str = 'en') -> str:
    """
    Generate tools prompt string from JSON tool definitions for chat-based models using XML format.
    
    Args:
        tool_definitions: Dictionary of tool definitions loaded from JSON
        language: Language code ('zh' for Chinese, 'en' for English)
        
    Returns:
        Formatted string containing tool descriptions for chat-based models in XML format
    """
    try:
        # For safety, import print_current here to avoid circular imports
        try:
            from tools.print_system import print_current
        except ImportError:
            def print_current(msg):
                print(msg)
        
        if not tool_definitions:
            return ""
        
        prompt_parts = []
        
        # Add header
        prompt_parts.append("## Available Tools")
        prompt_parts.append("")
        prompt_parts.append("Following is the tools you can use to complete tasks. Please call tools using XML format:")
        prompt_parts.append("")
        prompt_parts.append("**Correct Format (MUST use this):**")
        prompt_parts.append("```xml")
        prompt_parts.append("<invoke name=\"tool_name\">")
        prompt_parts.append("  <parameter name=\"param_name\">param_value</parameter>")
        prompt_parts.append("</invoke>")
        prompt_parts.append("```")
        prompt_parts.append("")
        prompt_parts.append("**WRONG Formats (NEVER use these):**")
        prompt_parts.append("- `<tool_call>tool_name>` ")
        prompt_parts.append("")
        prompt_parts.append("### Tool List:")
        prompt_parts.append("")
        
        # Add each tool's description
        for tool_name, tool_def in tool_definitions.items():
            description = tool_def.get('description', 'No description available')
            parameters = tool_def.get('parameters', {})
            properties = parameters.get('properties', {})
            required = parameters.get('required', [])
            
            # Tool header
            prompt_parts.append(f"#### {tool_name}")
            prompt_parts.append(f"**Description**: {description}" if language == 'zh' else f"**Description**: {description}")
            prompt_parts.append("")
            
            # Parameters
            if properties:
                prompt_parts.append("**Parameters**:" if language == 'zh' else "**Parameters**:")
                for param_name, param_def in properties.items():
                    param_type = param_def.get('type', 'string')
                    param_desc = param_def.get('description', 'No description')
                    param_required = param_name in required
                    required_marker = " (Required)" if language == 'zh' else " (required)" if param_required else ""
                    
                    # Handle array type
                    if param_type == 'array':
                        items_type = param_def.get('items', {}).get('type', 'string')
                        param_type = f"array[{items_type}]"
                    
                    prompt_parts.append(f"- `{param_name}` ({param_type}){required_marker}: {param_desc}")
                
                prompt_parts.append("")
            else:
                prompt_parts.append("**Parameters**: None" if language == 'zh' else "**Parameters**: None")
                prompt_parts.append("")
            
            # Example usage
            prompt_parts.append("**Example Usage**:")
            
            # Generate example based on tool
            example_params = {}
            for param_name, param_def in properties.items():
                if param_name in required:
                    param_type = param_def.get('type', 'string')
                    if param_type == 'string':
                        example_params[param_name] = "example_value"
                    elif param_type == 'integer':
                        example_params[param_name] = 1
                    elif param_type == 'boolean':
                        example_params[param_name] = True
                    elif param_type == 'array':
                        example_params[param_name] = ["item1", "item2"]
                    elif param_type == 'object':
                        example_params[param_name] = {"key": "value"}
            
            prompt_parts.append("```xml")
            prompt_parts.append(f"<invoke name=\"{tool_name}\">")
            
            if example_params:
                for key, value in example_params.items():
                    if isinstance(value, str):
                        # Escape XML special characters
                        escaped_value = value.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('"', '&quot;').replace("'", '&apos;')
                        prompt_parts.append(f"  <parameter name=\"{key}\">{escaped_value}</parameter>")
                    elif isinstance(value, bool):
                        prompt_parts.append(f"  <parameter name=\"{key}\">{str(value).lower()}</parameter>")
                    elif isinstance(value, (int, float)):
                        prompt_parts.append(f"  <parameter name=\"{key}\">{value}</parameter>")
                    elif isinstance(value, list):
                        # For arrays, use multiple parameter tags or JSON string
                        import json
                        json_str = json.dumps(value)
                        prompt_parts.append(f"  <parameter name=\"{key}\">{json_str}</parameter>")
                    elif isinstance(value, dict):
                        # For objects, use JSON string
                        import json
                        json_str = json.dumps(value)
                        prompt_parts.append(f"  <parameter name=\"{key}\">{json_str}</parameter>")
            
            prompt_parts.append("</invoke>")
            prompt_parts.append("```")
            prompt_parts.append("")
            prompt_parts.append("---")
            prompt_parts.append("")
        
        # Add footer instructions
        prompt_parts.append("### Important Notes:")
        prompt_parts.append("1. Please strictly follow the XML format above for tool calls")
        prompt_parts.append("2. Use <invoke name=\"tool_name\">...</invoke> format for each tool call")
        prompt_parts.append("3. **CRITICAL**: NEVER use <tool_call> or <tool_call>tool_name> format - these are WRONG formats")
        prompt_parts.append("4. **MUST use**: <invoke name=\"tool_name\">...</invoke> format ONLY")
        prompt_parts.append("5. Tool names must match exactly")
        prompt_parts.append("6. Required parameters cannot be omitted")
        prompt_parts.append("7. Parameter types must be correct")
        prompt_parts.append("8. Multiple tools can be called simultaneously by using multiple <invoke> tags")
        prompt_parts.append("9. For array parameters, you can use JSON format within the parameter value, or use multiple <item> tags")
        
        return "\n".join(prompt_parts)
        
    except Exception as e:
        # For safety, import print_current here to avoid circular imports
        try:
            from tools.print_system import print_current
        except ImportError:
            def print_current(msg):
                print(msg)
                
        print_current(f"⚠️  Error generating tools prompt from XML: {e}")
        return ""


def convert_xml_parameter_value(value: str) -> Any:
    """
    Convert XML parameter value to appropriate type.
    
    This function is used in XML parsing to convert string parameter values
    extracted from XML tags to their appropriate Python types (bool, int, list, etc.).
    
    Args:
        value: String value extracted from XML to convert
        
    Returns:
        Converted value (string, int, bool, list, etc.)
    """
    # For certain parameters that may contain meaningful whitespace/formatting,
    # don't strip the value
    value_stripped = value.strip()
    
    # Handle boolean values
    if value_stripped.lower() in ('true', 'false'):
        return value_stripped.lower() == 'true'
    
    # Handle integers
    if value_stripped.isdigit():
        return int(value_stripped)
    
    # Handle negative integers
    if value_stripped.startswith('-') and value_stripped[1:].isdigit():
        return int(value_stripped)
    
    # Handle floating point numbers (positive and negative)
    # This includes numbers like "0.8", "1.0", "-0.5", "3.14", etc.
    try:
        float_value = float(value_stripped)
        # Check if it's actually a float (contains decimal point or scientific notation)
        # If it's a pure integer string like "1", we already handled it above
        # But for cases like "0.8", we need to return float
        if '.' in value_stripped or 'e' in value_stripped.lower() or 'E' in value_stripped:
            return float_value
        # For pure integer strings that weren't caught above (shouldn't happen, but safe)
        # Return as int for backward compatibility
    except (ValueError, TypeError):
        pass
    
    # Handle JSON arrays/objects
    if (value_stripped.startswith('[') and value_stripped.endswith(']')) or (value_stripped.startswith('{') and value_stripped.endswith('}')):
        try:
            return json.loads(value_stripped)
        except json.JSONDecodeError:
            pass
    
    # Decode XML/HTML entities (e.g., &lt; -> <, &gt; -> >, &quot; -> ")
    # This is necessary because XML values extracted from tags may contain entities
    import html
    decoded_value = html.unescape(value)
    
    # Return decoded value (not stripped) for string parameters to preserve formatting
    return decoded_value


def _find_second_json_block_start(content: str) -> int:
    """
    找到第二个```json块的起始位置
    确保第一个JSON块已经完整闭合后再查找第二个
    重要：检查第二个```json块是否在JSON字符串值内部（如code_edit字段的值中）
    
    Args:
        content: 响应内容
        
    Returns:
        int: 第二个```json块的起始位置，如果没找到返回-1
    """
    json_block_marker = '```json'
    first_pos = content.find(json_block_marker)
    if first_pos == -1:
        return -1
    
    # 检查第一个JSON块是否已经完整闭合
    json_start = first_pos + len(json_block_marker)
    first_block_end = content.find('```', json_start)
    
    # 如果第一个块没有闭合，不要查找第二个块（可能还在接收中）
    if first_block_end == -1:
        return -1
    
    # 在第一个块闭合之后查找第二个```json块
    search_start = first_block_end + 3
    second_pos = content.find(json_block_marker, search_start)
    
    # 如果找到了第二个```json块，需要检查它是否在JSON字符串值内部
    if second_pos != -1:
        # 提取第一个JSON块的内容（从```json到```之间）
        json_content = content[json_start:first_block_end].strip()
        
        # 检查第二个```json是否在第一个JSON块的字符串值内部
        # 方法：从第一个JSON块开始到第二个```json位置，检查引号匹配
        # 如果引号数量是奇数，说明第二个```json在字符串值内部
        
        # 计算第二个```json相对于第一个JSON块开始的位置
        second_pos_relative = second_pos - json_start
        
        # 检查从json_start到second_pos之间的引号匹配情况
        check_range = content[json_start:second_pos]
        in_string = False
        escape_next = False
        brace_count = 0
        
        for i, char in enumerate(check_range):
            if escape_next:
                escape_next = False
                continue
            if char == '\\':
                escape_next = True
                continue
            if char == '"' and not escape_next:
                in_string = not in_string
                continue
            if not in_string:
                if char == '{':
                    brace_count += 1
                elif char == '}':
                    brace_count -= 1
        
        # 如果in_string为True，说明第二个```json在字符串值内部，应该忽略
        if in_string:
            # 继续查找下一个```json块（跳过这个在字符串值内部的）
            next_pos = content.find(json_block_marker, second_pos + len(json_block_marker))
            return next_pos if next_pos != -1 else -1
    
    return second_pos


def _has_complete_json_tool_call(content: str) -> bool:
    """
    检测content中是否包含完整的工具调用（支持带```json标记和不带标记的纯JSON格式）
    重要：检查第二个```json块是否在JSON字符串值内部（如code_edit字段的值中）
    
    Args:
        content: 累积的响应内容
        
    Returns:
        bool: 如果检测到完整的工具调用JSON返回True
    """
    # 首先检查是否有```json标记的格式
    json_block_marker = '```json'
    if json_block_marker in content:
        first_pos = content.find(json_block_marker)
        json_start = first_pos + len(json_block_marker)
        first_block_end = content.find('```', json_start)
        
        # 如果第一个块没有闭合，不要停止（可能还在接收中）
        if first_block_end == -1:
            return False
        
        # 查找第二个```json块（必须在第一个块之后）
        # 使用改进的方法，检查第二个```json是否在字符串值内部
        second_pos = _find_second_json_block_start(content)
        # 如果找到第二个```json块，且第一个块已完整，说明有多个工具调用，需要截断
        return second_pos != -1
    
    # 如果没有```json标记，检查是否是纯JSON格式的工具调用
    # 查找 "tool_name" 和 "parameters" 字段
    if '"tool_name"' in content and '"parameters"' in content:
        # 尝试找到第一个完整的JSON对象（以{开始，以}结束）
        try:
            brace_start = content.find('{')
            if brace_start != -1:
                # 尝试找到匹配的闭合括号
                brace_count = 0
                in_string = False
                escape_next = False
                brace_end = -1
                
                for i in range(brace_start, len(content)):
                    char = content[i]
                    if escape_next:
                        escape_next = False
                        continue
                    if char == '\\':
                        escape_next = True
                        continue
                    if char == '"' and not escape_next:
                        in_string = not in_string
                        continue
                    if not in_string:
                        if char == '{':
                            brace_count += 1
                        elif char == '}':
                            brace_count -= 1
                            if brace_count == 0:
                                brace_end = i + 1
                                break
                
                if brace_end > brace_start:
                    # 检查是否包含tool_name和parameters
                    json_str = content[brace_start:brace_end]
                    if '"tool_name"' in json_str and '"parameters"' in json_str:
                        # 尝试解析JSON验证其有效性
                        try:
                            tool_data = json.loads(json_str)
                            if isinstance(tool_data, dict) and 'tool_name' in tool_data and 'parameters' in tool_data:
                                # 检查是否有第二个工具调用
                                remaining_content = content[brace_end:]
                                if '"tool_name"' in remaining_content and '"parameters"' in remaining_content:
                                    return True  # 有多个工具调用
                                return True  # 至少有一个完整的工具调用
                        except:
                            pass
        except:
            pass
    
    return False


def _is_complete_json_tool_call(content: str) -> bool:
    """
    检测content中是否包含完整的工具调用（兼容性方法，调用新的检测方法）
    """
    return _has_complete_json_tool_call(content)


def _ensure_first_json_block_complete(content: str) -> str:
    """
    简化版本：确保第一个```json块有闭合的```标记
    不做复杂的修复，只做基本检查，将修复交给parse_tool_calls处理
    
    Args:
        content: 响应内容
        
    Returns:
        str: 确保第一个JSON块有闭合标记的内容（如果缺失则补全），否则返回原内容
    """
    json_block_marker = '```json'
    first_pos = content.find(json_block_marker)
    
    # 如果没有找到```json标记，直接返回原内容，让parse_tool_calls处理
    if first_pos == -1:
        return content
    
    # 找到第一个```json块的开始位置
    json_start = first_pos + len(json_block_marker)
    
    # 查找第一个```json块的结束位置（闭合的```）
    first_block_end = content.find('```', json_start)
    
    # 如果第一个块已经完整闭合，直接返回
    if first_block_end != -1:
        return content
    
    # 如果第一个块没有闭合，简单补全闭合标记（不做复杂的JSON验证）
    # 只查找第一个匹配的```来闭合，如果找不到就原样返回让parse_tool_calls处理
    return content + '\n```'


def parse_tool_calls_from_json(content: str) -> List[Dict[str, Any]]:
    """
    Parse tool calls from JSON format.
    
    Args:
        content: The model's response text
        
    Returns:
        List of dictionaries with tool name and parameters
    """
    all_tool_calls = []
    
    json_start = content.find('{')
    json_end = content.rfind('}') + 1
    if json_start == -1 or json_end <= json_start:
        return all_tool_calls
    
    json_str = content[json_start:json_end]
    
    try:
        tool_data = json.loads(json_str)
        
        if isinstance(tool_data, dict) and 'tool_name' in tool_data and 'parameters' in tool_data:
            all_tool_calls.append({
                "name": tool_data["tool_name"],
                "arguments": tool_data["parameters"]
            })
    except json.JSONDecodeError:
        # Try to fix JSON with quote escaping
        try:
            fixed_json = fix_json(json_str)
            tool_data = json.loads(fixed_json)
            
            if isinstance(tool_data, dict) and 'tool_name' in tool_data and 'parameters' in tool_data:
                _log_warning(f"✅ Successfully parsed tool calls from JSON using smart fix: {tool_data}")
                all_tool_calls.append({
                    "name": tool_data["tool_name"],
                    "arguments": tool_data["parameters"]
                })
        except (json.JSONDecodeError, Exception):
            # Try robust fix method
            try:
                fixed_json_robust = fix_json_advanced(json_str)
                if fixed_json_robust != json_str:
                    tool_data = json.loads(fixed_json_robust)
                    if isinstance(tool_data, dict) and 'tool_name' in tool_data and 'parameters' in tool_data:
                        _log_warning(f"✅ Successfully parsed tool calls from JSON using advanced fix: {tool_data}")
                        all_tool_calls.append({
                            "name": tool_data["tool_name"],
                            "arguments": tool_data["parameters"]
                        })
            except (json.JSONDecodeError, Exception):
                _log_warning(f"JSON parsing failed with all attempts")
                _log_debug(f"JSON parsing failed with original string: {content}")
    
    return all_tool_calls


def parse_arguments_xml(args_text: str) -> Dict[str, Any]:
    """
    Parse arguments from the given text.
    
    Args:
        args_text: Text containing arguments
        
    Returns:
        Dictionary of argument names and values
    """
    args = {}
    
    # Method 1: Try the traditional <parameter name="...">value</parameter> format
    arg_pattern = r'<parameter name="([^"]+)">(.*?)</parameter>'
    arg_matches = re.findall(arg_pattern, args_text, re.DOTALL)
    for name, value in arg_matches:
        value = value.strip()
        args[name] = convert_xml_parameter_value(value)
    
    # Method 2: Try the direct tag format <tag_name>value</tag_name>
    # This supports the more intuitive XML format that models often generate
    if not args:  # Only try this if the traditional format didn't work
        # Find all XML tags and their content
        direct_tag_pattern = r'<([^/][^>]*?)>(.*?)</\1>'
        direct_matches = re.findall(direct_tag_pattern, args_text, re.DOTALL)
        
        for tag_name, value in direct_matches:
            # Clean up the tag name (remove any attributes)
            tag_name = tag_name.split()[0]
            value = value.strip()
            
            # Handle special cases for array-like structures
            if tag_name == 'target_directories':
                # Handle <target_directories><item>value1</item><item>value2</item></target_directories>
                item_pattern = r'<item[^>]*>(.*?)</item>'
                items = re.findall(item_pattern, value, re.DOTALL)
                if items:
                    args[tag_name] = [item.strip() for item in items]
                else:
                    args[tag_name] = convert_xml_parameter_value(value)
            else:
                args[tag_name] = convert_xml_parameter_value(value)
    
    return args


def parse_function_calls_xml(function_calls_text: str) -> List[Dict[str, Any]]:
    """
    Parse function calls from the given text.
    
    Args:
        function_calls_text: Text containing function calls
        
    Returns:
        List of dictionaries, each representing a function call
    """
    function_calls = []
    # Look for individual function calls
    invoke_pattern = r'<invoke name="([^"]+)">(.*?)</invoke>'
    invokes = re.findall(invoke_pattern, function_calls_text, re.DOTALL)
    for name, args_text in invokes:
        # Parse the arguments
        args = parse_arguments_xml(args_text)
        function_calls.append({"name": name, "arguments": args})
    return function_calls


def fix_wrong_tool_call_format(content: str) -> str:
    """
    Fix wrong tool call format: <tool_call>tool_name> -> <invoke name="tool_name">
    
    Args:
        content: The model's response text that may contain wrong format
        
    Returns:
        Fixed content string
    """
    # Pattern: <tool_call>tool_name> -> <invoke name="tool_name">
    pattern = r'<tool_call>([^<>]+)>'
    
    def replace_tool_call(match):
        tool_name = match.group(1).strip()
        if tool_name:
            # Use print_debug instead of _log_warning
            try:
                from tools.print_system import print_debug
                print_debug(f"⚠️ Detected incorrect tool call format: <tool_call>{tool_name}>, automatically converted to: <invoke name=\"{tool_name}\">")
            except ImportError:
                pass
            return f'<invoke name="{tool_name}">'
        return match.group(0)
    
    fixed_content = re.sub(pattern, replace_tool_call, content)
    
    # If content was fixed, show corrected version using print_debug
    if fixed_content != content:
        try:
            from tools.print_system import print_debug
            display_content = fixed_content
            if len(display_content) > 500:
                display_content = display_content[:500] + "..."
            print_debug(f"✅ Fixed tool call format:\n{display_content}")
        except ImportError:
            pass
    
    return fixed_content


def fix_incomplete_invoke_closing_tags(content: str) -> str:
    """
    Fix incomplete XML invoke closing tags. If an <invoke> tag is not properly closed with </invoke>
    but ends with any </ tag, treat it as closed.
    
    This handles cases like:
    - <invoke name="tool">...</invoke_name> -> <invoke name="tool">...</invoke>
    - <invoke name="tool">...</parameter> -> <invoke name="tool">...</invoke>
    - <invoke name="edit_file">...</edit_file> -> <invoke name="edit_file">...</invoke>
    - <invoke name="tool">...</tool_name> -> <invoke name="tool">...</invoke>
    
    Any closing tag that is not </invoke> (case insensitive) will be replaced with </invoke>,
    except for nested </parameter> tags which are handled separately.
    
    Args:
        content: The model's response text that may contain incomplete closing tags
        
    Returns:
        Fixed content string with properly closed invoke tags
    """
    import re
    
    # Pattern to find <invoke name="..."> that may not be properly closed
    # Match: <invoke name="..."> ... any content ... </anything>
    # But we need to be careful not to match nested tags incorrectly
    
    fixed_content = content
    changes_made = False
    
    # Find all <invoke> start tags
    invoke_start_pattern = r'<invoke\s+name="([^"]+)"[^>]*>'
    
    # Iterate through all invoke tags
    last_pos = 0
    while True:
        start_match = re.search(invoke_start_pattern, fixed_content[last_pos:], re.IGNORECASE)
        if not start_match:
            break
        
        start_pos = last_pos + start_match.start()
        invoke_start = last_pos + start_match.end()
        tool_name = start_match.group(1)
        
        # Look for closing tag from the invoke start position
        # First, try to find proper </invoke> closing tag
        proper_close_match = re.search(r'</invoke\s*>', fixed_content[invoke_start:], re.IGNORECASE)
        
        if proper_close_match:
            # Properly closed, move to after this tag
            last_pos = invoke_start + proper_close_match.end()
            continue
        
        # No proper </invoke> found, look for any </...> tag that might be a mistaken closing
        # Look for closing tags like </invoke_name>, </parameter>, </invoke>, etc.
        # We need to be careful about nested <parameter> tags - count them to find the outermost closing
        any_close_match = re.search(r'</([^>\s]+)\s*>', fixed_content[invoke_start:])
        
        if any_close_match:
            close_pos = invoke_start + any_close_match.start()
            close_tag_name = any_close_match.group(1)
            
            # Check if this is a nested closing (e.g., </parameter> inside parameters)
            # Count open and close parameter tags between invoke_start and close_pos
            between_content = fixed_content[invoke_start:close_pos]
            open_params = len(re.findall(r'<parameter\s+[^>]*>', between_content, re.IGNORECASE))
            close_params = len(re.findall(r'</parameter\s*>', between_content, re.IGNORECASE))
            
            # If close_tag_name is 'parameter' and we have unmatched open parameters, this is nested
            if close_tag_name.lower() == 'parameter' and open_params > close_params:
                # This is a nested </parameter>, skip it and look for the next closing tag
                last_pos = close_pos + any_close_match.end()
                continue
            
            # Only fix if it's not already </invoke> (case insensitive)
            if close_tag_name.lower() != 'invoke':
                # Replace the incorrect closing tag with </invoke>
                fixed_content = (
                    fixed_content[:close_pos] + 
                    '</invoke>' + 
                    fixed_content[close_pos + any_close_match.end():]
                )
                changes_made = True
                try:
                    from tools.print_system import print_debug
                    print_debug(f"⚠️ Fixed incomplete invoke closing tag: </{close_tag_name}> -> </invoke> for tool '{tool_name}'")
                except ImportError:
                    pass
                # Update last_pos to after the fixed closing tag
                last_pos = close_pos + len('</invoke>')
            else:
                last_pos = invoke_start + any_close_match.end()
        else:
            # No closing tag found, can't fix this one
            # Move past the current invoke start to avoid infinite loop
            last_pos = invoke_start + 1
    
    return fixed_content


def parse_tool_calls_from_xml(content: str) -> List[Dict[str, Any]]:
    """
    Parse tool calls from XML format.
    
    Args:
        content: The model's response text
        
    Returns:
        List of dictionaries with tool name and parameters
    """
    # Fix wrong tool call format before parsing
    content = fix_wrong_tool_call_format(content)
    
    # Fix incomplete closing tags (e.g., </invoke_name> -> </invoke>)
    content = fix_incomplete_invoke_closing_tags(content)
    
    all_tool_calls = []
    
    # Try to parse individual <function_call> tags (single format)
    function_call_pattern = r'<function_call>\s*\{(.*?)\}\s*</function_call>'
    function_call_matches = re.findall(function_call_pattern, content, re.DOTALL)
    if function_call_matches:
        for match in function_call_matches:
            try:
                # Parse the JSON content inside function_call tags
                json_str = '{' + match + '}'
                tool_data = json.loads(json_str)
                
                if isinstance(tool_data, dict):
                    # Handle different JSON structures
                    if 'name' in tool_data and 'parameters' in tool_data:
                        all_tool_calls.append({
                            "name": tool_data["name"],
                            "arguments": tool_data["parameters"]
                        })
                    elif 'name' in tool_data and 'content' in tool_data:
                        all_tool_calls.append({
                            "name": tool_data["name"],
                            "arguments": tool_data["content"]
                        })
            except json.JSONDecodeError:
                continue
        
        # If we found function_call format tool calls, return them
        if all_tool_calls:
            return all_tool_calls
    
    # Try to parse XML format with function_calls wrapper
    function_calls_matches = re.findall(r'<function_calls>(.*?)</function_calls>', content, re.DOTALL)
    if function_calls_matches:
        for function_calls_text in function_calls_matches:
            # Parse the function calls in this block
            function_calls = parse_function_calls_xml(function_calls_text)
            if function_calls:
                all_tool_calls.extend(function_calls)
        
        # If we found function_calls wrapper tool calls, return directly
        if all_tool_calls:
            return all_tool_calls
    
    # Only try to parse individual invoke tags if no function_calls wrapper was found
    invoke_pattern = r'<invoke name="([^"]+)">(.*?)</invoke>'
    invoke_matches = re.findall(invoke_pattern, content, re.DOTALL)
    if invoke_matches:
        for tool_name, args_text in invoke_matches:
            args = parse_arguments_xml(args_text)
            all_tool_calls.append({"name": tool_name, "arguments": args})
    
    return all_tool_calls


def parse_python_function_calls(content: str, tool_map: Dict[str, Any]) -> List[Dict[str, Any]]:
    """
    Parse Python-style function calls from the model's response.
    This serves as a fallback for when the model doesn't use the correct XML format.
    
    Args:
        content: The model's response text
        tool_map: Dictionary mapping tool names to tool functions
        
    Returns:
        List of dictionaries, each representing a function call
    """
    function_calls = []
    
    # Pattern to match function calls like: tool_name({"param": "value", ...})
    # Updated pattern to better handle multiline strings and nested braces
    python_pattern = r'(\w+)\s*\(\s*(\{(?:[^{}]|(?:\{[^{}]*\}))*\})\s*\)'
    
    matches = re.findall(python_pattern, content, re.DOTALL)
    
    for tool_name, params_str in matches:
        # Check if this is a valid tool name
        if tool_name in tool_map:
            try:
                # Try to parse the parameters as JSON directly
                # Fix common JSON issues
                params_json = params_str.replace("'", '"')  # Replace single quotes with double quotes
                
                params = json.loads(params_json)
                
                function_calls.append({
                    "name": tool_name,
                    "arguments": params
                })
                
            except json.JSONDecodeError as e:
                continue
    
    return function_calls


def validate_tool_call_json(json_str: str, tool_name: str = "") -> Tuple[bool, Optional[Dict], str]:
    """
    Validate and parse the JSON parameters for a tool call, with auto-fix support for multiple formats.

    Args:
        json_str: The JSON string.
        tool_name: Name of the tool (for logging).

    Returns:
        Tuple of (is_valid, parsed_data, error_message)
    """
    if not json_str or not json_str.strip():
        return False, None, "Empty JSON string"

    # Try parsing directly first
    try:
        data = json.loads(json_str)
        return True, data, ""
    except json.JSONDecodeError as e:
        error_msg = f"JSON parsing failed"
        if tool_name:
            error_msg += f" (tool: {tool_name})"
        error_msg += f": {e.msg} at line {e.lineno} column {e.colno}"

        # Add detailed error context
        lines = json_str.split('\n')
        if 0 <= e.lineno - 1 < len(lines):
            error_line = lines[e.lineno - 1]
            error_msg += f"\nError line: {error_line}"
            if e.colno > 0:
                error_msg += f"\nPosition: {' ' * (e.colno - 1)}^"

        return False, None, error_msg
    except Exception as e:
        return False, None, f"Unexpected error: {str(e)}"
