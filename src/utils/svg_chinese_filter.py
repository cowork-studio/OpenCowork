#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Copyright (c) 2025 OfficeCowork Research Group.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Simplified SVG Chinese font repair filter
Specifically handles SVG charts containing Chinese generated by tools like Mermaid
"""

import mimetypes
import subprocess
import os
import sys
import re
import tempfile
from pandocfilters import toJSONFilter, Image


def convert_foreign_objects_to_text(svg_content):
    """Convert text in foreignObject to standard SVG text elements"""
    def extract_text_from_html(html_content):
        # Remove HTML tags
        text = re.sub(r'<[^>]+>', '', html_content)
        return ' '.join(text.split()).strip()
    
    def replace_foreign_object(match):
        full_match = match.group(0)
        
        # Extract position and size
        x = float(re.search(r'x\s*=\s*["\']([^"\']+)["\']', full_match).group(1)) if re.search(r'x\s*=\s*["\']([^"\']+)["\']', full_match) else 0
        y = float(re.search(r'y\s*=\s*["\']([^"\']+)["\']', full_match).group(1)) if re.search(r'y\s*=\s*["\']([^"\']+)["\']', full_match) else 0
        width = float(re.search(r'width\s*=\s*["\']([^"\']+)["\']', full_match).group(1)) if re.search(r'width\s*=\s*["\']([^"\']+)["\']', full_match) else 100
        height = float(re.search(r'height\s*=\s*["\']([^"\']+)["\']', full_match).group(1)) if re.search(r'height\s*=\s*["\']([^"\']+)["\']', full_match) else 24
        
        # Extract text content
        content_match = re.search(r'<foreignObject[^>]*>(.*?)</foreignObject>', full_match, re.DOTALL)
        if not content_match:
            return ''
            
        inner_content = content_match.group(1)
        text_content = extract_text_from_html(inner_content)
        
        if not text_content:
            return ''
        
        # Generate text element
        text_x = x + width / 2
        text_y = y + height / 2 + 6
        
        return f'''<text x="{text_x}" y="{text_y}" text-anchor="middle" dominant-baseline="central" font-family="Noto Sans CJK SC, WenQuanYi Micro Hei, sans-serif" font-size="16" fill="#333">{text_content}</text>'''
    
    # Replace all foreignObject
    pattern = r'<foreignObject[^>]*>.*?</foreignObject>'
    result = re.sub(pattern, replace_foreign_object, svg_content, flags=re.DOTALL | re.IGNORECASE)
    return result


def add_chinese_font_support(svg_content):
    """Add Chinese font support for SVG"""
    # Add CJK font styles with higher specificity
    cjk_style = '''<style type="text/css">
svg, text, tspan, .taskText, .sectionTitle, .titleText {
    font-family: "Noto Sans CJK SC", "Noto Serif CJK SC", "WenQuanYi Micro Hei", "SimHei", "Microsoft YaHei", sans-serif !important;
}
* {
    font-family: "Noto Sans CJK SC", "Noto Serif CJK SC", "WenQuanYi Micro Hei", "SimHei", "Microsoft YaHei", sans-serif !important;
}
</style>'''

    # Insert styles after <svg> tag
    def insert_style(match):
        return match.group(1) + cjk_style

    result, num = re.subn(r'(<svg[^>]*>)', insert_style, svg_content, count=1, flags=re.IGNORECASE)
    if num == 0:
        result = cjk_style + svg_content

    # Also replace any inline font-family attributes
    result = re.sub(
        r'font-family="[^"]*"',
        'font-family="Noto Sans CJK SC, WenQuanYi Micro Hei, SimHei, Microsoft YaHei, sans-serif"',
        result,
        flags=re.IGNORECASE
    )

    # For text elements without font-family, add it explicitly
    # Only add to text elements that don't already have font-family
    def add_font_to_text(match):
        text_tag = match.group(1)
        if 'font-family' not in text_tag:
            return text_tag + ' font-family="Noto Sans CJK SC, WenQuanYi Micro Hei, SimHei, Microsoft YaHei, sans-serif"' + match.group(2)
        else:
            return match.group(0)

    result = re.sub(
        r'(<text[^>]*)(>)',
        add_font_to_text,
        result,
        flags=re.IGNORECASE
    )

    return result


def convert_svg_to_pdf(svg_path, pdf_path):
    """Use CairoSVG to convert SVG to PDF"""
    try:
        import cairosvg
        cairosvg.svg2pdf(url=svg_path, write_to=pdf_path)
        return True
    except ImportError:
        sys.stderr.write("CairoSVG not available, trying Inkscape...\n")
        return convert_with_inkscape(svg_path, pdf_path)
    except Exception as e:
        sys.stderr.write(f"CairoSVG conversion failed: {e}\n")
        return convert_with_inkscape(svg_path, pdf_path)


def convert_with_inkscape(svg_path, pdf_path):
    """Use Inkscape conversion (backup plan)"""
    import shutil
    inkscape = shutil.which('inkscape')
    if not inkscape:
        return False
    
    try:
        cmd = [inkscape, svg_path, '--export-type=pdf', '--export-text-to-path', f'--export-filename={pdf_path}']
        result = subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return result == 0
    except Exception:
        return False


def generate_title_from_filename(src):
    """Generate appropriate title based on filename"""
    import os
    # Get filename (without path and extension)
    base_name = os.path.splitext(os.path.basename(src))[0]
    
    # If it's a SHA-encoded filename (starting with mermaid_sha)
    if base_name.startswith('mermaid_sha'):
        return None
    
    # New logic: directly use filename as title
    # Filename has been sanitized
    title = base_name.replace('_', ' ')
    return title

def convert_css_background_to_svg(svg_content: str) -> str:
    """
    将SVG中的CSS background样式转换为SVG标准元素
    
    很多SVG转换工具（如CairoSVG、Inkscape）不支持CSS的background属性，
    需要将其转换为SVG的<rect>元素和<linearGradient>元素。
    """
    import re
    import math
    import random
    
    try:
        # 查找SVG标签中的style属性，包含background
        pattern = r'<svg([^>]*?)(style\s*=\s*["\']([^"\']*?)["\'])([^>]*?)>'
        match = re.search(pattern, svg_content, re.IGNORECASE | re.DOTALL)
        
        if not match:
            return svg_content  # 没有找到style属性，直接返回
        
        svg_attrs_before = match.group(1)
        style_attr = match.group(2)
        style_content = match.group(3)
        svg_attrs_after = match.group(4)
        
        # 检查style中是否包含background
        if 'background' not in style_content.lower():
            return svg_content  # 没有background，直接返回
        
        # 提取SVG的width和height属性
        width_match = re.search(r'width\s*=\s*["\'](\d+)["\']', svg_content, re.IGNORECASE)
        height_match = re.search(r'height\s*=\s*["\'](\d+)["\']', svg_content, re.IGNORECASE)
        
        width = width_match.group(1) if width_match else '900'
        height = height_match.group(1) if height_match else '650'
        
        # 解析background样式
        bg_match = re.search(r'background\s*:\s*linear-gradient\s*\(([^)]+)\)', style_content, re.IGNORECASE)
        
        if not bg_match:
            # 如果不是linear-gradient，尝试提取纯色背景
            color_match = re.search(r'background\s*:\s*([#\w]+)', style_content, re.IGNORECASE)
            if color_match:
                bg_color = color_match.group(1)
                bg_rect = f'<rect x="0" y="0" width="{width}" height="{height}" fill="{bg_color}"/>'
                new_style = re.sub(r'background\s*:[^;]+;?\s*', '', style_content, flags=re.IGNORECASE).strip()
                if new_style:
                    new_svg_tag = f'<svg{svg_attrs_before}style="{new_style}"{svg_attrs_after}>'
                else:
                    new_svg_tag = f'<svg{svg_attrs_before}{svg_attrs_after}>'
                new_svg_content = svg_content.replace(match.group(0), new_svg_tag + bg_rect)
                return new_svg_content
            return svg_content
        
        # 解析linear-gradient参数
        grad_params = bg_match.group(1)
        angle_match = re.search(r'(\d+)deg', grad_params, re.IGNORECASE)
        angle = int(angle_match.group(1)) if angle_match else 0
        stops = re.findall(r'([#\w]+)\s+(\d+)%', grad_params)
        
        if not stops or len(stops) < 2:
            return svg_content
        
        grad_id = f'bgGrad_{random.randint(1000, 9999)}'
        rad = math.radians(angle)
        x1 = 0.5 - 0.5 * math.cos(rad)
        y1 = 0.5 - 0.5 * math.sin(rad)
        x2 = 0.5 + 0.5 * math.cos(rad)
        y2 = 0.5 + 0.5 * math.sin(rad)
        
        gradient_def = f'<defs><linearGradient id="{grad_id}" x1="{x1:.3f}" y1="{y1:.3f}" x2="{x2:.3f}" y2="{y2:.3f}">'
        for color, offset in stops:
            gradient_def += f'<stop offset="{offset}%" style="stop-color:{color};stop-opacity:1" />'
        gradient_def += '</linearGradient></defs>'
        
        bg_rect = f'<rect x="0" y="0" width="{width}" height="{height}" fill="url(#{grad_id})"/>'
        new_style = re.sub(r'background\s*:[^;]+;?\s*', '', style_content, flags=re.IGNORECASE).strip()
        
        if new_style:
            new_svg_tag = f'<svg{svg_attrs_before}style="{new_style}"{svg_attrs_after}>'
        else:
            new_svg_tag = f'<svg{svg_attrs_before}{svg_attrs_after}>'
        
        if '<defs>' in svg_content:
            defs_pattern = r'(<defs[^>]*>)'
            defs_match = re.search(defs_pattern, svg_content, re.IGNORECASE)
            if defs_match:
                new_svg_content = svg_content.replace(match.group(0), new_svg_tag)
                new_svg_content = new_svg_content.replace(defs_match.group(0), defs_match.group(0) + f'<linearGradient id="{grad_id}" x1="{x1:.3f}" y1="{y1:.3f}" x2="{x2:.3f}" y2="{y2:.3f}">' + ''.join([f'<stop offset="{offset}%" style="stop-color:{color};stop-opacity:1" />' for color, offset in stops]) + '</linearGradient>', 1)
                first_element_pattern = r'(</defs>\s*)(<[^/])'
                first_element_match = re.search(first_element_pattern, new_svg_content, re.IGNORECASE)
                if first_element_match:
                    new_svg_content = new_svg_content.replace(first_element_match.group(0), first_element_match.group(1) + bg_rect + '\n' + first_element_match.group(2), 1)
                else:
                    new_svg_content = new_svg_content.replace('</defs>', '</defs>' + bg_rect, 1)
            else:
                new_svg_content = svg_content.replace(match.group(0), new_svg_tag + gradient_def + bg_rect)
        else:
            new_svg_content = svg_content.replace(match.group(0), new_svg_tag + gradient_def + bg_rect)
        
        return new_svg_content
        
    except Exception as e:
        sys.stderr.write(f"⚠️ Error converting CSS background to SVG: {e}\n")
        return svg_content


def process_svg_file(src):
    """Process SVG file, convert to PDF and return PDF filename"""
    # Check if it's an SVG file
    mime_type, _ = mimetypes.guess_type(src)
    if mime_type != 'image/svg+xml':
        return None
        
    base_name, _ = os.path.splitext(src)
    pdf_name = base_name + ".pdf"
    
    # Check if regeneration is needed
    try:
        pdf_mtime = os.path.getmtime(pdf_name)
    except OSError:
        pdf_mtime = -1
        
    if pdf_mtime < os.path.getmtime(src):
        # Process SVG file
        try:
            with open(src, 'r', encoding='utf-8') as f:
                svg_content = f.read()
            
            # Convert CSS background to SVG standard elements
            svg_content = convert_css_background_to_svg(svg_content)
            
            # Convert foreignObject to text element
            svg_content = convert_foreign_objects_to_text(svg_content)
            
            # Add Chinese font support
            svg_content = add_chinese_font_support(svg_content)
            
            # Create temporary file
            with tempfile.NamedTemporaryFile('w', suffix='.svg', delete=False, encoding='utf-8') as tmp_file:
                tmp_file.write(svg_content)
                temp_svg = tmp_file.name
            
            try:
                # Convert to PDF
                success = convert_svg_to_pdf(temp_svg, pdf_name)
                if success:
                    sys.stderr.write(f"Successfully converted {src} to {pdf_name}\n")
                    return pdf_name
                else:
                    sys.stderr.write(f"Failed to convert {src}\n")
                    return None
            finally:
                # Clean up temporary files
                if os.path.exists(temp_svg):
                    os.remove(temp_svg)
        except Exception as e:
            sys.stderr.write(f"Error processing {src}: {e}\n")
            return None
    
    return pdf_name


def svg_to_pdf_filter(key, value, fmt, meta):
    """Pandoc filter main function"""
    
    # Process RawInline HTML img tags (for Mermaid charts)
    if key == 'RawInline' and fmt in ['latex', 'beamer']:
        format_type, content = value
        if format_type == 'html' and '<img' in content and '.svg' in content:
            # Extract src attribute from HTML img tag
            src_match = re.search(r'src=["\']([^"\']*\.svg)["\']', content)
            alt_match = re.search(r'alt=["\']([^"\']*)["\']', content)
            
            if src_match:
                src = src_match.group(1)
                alt = alt_match.group(1) if alt_match else ""
                
                # Process SVG to PDF conversion
                pdf_name = process_svg_file(src)
                if pdf_name:
                    from pandocfilters import Str
                    # Use alt text if available and meaningful, otherwise fall back to filename
                    if alt and alt.strip() and not alt.strip().startswith('svg_'):
                        # Use alt text from HTML img tag as caption
                        return Image(['', [], []], [Str(alt)], [pdf_name, "fig:"])
                    else:
                        # Fall back to filename-based title
                        title = generate_title_from_filename(src)
                        if title:
                            # Use filename as title
                            return Image(['', [], []], [Str(title)], [pdf_name, "fig:"])
                        else:
                            # SHA-encoded filename, use alt if available
                            return Image(['', [], []], [Str(alt)] if alt else [Str("Figure")], [pdf_name, "fig:"])
    
    # Process standard Image element
    if key == 'Image' and fmt in ['latex', 'beamer']:
        attrs, alt, [src, title] = value
        
        # Check if it's an SVG file
        mime_type, _ = mimetypes.guess_type(src)
        if mime_type == 'image/svg+xml':
            base_name, _ = os.path.splitext(src)
            pdf_name = base_name + ".pdf"
            
            # Check if regeneration is needed
            try:
                pdf_mtime = os.path.getmtime(pdf_name)
            except OSError:
                pdf_mtime = -1
                
            if pdf_mtime < os.path.getmtime(src):
                # Process SVG file
                with open(src, 'r', encoding='utf-8') as f:
                    svg_content = f.read()
                
                # Convert foreignObject to text element
                svg_content = convert_foreign_objects_to_text(svg_content)
                
                # Add Chinese font support
                svg_content = add_chinese_font_support(svg_content)
                
                # Create temporary file
                with tempfile.NamedTemporaryFile('w', suffix='.svg', delete=False, encoding='utf-8') as tmp_file:
                    tmp_file.write(svg_content)
                    temp_svg = tmp_file.name
                
                try:
                    # Convert to PDF
                    success = convert_svg_to_pdf(temp_svg, pdf_name)
                    if success:
                        sys.stderr.write(f"Successfully converted {src} to {pdf_name}\n")
                    else:
                        sys.stderr.write(f"Failed to convert {src}\n")
                finally:
                    # Clean up temporary files
                    if os.path.exists(temp_svg):
                        os.remove(temp_svg)
            
            # Use alt text from markdown as caption if available and meaningful
            # alt is a list of inline elements, convert to string
            alt_text = ""
            if alt and len(alt) > 0:
                # Extract text from alt inline elements
                alt_parts = []
                for inline in alt:
                    if isinstance(inline, dict) and inline.get('t') == 'Str':
                        alt_parts.append(inline.get('c', ''))
                    elif isinstance(inline, str):
                        alt_parts.append(inline)
                alt_text = ''.join(alt_parts).strip()
            
            # Use alt text if available and meaningful, otherwise fall back to filename
            if alt_text and not alt_text.startswith('svg_'):
                # Use alt text from markdown as caption
                return Image(attrs, alt, [pdf_name, "fig:"])
            else:
                # Fall back to filename-based title
                filename_title = generate_title_from_filename(src)
                if filename_title:
                    # Use filename as title
                    return Image(attrs, [{"t": "Str", "c": filename_title}], [pdf_name, "fig:"])
                else:
                    # SHA-encoded filename, use alt if available
                    return Image(attrs, alt, [pdf_name, title])


if __name__ == "__main__":
    toJSONFilter(svg_to_pdf_filter)