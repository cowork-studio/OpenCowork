<!DOCTYPE html>
<html lang="{{ 'zh-CN' if lang == 'zh' else 'en' }}">
<head>
    <!-- 在页面渲染前立即设置主题，避免闪烁 - 必须在所有CSS之前执行 -->
    <script>
        (function() {
            // 从localStorage读取保存的主题，默认为light
            const savedTheme = localStorage.getItem('theme') || 'light';
            // 立即设置主题属性，避免页面加载时的闪烁
            document.documentElement.setAttribute('data-theme', savedTheme);
            // 立即设置html和body的背景色，避免闪屏（在CSS加载前就应用）
            const bgColor = savedTheme === 'light' ? '#ffffff' : '#1e1e1e';
            document.documentElement.style.backgroundColor = bgColor;
            // 如果body已存在，立即设置；否则在DOMContentLoaded时设置
            if (document.body) {
                document.body.style.backgroundColor = bgColor;
            } else {
                document.addEventListener('DOMContentLoaded', function() {
                    document.body.style.backgroundColor = bgColor;
                });
            }
        })();
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% if is_app_mode %}{{ app_name }}{% else %}{{ i18n.app_title.replace(' GUI', '') }}{% endif %}</title>
    <link href="{{ url_for('static', filename='css/fontawesome.min.css') }}" rel="stylesheet">
    <!-- Prism.js for syntax highlighting -->
    <link href="{{ url_for('static', filename='css/prism-tomorrow.min.css') }}" rel="stylesheet">
    <!-- Custom Prism.js override styles for better visibility -->
    <style>
        /* ============================================
           CSS Color Variables - Theme System
           ============================================ */
        :root {
            /* Dark Theme (Fallback) */
            --bg-primary: #1e1e1e;
            --bg-secondary: #2d2d30;
            --bg-tertiary: #252526;
            --bg-input: #1e1e1e;
            --bg-container: #1e1e1e;
            --bg-sidebar: #252526;
            --bg-chat: #1e1e1e;
            --bg-chat-header: #2d2d30;
            --bg-input-container: #2d2d30;
            --bg-user-auth: #2d2d30;
            --bg-main: #252526;
            --bg-message-user: #0e639c;
            --bg-message-system: #264f78;
            --bg-message-info: #1a1a1a;
            --bg-message-error: #5a1d1d;
            --bg-message-success: #0f5132;
            --bg-json-collapsible: #0f5132;
            --bg-directory-item: #1e1e1e;
            --bg-directory-item-hover: #2d2d30;
            --bg-directory-item-expanded: #1e1e1e;
            --bg-directory-item-selected: linear-gradient(135deg, #007acc 0%, #005a9e 100%);
            --bg-directory-item-last: #1e1e1e;
            --bg-file-tree: #1e1e1e;
            --bg-upload-area: #1e1e1e;
            --bg-upload-area-hover: #2d2d30;
            --bg-upload-btn: #007acc;
            --bg-upload-btn-hover: #005a9e;
            --bg-progress-bar: #3e3e42;
            --bg-progress-fill: #007acc;
            --bg-send-button: rgba(74, 144, 226, 0.8);
            --bg-send-button-hover: rgba(53, 122, 189, 0.9);
            --bg-send-button-disabled: #3e3e42;
            --bg-scroll-hint: #007acc;
            --bg-scroll-hint-hover: #005a9e;
            
            --text-primary: #cccccc;
            --text-secondary: #9cdcfe;
            --text-tertiary: #569cd6;
            --text-header: #cccccc;
            --text-header-title: #569cd6;
            --text-label: #cccccc;
            --text-placeholder: #6a6a6a;
            --text-user: white;
            --text-system: #9cdcfe;
            --text-info: #cccccc;
            --text-error: #f48771;
            --text-success: #75b798;
            --text-json-title: #75b798;
            --text-json-content: #cccccc;
            --text-directory-name: #cccccc;
            --text-directory-info: #9cdcfe;
            --text-task-description: #cccccc;
            --text-file-item: #ffffff;
            --text-file-item-directory: #9cdcfe;
            --text-upload-hint: #9cdcfe;
            --text-progress: #9cdcfe;
            --link-color: #4a9eff;
            --link-color-hover: #6bb3ff;
            
            --border-primary: #3e3e42;
            --border-secondary: #3e3e42;
            --border-focus: #007acc;
            --border-resizer: #3e3e42;
            --border-resizer-hover: #569cd6;
            --border-resizer-active: #007acc;
            --border-message-system: #007acc;
            --border-message-info: #569cd6;
            --border-message-error: #f14c4c;
            --border-message-success: #198754;
            --border-json-collapsible: #198754;
            --border-directory-item: #3e3e42;
            --border-directory-item-hover: #569cd6;
            --border-directory-item-expanded: #3e3e42;
            --border-directory-item-selected: #007acc;
            --border-directory-item-last: #3e3e42;
            --border-file-tree: #3e3e42;
            --border-upload-area: #569cd6;
            --border-upload-area-hover: #007acc;
            
            --color-accent: #569cd6;
            --color-accent-hover: #007acc;
            --color-action-btn: #9cdcfe;
            --color-action-btn-hover: #569cd6;
            --color-rename-btn: #ffc107;
            --color-delete-btn: #ff6b6b;
            --color-connect-success: #28a745;
            --color-connect-success-hover: #218838;
            --color-connect-disabled: #6c757d;
            --color-connect-disabled-hover: #5a6268;
            
            --shadow-focus: rgba(0, 122, 204, 0.2);
            --shadow-directory-selected: rgba(0, 122, 204, 0.3);
            --shadow-scroll-hint: rgba(0, 122, 204, 0.4);
            --shadow-scroll-hint-hover: rgba(0, 122, 204, 0.6);
            
            --resizer-indicator: rgba(255, 255, 255, 0.3);
            --resizer-indicator-hover: rgba(255, 255, 255, 0.6);
            
            /* Code syntax highlighting colors for dark theme */
            --code-text: #ffffff;
            --code-bg: #1e1e1e;
            --code-border: #404040;
            --code-inline-bg: #2d2d2d;
            --code-comment: #6a9955;
            --code-punctuation: #d4d4d4;
            --code-property: #569cd6;
            --code-number: #b5cea8;
            --code-string: #ce9178;
            --code-operator: #d4d4d4;
            --code-keyword: #c586c0;
            --code-function: #dcdcaa;
            --code-variable: #9cdcfe;
        }
        
        [data-theme="light"] {
            /* Light Theme */
            --bg-primary: #ffffff;
            --bg-secondary: #e8eaed;
            --bg-tertiary: #f3f3f3;
            --bg-input: #ffffff;
            --bg-container: #ffffff;
            --bg-sidebar: #fafafa;
            --bg-chat: #ffffff;
            --bg-chat-header: #e8eaed;
            --bg-input-container: #e8eaed;
            --bg-user-auth: #e8eaed;
            --bg-main: #f3f3f3;
            --bg-message-user: #b3d9ff;
            --bg-message-system: #cfe8fc;
            --bg-message-info: #e8eaed;
            --bg-message-error: #ffeef0;
            --bg-message-success: #c3f0d3;
            --bg-json-collapsible: #c3f0d3;
            --bg-directory-item: #f5f5f0;
            --bg-directory-item-hover: #e8eaed;
            --bg-directory-item-expanded: #f5f5f0;
            --bg-directory-item-selected: linear-gradient(135deg, #0366d6 0%, #005cc5 100%);
            --bg-directory-item-last: #f5f5f0;
            --bg-file-tree: #ffffff;
            --bg-upload-area: #ffffff;
            --bg-upload-area-hover: #e8eaed;
            --bg-upload-btn: #0366d6;
            --bg-upload-btn-hover: #005cc5;
            --bg-progress-bar: #d0d7de;
            --bg-progress-fill: #0366d6;
            --bg-send-button: rgba(3, 102, 214, 0.9);
            --bg-send-button-hover: rgba(3, 102, 214, 1);
            --bg-send-button-disabled: #d0d7de;
            --bg-scroll-hint: #0366d6;
            --bg-scroll-hint-hover: #005cc5;
            
            --text-primary: #24292e;
            --text-secondary: #0366d6;
            --text-tertiary: #0366d6;
            --text-header: #24292e;
            --text-header-title: #0366d6;
            --text-label: #24292e;
            --text-placeholder: #6a737d;
            --text-user: #1a1a1a;
            --text-system: #0052a3;
            --text-info: #24292e;
            --text-error: #d73a49;
            --text-success: #1a6b2d;
            --text-json-title: #1a6b2d;
            --text-json-content: #24292e;
            --text-directory-name: #24292e;
            --text-directory-info: #0366d6;
            --text-task-description: #1a1a1a;
            --text-file-item: #24292e;
            --text-file-item-directory: #0366d6;
            --text-upload-hint: #0366d6;
            --text-progress: #0366d6;
            
            --border-primary: #d0d7de;
            --border-secondary: #d0d7de;
            --border-focus: #0366d6;
            --border-resizer: #f0f0f0;
            --border-resizer-hover: #0366d6;
            --border-resizer-active: #005cc5;
            --border-message-system: #0366d6;
            --border-message-info: #0366d6;
            --border-message-error: #d73a49;
            --border-message-success: #22863a;
            --border-json-collapsible: #22863a;
            --border-directory-item: #d0d7de;
            --border-directory-item-hover: #0366d6;
            --border-directory-item-expanded: #d0d7de;
            --border-directory-item-selected: #0366d6;
            --border-directory-item-last: #d0d7de;
            --border-file-tree: #d0d7de;
            --border-upload-area: #0366d6;
            --border-upload-area-hover: #005cc5;
            
            --color-accent: #0366d6;
            --color-accent-hover: #005cc5;
            --color-action-btn: #0366d6;
            --color-action-btn-hover: #0366d6;
            --color-rename-btn: #ffc107;
            --color-delete-btn: #d73a49;
            --color-connect-success: #28a745;
            --color-connect-success-hover: #218838;
            --color-connect-disabled: #6c757d;
            --color-connect-disabled-hover: #5a6268;
            
            --shadow-focus: rgba(3, 102, 214, 0.2);
            --shadow-directory-selected: rgba(3, 102, 214, 0.3);
            --shadow-scroll-hint: rgba(3, 102, 214, 0.4);
            --shadow-scroll-hint-hover: rgba(3, 102, 214, 0.6);
            
            --resizer-indicator: rgba(0, 0, 0, 0.15);
            --resizer-indicator-hover: rgba(0, 0, 0, 0.3);
            
            /* Code syntax highlighting colors for light theme */
            --code-text: #1a1a1a;
            --code-bg: #ffffff;
            --code-border: #d0d0d0;
            --code-inline-bg: #f5f5f5;
            --code-comment: #6a9955;
            --code-punctuation: #586069;
            --code-property: #005cc5;
            --code-number: #005cc5;
            --code-string: #032f62;
            --code-operator: #586069;
            --code-keyword: #d73a49;
            --code-function: #6f42c1;
            --code-variable: #e36209;
        }

        /* Light theme specific styles - transparent borders for dividers */
        [data-theme="light"] .sidebar {
            border-left: 1px solid transparent;
        }
        
        /* Override Prism.js with theme-aware code preview */
        .preview-modal code[class*="language-"],
        .preview-modal pre[class*="language-"] {
            color: var(--code-text) !important;
            background: var(--code-bg) !important;
            font-weight: normal !important;
        }
        
        .preview-modal pre[class*="language-"] {
            background: var(--code-bg) !important;
            border: 1px solid var(--code-border) !important;
        }
        
        .preview-modal :not(pre) > code[class*="language-"] {
            background: var(--code-inline-bg) !important;
            color: var(--code-text) !important;
            font-weight: normal !important;
        }
        
        /* Syntax highlighting tokens with theme-aware colors */
        .preview-modal .token.comment,
        .preview-modal .token.prolog,
        .preview-modal .token.doctype,
        .preview-modal .token.cdata {
            color: var(--code-comment) !important;
        }
        
        .preview-modal .token.punctuation {
            color: var(--code-punctuation) !important;
        }
        
        .preview-modal .token.property,
        .preview-modal .token.tag,
        .preview-modal .token.constant,
        .preview-modal .token.symbol,
        .preview-modal .token.deleted {
            color: var(--code-property) !important;
        }
        
        .preview-modal .token.boolean,
        .preview-modal .token.number {
            color: var(--code-number) !important;
        }
        
        .preview-modal .token.selector,
        .preview-modal .token.attr-name,
        .preview-modal .token.string,
        .preview-modal .token.char,
        .preview-modal .token.builtin,
        .preview-modal .token.inserted {
            color: var(--code-string) !important;
        }
        
        .preview-modal .token.operator,
        .preview-modal .token.entity,
        .preview-modal .token.url,
        .preview-modal .language-css .token.string,
        .preview-modal .style .token.string {
            color: var(--code-operator) !important;
        }
        
        .preview-modal .token.atrule,
        .preview-modal .token.attr-value,
        .preview-modal .token.keyword {
            color: var(--code-keyword) !important;
        }
        
        .preview-modal .token.function,
        .preview-modal .token.class-name {
            color: var(--code-function) !important;
        }
        
        .preview-modal .token.regex,
        .preview-modal .token.important,
        .preview-modal .token.variable {
            color: var(--code-variable) !important;
        }
        
        .preview-modal .token.important,
        .preview-modal .token.bold {
            font-weight: bold !important;
        }
        
        .preview-modal .token.italic {
            font-style: italic !important;
        }
    </style>
    <!-- PDF.js -->
    <script src="{{ url_for('static', filename='js/pdf.min.js') }}"></script>
    <!-- MathJax for mathematical formulas with fallback -->
    <script>
        // MathJax配置
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            startup: {
                ready() {
                    MathJax.startup.defaultReady();
                    window.mathJaxAvailable = true;
                }
            }
        };

        // MathJax加载状态
        window.mathJaxAvailable = false;
        window.mathJaxLoadAttempted = false;

        // 保护单独的$符号，避免被误识别为数学公式
        function protectLoneDollarSigns(htmlContent) {
            if (!htmlContent) return htmlContent;
            
            // 创建一个临时标记来保护已存在的HTML标签和代码块
            const placeholders = [];
            let placeholderIndex = 0;
            
            // 保护代码块和pre标签中的内容
            htmlContent = htmlContent.replace(/<pre[^>]*>[\s\S]*?<\/pre>/gi, function(match) {
                const placeholder = `__CODE_BLOCK_${placeholderIndex}__`;
                placeholders[placeholderIndex] = match;
                placeholderIndex++;
                return placeholder;
            });
            
            // 保护行内代码
            htmlContent = htmlContent.replace(/<code[^>]*>[\s\S]*?<\/code>/gi, function(match) {
                const placeholder = `__CODE_INLINE_${placeholderIndex}__`;
                placeholders[placeholderIndex] = match;
                placeholderIndex++;
                return placeholder;
            });
            
            // 保护已存在的数学公式标记（MathJax处理后的）
            htmlContent = htmlContent.replace(/<span[^>]*class="[^"]*math[^"]*"[^>]*>[\s\S]*?<\/span>/gi, function(match) {
                const placeholder = `__MATH_SPAN_${placeholderIndex}__`;
                placeholders[placeholderIndex] = match;
                placeholderIndex++;
                return placeholder;
            });
            
            // 保护块级数学公式
            htmlContent = htmlContent.replace(/<div[^>]*class="[^"]*math[^"]*"[^>]*>[\s\S]*?<\/div>/gi, function(match) {
                const placeholder = `__MATH_DIV_${placeholderIndex}__`;
                placeholders[placeholderIndex] = match;
                placeholderIndex++;
                return placeholder;
            });
            
            // 先保护货币符号模式：$后面直接跟数字（如 $94,189, $1, $100等）
            // 使用span包裹并添加tex2jax_ignore类，防止MathJax处理
            const protectedCurrency = [];
            let currencyIndex = 0;
            
            // 匹配货币符号：$后面跟数字，可能包含逗号、小数点等
            // 模式：$数字（可能包含逗号、小数点），后面不能是$、数字或字母（避免匹配到公式或变量）
            // 使用负向前瞻确保后面是空格、标点符号或结束
            // 注意：要匹配完整的金额，包括可能的小数部分
            htmlContent = htmlContent.replace(/\$(\d{1,3}(?:,\d{3})*(?:\.\d+)?|\d+\.\d+|\d+)(?![$\d\w])/g, function(match, amount) {
                const placeholder = `__CURRENCY_${currencyIndex}__`;
                // 使用span包裹并添加tex2jax_ignore类，防止MathJax处理
                // 在tex2jax_ignore类中，可以直接使用$符号，MathJax不会处理
                protectedCurrency[currencyIndex] = `<span class="tex2jax_ignore">$` + amount + `</span>`;
                currencyIndex++;
                return placeholder;
            });
            
            // 保护块级公式 $$...$$
            const protectedFormulas = [];
            let formulaIndex = 0;
            
            htmlContent = htmlContent.replace(/\$\$[\s\S]*?\$\$/g, function(match) {
                const placeholder = `__FORMULA_BLOCK_${formulaIndex}__`;
                protectedFormulas[formulaIndex] = match;
                formulaIndex++;
                return placeholder;
            });
            
            // 保护行内公式 $...$，使用更严格的匹配规则
            // 要求：$后面不能是空格，公式内容必须在一行内，且包含数学相关字符
            htmlContent = htmlContent.replace(/\$([^\s$\n][^$\n]{0,200}?)\$/g, function(match, formula) {
                // 检查是否是有效的数学公式
                // 必须包含数学符号、希腊字母、或常见的数学表达式模式
                const mathPattern = /[a-zA-Zα-ωΑ-Ω+\-*/=<>≤≥≠≈∑∏∫∞±√^_()\[\]{}]|\\[a-zA-Z]+|frac|sqrt|sum|prod|int|lim|sin|cos|tan|log|ln|exp/;
                if (mathPattern.test(formula) && formula.trim().length > 0) {
                    const placeholder = `__FORMULA_INLINE_${formulaIndex}__`;
                    protectedFormulas[formulaIndex] = match;
                    formulaIndex++;
                    return placeholder;
                }
                // 如果不是有效的数学公式，转义两个$符号
                return '<span class="tex2jax_ignore">&#36;' + formula + '&#36;</span>';
            });
            
            // 转义所有剩余的单独$符号（不在公式中的），并用span包裹防止MathJax处理
            // 注意：此时货币符号已经被占位符替换，所以不会影响货币符号
            htmlContent = htmlContent.replace(/\$/g, '<span class="tex2jax_ignore">&#36;</span>');
            
            // 恢复被保护的货币符号
            for (let i = currencyIndex - 1; i >= 0; i--) {
                htmlContent = htmlContent.replace(`__CURRENCY_${i}__`, protectedCurrency[i]);
            }
            
            // 恢复被保护的公式
            for (let i = formulaIndex - 1; i >= 0; i--) {
                htmlContent = htmlContent.replace(`__FORMULA_INLINE_${i}__`, protectedFormulas[i]);
                htmlContent = htmlContent.replace(`__FORMULA_BLOCK_${i}__`, protectedFormulas[i]);
            }
            
            // 恢复被保护的其他内容
            for (let i = placeholderIndex - 1; i >= 0; i--) {
                htmlContent = htmlContent.replace(`__CODE_BLOCK_${i}__`, placeholders[i]);
                htmlContent = htmlContent.replace(`__CODE_INLINE_${i}__`, placeholders[i]);
                htmlContent = htmlContent.replace(`__MATH_SPAN_${i}__`, placeholders[i]);
                htmlContent = htmlContent.replace(`__MATH_DIV_${i}__`, placeholders[i]);
            }
            
            return htmlContent;
        }

        // Fallback: 简单的数学公式文本替换
        function fallbackMathRendering(element) {
            if (!element) return;
            
            // 先保护单独的$符号
            let content = protectLoneDollarSigns(element.innerHTML);
            
            // 简单的LaTeX到文本的转换
            const mathReplacements = {
                // 希腊字母
                '\\\\alpha': 'α', '\\\\beta': 'β', '\\\\gamma': 'γ', '\\\\delta': 'δ',
                '\\\\epsilon': 'ε', '\\\\theta': 'θ', '\\\\lambda': 'λ', '\\\\mu': 'μ',
                '\\\\pi': 'π', '\\\\sigma': 'σ', '\\\\phi': 'φ', '\\\\omega': 'ω',
                
                // 数学符号
                '\\\\sum': '∑', '\\\\prod': '∏', '\\\\int': '∫',
                '\\\\infty': '∞', '\\\\pm': '±', '\\\\mp': '∓',
                '\\\\leq': '≤', '\\\\geq': '≥', '\\\\neq': '≠',
                '\\\\approx': '≈', '\\\\equiv': '≡',
                
                // 上下标简化处理
                '\\\\^\\{([^}]+)\\}': '^($1)',
                '_\\{([^}]+)\\}': '_($1)',
                
                // 分数简化
                '\\\\frac\\{([^}]+)\\}\\{([^}]+)\\}': '($1)/($2)',
                
                // 平方根
                '\\\\sqrt\\{([^}]+)\\}': '√($1)',
                
                // 移除多余的反斜杠和花括号
                '\\\\\\\\': '\\\\',
                '\\{': '',
                '\\}': ''
            };
            
            // 处理行内数学公式 $...$
            content = content.replace(/\$([^$]+)\$/g, function(match, formula) {
                let processed = formula;
                for (let pattern in mathReplacements) {
                    processed = processed.replace(new RegExp(pattern, 'g'), mathReplacements[pattern]);
                }
                return '<span style="font-style: italic; color: #0066cc; background: #f0f8ff; padding: 1px 3px; border-radius: 2px;" title="">' + processed + '</span>';
            });
            
            // 处理块级数学公式 $$...$$
            content = content.replace(/\$\$([^$]+)\$\$/g, function(match, formula) {
                let processed = formula;
                for (let pattern in mathReplacements) {
                    processed = processed.replace(new RegExp(pattern, 'g'), mathReplacements[pattern]);
                }
                return '<div style="text-align: center; font-style: italic; color: #0066cc; background: #f0f8ff; padding: 8px; margin: 10px 0; border-radius: 4px; border-left: 3px solid #0066cc;" title="">' + processed + '</div>';
            });
            
            element.innerHTML = content;
        }

        // 智能数学渲染函数
        function renderMath(element) {
            if (!element) return Promise.resolve();
            
            // 在MathJax处理前，先保护单独的$符号
            element.innerHTML = protectLoneDollarSigns(element.innerHTML);
            
            if (window.mathJaxAvailable && typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                // 使用MathJax渲染
                return MathJax.typesetPromise([element]).catch(function (err) {
                    fallbackMathRendering(element);
                });
            } else {
                // 使用fallback渲染
                fallbackMathRendering(element);
                return Promise.resolve();
            }
        }

        // 检测MathJax加载状态
        function checkMathJaxStatus() {
            setTimeout(function() {
                if (!window.mathJaxAvailable && window.mathJaxLoadAttempted) {
                    // 静默处理，不显示用户提示
                }
            }, 3000); // 3秒后检查
        }
    </script>
    
    <!-- 尝试加载MathJax CDN -->
    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mtml-chtml.js" 
            onload="window.mathJaxLoadAttempted = true; checkMathJaxStatus();"
            onerror="window.mathJaxLoadAttempted = true; checkMathJaxStatus();"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
            overflow: hidden;
            background: var(--bg-primary);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            height: 100vh;
            overflow: hidden;
            color: var(--text-primary);
            /* zoom: 0.9; */ /* 暂时禁用zoom，使用transform替代 */
            display: flex;
            flex-direction: column;
            margin: 0;
            padding: 0;
        }

        /* User authentication area styles */
        .user-auth-area {
            background: var(--bg-user-auth);
            border-bottom: 1px solid var(--border-primary);
            padding: 10px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 20px;
            min-height: 50px;
            flex-shrink: 0;
        }

        .user-auth-left {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 0 0 auto;
            min-width: auto;
        }

        .logo-group {
            display: flex;
            align-items: center;
        }

        .user-auth-right {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 0 0 auto;
            margin-left: auto;
        }

        .api-key-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .api-key-group label {
            color: var(--text-label);
            font-size: 0.9em;
            white-space: nowrap;
        }

        .api-key-input {
            padding: 6px 12px;
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            background: var(--bg-input);
            color: var(--text-primary);
            font-size: 0.9em;
            width: 160px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }

        .api-key-input:focus {
            outline: none;
            border-color: var(--border-focus);
            box-shadow: 0 0 0 2px var(--shadow-focus);
        }

        .api-key-input::placeholder {
            color: var(--text-placeholder);
        }

        /* 覆盖浏览器自动填充的浅色背景 */
        .api-key-input:-webkit-autofill,
        .api-key-input:-webkit-autofill:hover,
        .api-key-input:-webkit-autofill:focus,
        .api-key-input:-webkit-autofill:active {
            -webkit-box-shadow: 0 0 0px 1000px var(--bg-input) inset !important;
            -webkit-text-fill-color: var(--text-primary) !important;
            box-shadow: 0 0 0px 1000px var(--bg-input) inset !important;
            transition: background-color 5000s ease-in-out 0s;
        }

        .connect-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .connect-btn.connect {
            background: #28a745;
            color: white;
        }

        .connect-btn.connect:hover {
            background: #218838;
        }

        .connect-btn.disconnect {
            background: #6c757d;
            color: white;
        }

        .connect-btn.disconnect:hover {
            background: #5a6268;
        }

        .connect-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .lang-toggle-btn {
            padding: 6px 12px;
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            background: var(--bg-input);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 50px;
            height: 36px;
            font-weight: 500;
        }

        .lang-toggle-btn:hover {
            background: var(--bg-secondary);
            border-color: var(--border-focus);
            color: var(--color-accent);
        }

        .lang-toggle-btn:focus {
            outline: none;
            border-color: var(--border-focus);
            box-shadow: 0 0 0 2px var(--shadow-focus);
        }

        .theme-toggle-btn {
            padding: 6px 12px;
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            background: var(--bg-input);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
        }

        .theme-toggle-btn:hover {
            background: var(--bg-secondary);
            border-color: var(--border-focus);
            color: var(--color-accent);
        }

        .theme-toggle-btn:focus {
            outline: none;
            border-color: var(--border-focus);
            box-shadow: 0 0 0 2px var(--shadow-focus);
        }

        .logo-title {
            font-size: 1.2em;
            font-weight: 700;
            color: var(--text-header-title);
        }

        .api-key-toggle-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 21px;
            padding: 5px;
            transition: all 0.3s ease;
        }

        .api-key-toggle-btn:hover {
            color: var(--color-accent);
        }

        .register-link {
            padding: 6px 12px;
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            background: var(--bg-input);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            min-width: 50px;
            height: 36px;
            font-weight: 500;
        }

        .register-link:hover {
            background: var(--bg-secondary);
            border-color: var(--border-focus);
            color: var(--color-accent);
        }

        .register-link:focus {
            outline: none;
            border-color: var(--border-focus);
            box-shadow: 0 0 0 2px var(--shadow-focus);
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85em;
            color: var(--text-secondary);
        }

        .action-buttons-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .user-status {
            display: flex;
            align-items: center;
            gap: 6px;
        }


        .container {
            display: flex;
            flex: 1;
            min-height: 0;
            background: var(--bg-main);
            overflow: hidden;
            position: relative;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 15px;
            padding-bottom: 10px;
            min-width: 400px;
            min-height: 0;
            overflow: hidden;
        }

        #resizer {
            width: 5px;
            background: var(--border-resizer);
            cursor: col-resize;
            flex-shrink: 0;
            transition: all 0.2s ease;
            position: relative;
        }

        #resizer:hover {
            background: var(--border-resizer-hover);
            width: 6px;
        }

        #resizer:active {
            background: var(--border-resizer-active);
            width: 6px;
        }

        /* Add visual indicator when dragging */
        #resizer::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 30px;
            background: var(--resizer-indicator);
            border-radius: 1px;
            pointer-events: none;
            transition: all 0.2s ease;
        }

        #resizer:hover::before {
            background: var(--resizer-indicator-hover);
            height: 40px;
        }

        #resizer.hidden {
            width: 4px;
            background: var(--bg-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            transition: all 0.2s ease;
        }

        #resizer.hidden:hover {
            background: var(--border-primary);
            color: var(--color-accent);
        }

        #resizer.hidden::before {
            content: '';
            display: none;
        }

        .sidebar {
            width: 400px;
            background: var(--bg-sidebar);
            border-left: 1px solid var(--border-primary);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex-shrink: 0;
            min-height: 0;
        }

        .header {
            text-align: center;
            margin-bottom: 15px;
            color: var(--text-header);
        }

        .header h1 {
            font-size: 1.2em;
            font-weight: 700;
            margin-bottom: 0;
            color: var(--text-header-title);
        }

        .header p {
            display: none;
        }

        .chat-wrapper {
            flex: 1;
            min-height: 0;
            display: flex;
            gap: 0;
            margin-bottom: 20px;
            position: relative;
        }

        .floating-restore-tag {
            position: absolute;
            display: none;
            align-items: center;
            gap: 6px;
            padding: 5px 12px;
            background: var(--bg-container);
            color: var(--text-primary);
            font-size: 0.8em;
            border-radius: 999px;
            border: 1px solid var(--border-primary);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
            cursor: grab;
            z-index: 5;
            opacity: 0.9;
            transition: box-shadow 0.2s ease, opacity 0.2s ease;
        }

        [data-theme="light"] .floating-restore-tag {
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.08);
        }

        .floating-restore-tag:hover {
            opacity: 1;
            box-shadow: 0 8px 18px rgba(0, 0, 0, 0.18);
        }

        .floating-restore-tag.dragging {
            cursor: grabbing;
            opacity: 1;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.22);
        }

        .floating-restore-tag.visible {
            display: inline-flex;
        }

        #detailInfoRestoreTag {
            right: 16px;
            top: 10px;
            transform: none;
        }

        #sidebarRestoreTag {
            right: 16px;
            top: 10px;
            transform: none;
        }

        .chat-container {
            flex: 1;
            min-height: 0;
            background: var(--bg-container);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .chat-header {
            padding: 10px 15px;
            background: var(--bg-chat-header);
            border-bottom: 1px solid var(--border-primary);
            color: var(--text-primary);
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            flex-shrink: 0;
        }

        .chat-header i {
            color: var(--color-accent);
        }

        .chat-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chat-header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .load-history-btn,
        .agent-view-btn,
        .terminal-btn,
        .clear-chat-btn {
            width: 28px;
            height: 28px;
            min-width: 28px;
            padding: 0;
            background: var(--color-accent);
            color: white;
            border: 1px solid var(--color-accent);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s, opacity 0.3s;
        }
        
        .agent-select-wrapper {
            display: flex;
            align-items: center;
        }
        
        .agent-select-dropdown {
            min-width: 84px; /* 缩小30%: 120px * 0.7 = 84px */
            padding: 4px 8px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 2px solid #007bff; /* 蓝色外框 */
            border-radius: 4px;
            font-size: 0.85em;
            cursor: pointer;
            outline: none;
            transition: border-color 0.3s;
        }
        
        .agent-select-dropdown:hover {
            border-color: #0056b3; /* 深蓝色悬停效果 */
        }
        
        .agent-select-dropdown:focus {
            border-color: #0056b3; /* 深蓝色焦点效果 */
        }

        .load-history-btn:hover,
        .agent-view-btn:hover,
        .terminal-btn:hover,
        .clear-chat-btn:hover:not(:disabled) {
            opacity: 0.9;
            background: var(--color-accent);
        }

        .load-history-btn i,
        .agent-view-btn i,
        .terminal-btn i,
        .clear-chat-btn i {
            color: white;
        }
        
        .agent-view-btn {
            margin-right: 0;
        }

        .vertical-resizer {
            width: 5px;
            background: var(--border-resizer);
            cursor: col-resize;
            flex-shrink: 0;
            transition: all 0.2s ease;
            position: relative;
        }

        .vertical-resizer:hover {
            background: var(--border-resizer-hover);
            width: 6px;
        }

        .vertical-resizer:active {
            background: var(--border-resizer-active);
            width: 6px;
        }

        .vertical-resizer::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 30px;
            background: var(--resizer-indicator);
            border-radius: 1px;
            pointer-events: none;
            transition: all 0.2s ease;
        }

        .vertical-resizer:hover::before {
            background: var(--resizer-indicator-hover);
            height: 40px;
        }

        .detail-info-container {
            width: min(400px, 30vw);
            max-width: 800px;
            min-width: 200px;
            min-height: 0;
            background: var(--bg-container);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex-shrink: 0;
            transition: width 0.2s ease;
        }

        .detail-info-container.hidden {
            width: 0;
            min-width: 0;
            overflow: hidden;
            border: none;
            padding: 0;
            margin: 0;
            opacity: 0;
            pointer-events: none;
        }

        .vertical-resizer.hidden {
            width: 4px;
            background: var(--bg-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            transition: all 0.2s ease;
        }

        .vertical-resizer.hidden:hover {
            background: var(--border-primary);
            color: var(--color-accent);
        }

        .vertical-resizer.hidden::before {
            content: '';
            display: none;
        }

        .vertical-resizer.hidden::after {
            display: none;
        }

        .sidebar.hidden {
            width: 0;
            min-width: 0;
            overflow: hidden;
            border: none;
            padding: 0;
            margin: 0;
            opacity: 0;
            pointer-events: none;
        }

        .detail-info-header {
            padding: 10px 15px;
            background: var(--bg-chat-header);
            border-bottom: 1px solid var(--border-primary);
            color: var(--text-primary);
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
            justify-content: space-between;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 1em;
        }

        .detail-info-toggle-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.3s ease;
            font-size: 0.9em;
            margin-left: auto;
        }

        .detail-info-toggle-btn:hover {
            background: rgba(156, 220, 254, 0.1);
            color: var(--color-accent);
        }


        .detail-info-header i {
            color: var(--color-accent);
        }

        .detail-info-messages {
            flex: 1;
            min-height: 0;
            padding: 10px;
            overflow-y: auto;
            overflow-x: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 0.9em;
            color: var(--text-primary);
        }

        .detail-info-message {
            margin-bottom: 4px;
            white-space: pre-wrap;
            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: anywhere;
            color: var(--text-primary);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 1em;
            line-height: 1.4;
        }





        .chat-messages {
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            padding: 20px;
            background: var(--bg-chat);
            font-size: 0.9em;
        }

        .message {
            margin-bottom: 15px;
            padding: 12px 16px;
            border-radius: 6px;
            max-width: 95%;
            word-wrap: break-word;
            animation: fadeIn 0.3s ease-in;
            white-space: pre-wrap;
            overflow-wrap: break-word;
        }

        .message-text {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            white-space: pre-wrap;
            word-break: break-all;
            overflow-wrap: anywhere;
            line-height: 1.4;
            font-size: 1em;
        }
        
        .message-text a {
            color: var(--link-color, #4a9eff);
            text-decoration: underline;
            cursor: pointer;
            word-break: break-all;
        }
        
        .message-text a:hover {
            color: var(--link-color-hover, #6bb3ff);
            text-decoration: underline;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.user {
            background: var(--bg-message-user);
            color: var(--text-user);
            margin-left: auto;
            border-bottom-right-radius: 3px;
            font-size: 1em;
        }

        .message.system {
            background: var(--bg-message-system);
            color: var(--text-system);
            border-left: 3px solid var(--border-message-system);
            padding: 6px 8px !important;
            max-width: 95% !important;
            white-space: nowrap !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
            font-size: 1em;
        }

        .message.info {
            background: var(--bg-message-info);
            color: var(--text-info);
            border-left: 3px solid var(--border-message-info);
            font-size: 1em;
        }

        .message.error {
            background: var(--bg-message-error);
            color: var(--text-error);
            border-left: 3px solid var(--border-message-error);
            font-size: 1em;
        }

        .message.success {
            background: var(--bg-message-success);
            color: var(--text-success);
            border-left: 3px solid var(--border-message-success);
            font-size: 1em;
        }

        .message.normal {
            background: transparent;
            color: var(--text-primary);
            border: none;
            padding: 2px 0;
            font-size: 1em;
        }

        /* JSON折叠框样式 */
        .json-collapsible {
            background: var(--bg-json-collapsible);
            border: 2px solid var(--border-json-collapsible);
            border-radius: 6px;
            margin-bottom: 15px;
            max-width: 95%;
            overflow: hidden;
            animation: fadeIn 0.3s ease-in;
        }

        .json-collapsible-header {
            padding: 12px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: background-color 0.2s ease;
        }

        .json-collapsible-header:hover {
            background-color: rgba(25, 135, 84, 0.2);
        }

        .json-collapsible-title {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-json-title);
            font-weight: 500;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 1em;
        }

        .json-collapsible-title span {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 1em;
        }

        .json-collapsible-icon {
            transition: transform 0.3s ease;
            font-size: 12px;
        }

        .json-collapsible.collapsed .json-collapsible-icon {
            transform: rotate(-90deg);
        }

        .json-collapsible-content {
            padding: 12px 16px;
            border-top: 1px solid rgba(25, 135, 84, 0.3);
            color: var(--text-json-content);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 1em;
            white-space: pre-wrap;
            word-break: break-all;
            overflow-wrap: anywhere;
            line-height: 1.4;
            max-height: none;
            overflow: visible;
        }

        .json-collapsible.collapsed .json-collapsible-content {
            display: none;
        }

        .input-container {
            background: var(--bg-input-container);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 15px;
            flex-shrink: 0;
            min-width: 0; /* 允许缩小，防止超出容器 */
            max-width: 100%; /* 确保不超出容器 */
            box-sizing: border-box; /* 确保padding计算正确 */
        }

        .input-group {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            min-width: 0; /* 允许缩小 */
            max-width: 100%; /* 确保不超出容器 */
        }
        
        .input-wrapper {
            flex: 1;
            position: relative;
        }

        .mode-selection {
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 4px;
            margin-bottom: 0;
        }
        
        .button-row {
            display: flex;
            gap: 6px;
            flex-direction: row;
            align-items: center;
        }


        /* 配置页面中的执行轮次滑条样式 */
        .config-rounds-slider {
            width: 100%;
            height: 6px;
            background: var(--bg-secondary);
            outline: none;
            border-radius: 3px;
            appearance: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .config-rounds-slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--color-accent);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .config-rounds-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
        }

        .config-rounds-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--color-accent);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        .config-rounds-slider::-moz-range-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
        }

        .config-rounds-slider::-moz-range-track {
            height: 6px;
            background: var(--bg-secondary);
            border-radius: 3px;
            border: none;
        }


        #userInput {
            width: 100%;
            min-height: 60px;
            max-height: 120px;
            padding: 15px 20px;
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            font-size: 16px;
            resize: vertical;
            transition: all 0.3s ease;
            font-family: inherit;
            background: var(--bg-input);
            color: var(--text-primary);
            overflow-y: auto;
        }

        /* 自定义滚动条样式 */
        #userInput::-webkit-scrollbar {
            width: 6px;
        }

        #userInput::-webkit-scrollbar-track {
            background: transparent;
        }

        #userInput::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        #userInput::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* 只在内容超出时显示滚动条 */
        #userInput:not(:focus) {
            overflow-y: hidden;
        }

        #userInput:focus {
            outline: none;
            border-color: var(--border-focus);
            box-shadow: 0 0 0 2px var(--shadow-focus);
            overflow-y: auto;
        }

        #userInput::placeholder {
            color: var(--text-placeholder);
        }

        #userInput.drag-over {
            border-color: var(--color-accent);
            background: var(--bg-input-container);
            box-shadow: 0 0 0 2px var(--shadow-focus);
        }

        .file-item-container {
            position: relative; /* 为绝对定位的按钮提供定位上下文 */
        }

        .file-item-container.dragging {
            opacity: 0.5;
            cursor: default;
        }

        .file-item-container[draggable="true"] {
            cursor: default;
        }

        .file-item-container[draggable="true"]:hover {
            background: var(--bg-directory-item-hover);
        }

        .send-button {
            background: transparent;
            border: 1px solid var(--color-accent);
            color: var(--color-accent);
            border-radius: 4px;
            width: auto;
            min-width: 28px;
            height: 28px;
            padding: 4px 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9em;
            flex-shrink: 0; /* 防止按钮被压缩得太小 */
            box-sizing: border-box; /* 确保padding计算正确 */
        }

        .send-button:hover:not(:disabled) {
            background: var(--color-accent);
            color: white;
            transform: translateY(-1px);
        }

        .send-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        #sendButton {
            background: var(--bg-send-button);
            color: white;
            border: none;
            width: 42px;
            height: 28px;
            min-width: 42px;
        }

        #sendButton:hover:not(:disabled) {
            background: var(--bg-send-button-hover);
        }

        #stopButton {
            background-color: #f44336 !important;
            border: none !important;
            color: white !important;
        }

        #stopButton:hover:not(:disabled) {
            background-color: #d32f2f !important;
        }


        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-primary);
            background: var(--bg-secondary);
        }

        .sidebar-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 1.1em;
            font-weight: 500;
        }

        .sidebar-header .action-btn {
            background: transparent;
            border: 1px solid var(--color-accent);
            color: var(--color-accent);
            padding: 6px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9em;
        }

        .sidebar-header .action-btn:hover:not(:disabled) {
            background: var(--color-accent);
            color: white;
        }

        .sidebar-header .action-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .sidebar-header .action-btn .fa-spin {
            animation: fa-spin 1s infinite linear;
        }

        .directory-list {
            flex: 1;
            overflow-y: auto;
            padding: 0;
            margin: 0;
        }

        .directory-placeholder {
            padding: 24px 16px;
            text-align: center;
            color: #9ca3af;
            font-size: 0.95em;
        }

        .directory-item {
            background: var(--bg-directory-item);
            border-radius: 6px;
            margin-bottom: 12px;
            padding: 15px;
            border: 1px solid var(--border-directory-item);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .directory-item:hover {
            background: var(--bg-directory-item-hover);
            border-color: var(--border-directory-item-hover);
        }

        .directory-item.expanded {
            background: var(--bg-directory-item-expanded);
            border-color: var(--border-directory-item-expanded);
        }

        .directory-item.current {
            background: var(--bg-directory-item-hover);
            color: var(--text-primary);
            border-color: var(--border-primary);
            box-shadow: none;
        }

        .directory-item.current .directory-name,
        .directory-item.current .directory-info {
            color: var(--text-primary);
        }

        .directory-item.current .action-btn {
            color: var(--text-secondary);
        }

        .directory-item.current .action-btn:hover {
            background: rgba(156, 220, 254, 0.1);
        }

        .directory-item.selected {
            background: var(--bg-directory-item-selected);
            color: white;
            border-color: var(--border-directory-item-selected);
            box-shadow: 0 3px 10px var(--shadow-directory-selected);
        }

        .directory-item.selected .directory-name,
        .directory-item.selected .directory-info,
        .directory-item.selected .task-description {
            color: white !important;
        }
        
        .directory-item.selected .directory-name > div,
        .directory-item.selected .directory-name span,
        .directory-item.selected .directory-name i,
        .directory-item.selected .directory-info div,
        .directory-item.selected .directory-info i,
        .directory-item.selected .task-description {
            color: white !important;
        }

        .directory-item.selected .action-btn {
            color: white;
        }

        .directory-item.selected .action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .directory-item.last {
            border: 2px solid var(--border-directory-item-last);
            background: var(--bg-directory-item-last);
        }

        .directory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .directory-name {
            font-weight: 600;
            color: var(--text-directory-name);
            font-size: 0.9em;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin-right: 10px;
        }

        .directory-actions {
            display: flex;
            gap: 6px;
            flex-shrink: 0;
        }

        .action-btn {
            background: none;
            border: none;
            color: var(--color-action-btn);
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .action-btn:hover {
            background: rgba(156, 220, 254, 0.1);
            color: var(--color-action-btn-hover);
        }

        .rename-btn {
            color: #ffc107 !important;
        }

        .rename-btn:hover {
            background: rgba(255, 193, 7, 0.1) !important;
            color: #ffc107 !important;
        }

        .delete-btn {
            color: #ff6b6b !important;
        }

        .delete-btn:hover {
            background: rgba(255, 107, 107, 0.1) !important;
            color: #ff5252 !important;
        }

        .directory-info {
            font-size: 0.75em;
            color: var(--text-directory-info);
            margin-bottom: 10px;
        }

        .file-tree {
            display: none;
            margin-top: 8px; /* 从10px减少到8px */
            padding: 6px; /* 从10px减少到6px */
            border-top: 1px solid var(--border-file-tree);
            background: var(--bg-file-tree);
            border-radius: 4px;
            max-height: 400px; /* 增加高度以显示至少10个文件 */
            overflow-y: auto; /* 添加滚动条 */
        }

        .file-tree.show {
            display: block;
        }

        .sub-file-tree {
            display: none;
            margin-left: 20px;
        }

        .sub-file-tree.show {
            display: block;
        }

        .sub-folder-toggle {
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .sub-folder-toggle:hover {
            opacity: 1;
            background: rgba(156, 220, 254, 0.2) !important;
            border-radius: 3px;
        }

        .file-item.directory > div[onclick]:hover {
            background: rgba(156, 220, 254, 0.1);
            border-radius: 4px;
            padding: 2px 6px;
            margin: -2px -6px;
        }

        .file-item {
            padding: 2px 0; /* 从5px减少到2px */
            margin-left: 20px;
            font-size: 0.9em;
            color: var(--text-file-item);
            display: flex;
            align-items: center;
            gap: 6px; /* 从8px减少到6px */
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative; /* 为绝对定位的按钮提供定位上下文 */
            word-break: break-word; /* 允许长文件名换行 */
            overflow: hidden; /* 防止内容溢出 */
        }

        .file-item:hover {
            background: rgba(156, 220, 254, 0.2);
            border-radius: 4px;
            padding-left: 5px;
        }

        .file-item.directory {
            font-weight: 500;
            color: var(--text-file-item-directory);
        }

        .file-item.previewable {
            color: var(--text-file-item);
        }

        .file-item.previewable:hover {
            color: var(--text-file-item);
        }

        .file-item i {
            width: 16px;
            text-align: center;
        }

        .file-item.grayed {
            color: #888888 !important;
        }

        .file-item.grayed:hover {
            color: #aaaaaa !important;
        }

        .file-item.grayed.previewable {
            cursor: pointer;
        }

        .file-item.grayed.previewable:hover {
            color: #cccccc !important;
            background: rgba(156, 220, 254, 0.1);
            border-radius: 4px;
            padding-left: 5px;
        }

        /* 文件操作按钮组容器 */
        .file-item-buttons {
            position: absolute;
            right: 4px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            gap: 2px; /* 缩小按钮间距 */
            opacity: 0;
            transition: opacity 0.2s ease;
            background: var(--bg-file-tree); /* 使用文件树背景色遮挡文字 */
            padding: 2px 4px;
            border-radius: 3px;
            z-index: 10; /* 确保按钮在文字上方 */
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.2); /* 添加阴影使按钮更明显 */
        }

        .file-item-container:hover .file-item-buttons,
        .file-item.directory:hover .file-item-buttons {
            opacity: 1;
        }

        /* 当文件项悬停时，给按钮组添加更明显的背景 */
        .file-item-container:hover .file-item-buttons {
            background: var(--bg-directory-item-hover);
            box-shadow: 0 0 6px rgba(0, 0, 0, 0.3); /* hover时增强阴影 */
        }

        .file-item.directory:hover .file-item-buttons {
            background: var(--bg-directory-item-hover);
            box-shadow: 0 0 6px rgba(0, 0, 0, 0.3); /* hover时增强阴影 */
        }
        
        /* 确保文件内容在按钮下方时可以被遮挡 */
        .file-content {
            position: relative;
            z-index: 1;
        }

        /* 下载文件按钮样式 */
        .download-file-btn {
            background: transparent !important;
            border: none !important;
            color: #888;
            cursor: pointer;
            padding: 2px 4px; /* 缩小padding */
            border-radius: 3px;
            font-size: 12px;
            transition: all 0.2s ease;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .download-file-btn:hover {
            background: rgba(76, 175, 80, 0.1) !important;
            color: #4caf50;
        }

        .download-file-btn:active {
            transform: scale(0.95);
        }

        /* 删除文件按钮样式 */
        .delete-file-btn {
            background: transparent !important;
            border: none !important;
            color: #888;
            cursor: pointer;
            padding: 2px 4px; /* 缩小padding */
            border-radius: 3px;
            font-size: 12px;
            transition: all 0.2s ease;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .delete-file-btn:hover {
            background: rgba(255, 107, 107, 0.1) !important;
            color: #ff6b6b;
        }

        .delete-file-btn:active {
            transform: scale(0.95);
        }

        /* 运行文件按钮样式（包括Python、Shell、CMD等） */
        .run-python-btn,
        .run-file-btn {
            background: transparent !important;
            border: none !important;
            color: #888;
            cursor: pointer;
            padding: 2px 4px; /* 缩小padding */
            border-radius: 3px;
            font-size: 12px;
            transition: all 0.2s ease;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .run-python-btn:hover,
        .run-file-btn:hover {
            background: rgba(100, 181, 246, 0.1) !important;
            color: #64b5f6;
        }

        .run-python-btn:active,
        .run-file-btn:active {
            transform: scale(0.95);
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #9cdcfe;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            border: 3px solid #3e3e42;
            border-top: 3px solid #007acc;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .scrollbar-custom {
            scrollbar-width: thin;
            scrollbar-color: #569cd6 var(--bg-secondary);
        }

        .scrollbar-custom::-webkit-scrollbar {
            width: 8px;
        }

        .scrollbar-custom::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        .scrollbar-custom::-webkit-scrollbar-thumb {
            background: #569cd6;
            border-radius: 4px;
        }

        .scrollbar-custom::-webkit-scrollbar-thumb:hover {
            background: #007acc;
        }

        /* Responsive design for mobile devices */
        @media (max-width: 768px) {
            html {
                overflow-y: auto; /* 允许页面滚动 */
                overflow-x: hidden;
                height: auto; /* 允许页面可以很长 */
                min-height: 100vh; /* 至少占满视口 */
                -webkit-overflow-scrolling: touch; /* iOS 平滑滚动 */
                scroll-behavior: smooth; /* 平滑滚动 */
            }
            
            body {
                overflow: visible; /* 允许页面滚动 */
                height: auto; /* 允许页面可以很长 */
                min-height: 100vh; /* 至少占满视口 */
                display: flex;
                flex-direction: column;
                -webkit-overflow-scrolling: touch; /* iOS 平滑滚动 */
                touch-action: pan-y; /* 优化触摸滚动 */
            }
            
            /* Header optimization */
            .user-auth-area {
                padding: 5px 8px;
                flex-direction: column;
                gap: 5px;
                min-height: auto;
                overflow-x: hidden;
            }
            
            .user-auth-left {
                width: 100%;
                min-width: unset;
                justify-content: center;
                margin-bottom: 5px;
            }
            
            .logo-group {
                flex-direction: column;
                align-items: center;
                gap: 2px;
            }
            
            .logo-group img {
                height: 1.8em !important;
            }
            
            .logo-group span {
                font-size: 1em !important;
            }
            
            .user-auth-right {
                width: 100%;
                flex-direction: column;
                align-items: center;
                gap: 6px;
                overflow-x: hidden;
            }
            
            .user-auth-right > div:last-child {
                margin-left: 0 !important;
                margin-top: 8px;
            }

            .action-buttons-group {
                display: flex;
                flex-direction: row;
                align-items: center;
                justify-content: center;
                gap: 8px;
                flex-wrap: nowrap;
                width: 100%;
            }

            .action-buttons-group > div {
                margin-left: 0 !important;
            }
            
            .api-key-group {
                flex-direction: column;
                align-items: center;
                gap: 3px;
                width: 100%;
                max-width: none;
                overflow: hidden;
            }
            
            .api-key-group label {
                font-size: 0.8em;
                text-align: center;
                white-space: nowrap;
            }
            
            .api-key-input {
                width: calc(100vw - 20px) !important;
                max-width: calc(100vw - 20px) !important;
                font-size: 16px; /* Prevent zoom on iOS */
                padding: 6px 8px;
                box-sizing: border-box;
            }
            
            #modelSelect {
                width: calc(100vw - 20px) !important;
                max-width: calc(100vw - 20px) !important;
            }
            
            #routineSelect {
                max-width: 100px !important; /* 手机布局下缩短选择框宽度 */
                width: auto !important;
            }
            
            .connect-btn {
                width: calc(100vw - 20px);
                max-width: calc(100vw - 20px);
                padding: 8px 12px;
                font-size: 0.9em;
                justify-content: center;
                box-sizing: border-box;
            }
            
            .user-info {
                width: 100%;
                justify-content: center;
                flex-wrap: wrap;
                gap: 8px;
                font-size: 0.8em;
            }
            
            .user-status {
                justify-content: center;
            }
            
            /* Container layout */
            .container {
                flex-direction: column;
                flex: none; /* 不占据固定空间，随内容自然增长 */
                min-height: 0;
                overflow: visible; /* 移除滚动，让页面统一滚动 */
            }
            
            .sidebar {
                width: 100% !important;
                max-width: none !important;
                min-width: 0 !important;
                flex-shrink: 0;
                border-radius: 0;
                border-left: none;
                border-bottom: 1px solid #3e3e42;
                order: 2;
                overflow: visible; /* 移除滚动，让页面统一滚动 */
                max-height: none; /* 移除高度限制，让内容自然流动 */
            }
            
            .main-content {
                padding: 10px;
                padding-bottom: 10px; /* 增加底部padding，确保按钮可以通过滚动到达 */
                min-width: unset;
                order: 1;
                flex: none; /* 不占据固定空间，随内容自然增长 */
                min-height: 0;
                display: flex;
                flex-direction: column;
                overflow: visible; /* 移除滚动，让页面统一滚动 */
            }
            
            /* Hide resizer on mobile */
            #resizer {
                display: none;
            }
            
            /* Chat wrapper optimization */
            .chat-wrapper {
                flex-direction: column;
                gap: 15px; /* 增加间距，确保聊天窗口和工具调用窗口之间有足够空间 */
                margin-bottom: 10px;
                width: 100% !important;
                max-width: none !important;
                min-width: 0 !important;
            }

            /* Hide vertical resizer on mobile */
            .vertical-resizer {
                display: none !important;
            }

            /* Detail info container on mobile */
            .detail-info-container {
                width: 100% !important;
                max-width: none !important;
                min-width: 0 !important;
                order: 2;
            }

            .detail-info-container.hidden {
                display: none;
            }
            
            .detail-info-header {
                font-size: 0.85em !important;
                padding: 8px 12px !important;
            }
            
            .detail-info-header span {
                font-size: 1em !important;
            }
            
            .detail-info-messages {
                min-height: 250px;
                max-height: 400px;
                overflow-y: auto !important;
            }

            /* Chat container optimization */
            .chat-container {
                margin-bottom: 15px; /* 增加底部间距，防止被工具调用显示框遮挡 */
                flex: none; /* 不占据固定空间，随内容自然增长 */
                min-height: 0;
                display: flex;
                order: 1;
                flex-direction: column;
                max-height: none; /* 不限制最大高度，让内容自然流动 */
                width: 100% !important;
                max-width: none !important;
                min-width: 0 !important;
            }
            
            .chat-header {
                font-size: 0.85em !important;
                padding: 8px 12px !important;
            }
            
            .chat-header span {
                font-size: 1em !important;
            }
            
            
            .chat-messages {
                padding: 10px;
                padding-bottom: 20px; /* 增加底部padding，防止被工具调用显示框遮挡 */
                flex: none; /* 不占据固定空间，随内容自然增长 */
                min-height: 250px;
                max-height: 400px;
                overflow-y: auto !important; /* 启用内部滚动 */
            }
            
            .message {
                margin-bottom: 10px;
                padding: 8px 12px;
                font-size: 0.85em;
            }
            
            /* Input optimization */
            .input-container {
                padding: 10px;
                flex-shrink: 0;
                position: relative; /* 确保按钮区域可见 */
                /* 移除margin-top: auto，让按钮区域在内容流中自然显示 */
            }
            
            .input-group {
                flex-direction: column; /* 垂直布局，按钮放到下一行 */
                gap: 8px;
                align-items: stretch;
            }

            .mode-selection {
                width: 100%;
                justify-content: flex-end;
                flex-wrap: wrap; /* 允许换行以适应小屏幕 */
                gap: 4px; /* 减小间距以适应小屏幕 */
            }
            
            /* 确保"规则文件"label和选择框在同一行，不分开 */
            .mode-selection > label:nth-of-type(2) {
                flex-shrink: 0;
                margin-right: 0; /* 移除右边距，让label和select紧挨着 */
            }
            
            .mode-selection > select#routineSelect {
                flex-shrink: 0;
                max-width: 100px !important; /* 进一步缩短选择框宽度 */
                width: auto !important;
                margin-left: 0; /* 移除左边距 */
            }
            
            .button-row {
                flex-direction: row !important; /* 确保按钮行始终横排 */
                flex-wrap: nowrap; /* 按钮不换行，保持左右排列 */
                justify-content: flex-end; /* 右对齐按钮 */
            }
            
            .input-wrapper {
                width: 100%;
                min-width: 0;
            }
            
            #userInput {
                font-size: 16px; /* Prevent zoom on iOS */
                min-height: 60px;
                max-height: 120px;
                padding: 10px 12px;
                width: 100%;
                min-width: 280px; /* 设置最小宽度 */
                box-sizing: border-box;
            }
            
            .send-button {
                height: 28px;
                font-size: 0.9em;
                min-width: 28px;
            }
            
            /* Sidebar optimization */
            .sidebar-header {
                padding: 8px 12px;
                flex-shrink: 0;
            }
            
            .sidebar-header h3 {
                font-size: 0.9em !important;
            }
            
            .directory-list {
                flex: none; /* 不占据固定空间，随内容自然增长 */
                min-height: 200px; /* 保留最小高度，确保可见 */
                max-height: none; /* 移除高度限制，让内容自然流动 */
                overflow: visible; /* 移除滚动，让页面统一滚动 */
                padding: 8px;
            }
            
            .directory-item {
                margin-bottom: 8px;
                padding: 10px;
            }
            
            .directory-name {
                font-size: 0.85em;
            }
            
            .directory-info {
                font-size: 0.7em;
                margin-bottom: 8px;
            }
            
            .directory-actions {
                gap: 6px;
            }
            
            .action-btn {
                padding: 4px 6px;
                font-size: 0.8em;
            }
            
            .file-tree {
                max-height: none; /* 移除高度限制，让内容自然流动 */
                overflow: visible; /* 移除滚动，让页面统一滚动 */
            }
            
            .file-item {
                padding: 1px 0; /* 进一步减少手机端间距 */
                font-size: 0.8em;
            }
            
        }
        
        /* Smaller mobile devices */
        @media (max-width: 480px) {
            .user-auth-area {
                padding: 4px 6px;
            }
            
            .main-content {
                padding: 8px;
                padding-bottom: 10px; /* 增加底部padding，确保按钮可以通过滚动到达 */
                flex: none; /* 不占据固定空间，随内容自然增长 */
                min-height: 0;
                display: flex;
                flex-direction: column;
                overflow: visible; /* 移除滚动，让页面统一滚动 */
            }
            
            .sidebar {
                flex-shrink: 0;
                max-height: none; /* 移除高度限制，让内容自然流动 */
            }
            
            .chat-container {
                flex: none; /* 不占据固定空间，随内容自然增长 */
                min-height: 0;
                max-height: none; /* 不限制最大高度，让内容自然流动 */
            }
            
            .chat-messages {
                padding: 8px;
                padding-bottom: 20px; /* 增加底部padding，防止被工具调用显示框遮挡 */
                flex: none; /* 不占据固定空间，随内容自然增长 */
                min-height: 0;
                overflow: visible; /* 在手机端不内部滚动，让页面统一滚动 */
            }
            
            .message {
                padding: 6px 10px;
                font-size: 0.8em;
                margin-bottom: 8px;
            }
            
            .input-container {
                padding: 8px;
                position: relative; /* 确保按钮区域可见 */
                /* 移除margin-top: auto，让按钮区域在内容流中自然显示 */
            }
            
            #userInput {
                min-height: 50px;
                padding: 8px 10px;
                font-size: 16px;
                min-width: 250px; /* 小屏设备输入框最小宽度 */
            }
            
            .mode-selection {
                width: 100%;
                justify-content: flex-end;
                flex-wrap: wrap; /* 允许换行以适应小屏幕 */
                gap: 4px; /* 减小间距以适应小屏幕 */
                min-width: 0; /* 允许缩小，防止超出容器 */
                max-width: 100%; /* 确保不超出容器 */
            }
            
            /* 确保"规则文件"label和选择框在同一行，不分开 */
            .mode-selection > label:nth-of-type(2) {
                flex-shrink: 0;
                margin-right: 0; /* 移除右边距，让label和select紧挨着 */
            }
            
            .mode-selection > select#routineSelect {
                flex-shrink: 0;
                max-width: 100px !important; /* 进一步缩短选择框宽度 */
                width: auto !important;
                margin-left: 0; /* 移除左边距 */
            }
            
            /* 确保mode-selection中的按钮可以换行 */
            .mode-selection > button {
                flex-shrink: 0;
            }
            
            .button-row {
                flex-direction: row !important; /* 确保按钮行始终横排 */
                flex-wrap: wrap; /* 允许按钮换行，防止超出边界 */
                justify-content: flex-end; /* 右对齐按钮 */
                min-width: 0; /* 允许缩小 */
                max-width: 100%; /* 确保不超出容器 */
            }
            
            .button-row > button {
                flex-shrink: 0; /* 防止按钮被压缩 */
            }
            
            .send-button {
                height: 28px;
                font-size: 0.8em;
                min-width: 28px;
            }
            
            .directory-list {
                min-height: 150px; /* 保留最小高度，确保可见 */
                max-height: none; /* 移除高度限制，让内容自然流动 */
                overflow: visible; /* 移除滚动，让页面统一滚动 */
                padding: 6px;
            }
            
            .directory-item {
                padding: 8px;
                margin-bottom: 6px;
            }
            
            .directory-name {
                font-size: 0.8em;
            }
            
            .directory-info {
                font-size: 0.65em;
            }
            
            .sidebar-header {
                padding: 6px 10px;
            }
            
            .sidebar-header .action-btn {
                padding: 3px 5px;
                font-size: 0.75em;
            }
            
            .file-tree {
                max-height: none; /* 移除高度限制，让内容自然流动 */
                overflow: visible; /* 移除滚动，让页面统一滚动 */
            }
            
            .file-item {
                padding: 1px 0; /* 小屏设备也减少间距 */
                font-size: 0.75em;
            }
            
            
            /* Modal optimization for mobile */
            .modal-content {
                width: 95%;
                height: 95vh;
                margin: 2.5vh auto;
                border-radius: 6px;
            }
            
            .modal-header {
                padding: 10px 12px;
            }
            
            .modal-header h3 {
                font-size: 1em;
                margin-right: 8px;
            }
            
            .modal-header-buttons {
                gap: 5px;
            }
            
            .modal-button {
                width: 22px;
                height: 22px;
                font-size: 16px;
                padding: 3px;
            }
            
            .close {
                font-size: 22px;
                height: 22px;
            }
            
            .modal-body {
                padding: 15px;
            }
            
            /* Preview content iframe optimization */
            #previewContent iframe {
                height: calc(95vh - 100px);
            }
            
            /* Upload area optimization */
            .upload-area {
                padding: 20px 15px;
            }
            
            .upload-icon {
                font-size: 36px;
                margin-bottom: 15px;
            }
            
            .upload-text p {
                font-size: 14px;
                margin: 8px 0;
            }
            
            .upload-hint {
                font-size: 16px !important;
            }
            
            .upload-btn {
                padding: 10px 20px;
                font-size: 14px;
                margin-top: 15px;
            }
        }

        /* Touch-friendly improvements for mobile */
        @media (max-width: 768px) {
            /* Increase touch targets */
            .action-btn {
                min-width: 44px;
                min-height: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .file-item {
                min-height: 36px; /* 减少最小高度但保持可点击 */
                padding: 4px 0; /* 减少padding但保持触摸友好 */
            }
            
            .directory-item {
                cursor: pointer;
                -webkit-tap-highlight-color: rgba(0, 122, 204, 0.2);
            }
            
            /* Smooth scrolling */
            .chat-messages {
                -webkit-overflow-scrolling: touch;
                scroll-behavior: smooth;
            }
            
            .directory-list {
                -webkit-overflow-scrolling: touch;
                scroll-behavior: smooth;
            }
            
            /* Prevent text selection on interactive elements */
            .action-btn,
            .connect-btn,
            .send-button,
            .directory-item {
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }
            
            /* Improve button press feedback */
            .send-button:active,
            .connect-btn:active,
            .action-btn:active {
                transform: scale(0.95);
                transition: transform 0.1s;
            }
            
            /* Scroll to bottom button mobile optimization */
            .scroll-to-bottom-hint {
                bottom: 80px;
                right: 15px;
                width: 45px;
                height: 45px;
                z-index: 100;
            }
            
            /* New message indicator mobile optimization (已禁用) */
            /* .new-message-indicator {
                bottom: 135px;
                right: 15px;
                padding: 8px 12px;
                font-size: 0.85em;
            } */
        }

        /* Tablet optimization (768px to 1024px) */
        @media (min-width: 769px) and (max-width: 1024px) {
            .sidebar {
                width: 350px;
            }
            
            .main-content {
                padding: 18px;
            }
            
            /* 确保按钮区域可以正确折叠 */
            .mode-selection {
                flex-wrap: wrap; /* 允许换行 */
                min-width: 0; /* 允许缩小 */
                max-width: 100%; /* 确保不超出容器 */
            }
            
            .button-row {
                flex-wrap: wrap; /* 允许按钮换行 */
                min-width: 0; /* 允许缩小 */
                max-width: 100%; /* 确保不超出容器 */
            }
            
            .input-container {
                min-width: 0; /* 允许缩小 */
                max-width: 100%; /* 确保不超出容器 */
            }
            
            .input-group {
                min-width: 0; /* 允许缩小 */
                max-width: 100%; /* 确保不超出容器 */
            }
            
            .chat-messages {
                padding: 18px;
            }
            
            .input-container {
                padding: 18px;
            }
            
            #userInput {
                font-size: 16px;
            }
            
            .user-auth-area {
                padding: 10px 18px;
            }
            
            .api-key-input {
                font-size: 16px;
            }
        }
        
        /* Small desktop optimization (1025px to 1200px) - 确保按钮可以折叠 */
        @media (min-width: 1025px) and (max-width: 1200px) {
            .mode-selection {
                flex-wrap: wrap; /* 允许换行 */
                min-width: 0; /* 允许缩小 */
                max-width: 100%; /* 确保不超出容器 */
            }
            
            .button-row {
                flex-wrap: wrap; /* 允许按钮换行 */
                min-width: 0; /* 允许缩小 */
                max-width: 100%; /* 确保不超出容器 */
            }
            
            .input-container {
                min-width: 0; /* 允许缩小 */
                max-width: 100%; /* 确保不超出容器 */
            }
            
            .input-group {
                min-width: 0; /* 允许缩小 */
                max-width: 100%; /* 确保不超出容器 */
            }
        }

        /* Landscape phone optimization */
        @media (max-width: 768px) and (orientation: landscape) {
            .container {
                flex-direction: row;
                flex: 1;
                min-height: 0;
            }
            
            .sidebar {
                width: 40%;
                height: 100%;
                border-left: 1px solid #3e3e42;
                border-bottom: none;
                order: 2;
            }
            
            .main-content {
                width: 60%;
                height: 100%;
                order: 1;
            }
            
            #resizer {
                display: block;
            }
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        /* 预览窗口特殊样式 - 无背景遮罩，可拖动 */
        #previewModal {
            background-color: transparent;
            z-index: 2000;
            pointer-events: none; /* 允许点击穿透到下层 */
        }

        #previewModal .modal-content {
            position: absolute;
            z-index: 2001;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            margin: 0;
            pointer-events: auto; /* 窗口本身可以交互 */
        }
        
        #previewModal .modal-header {
            cursor: move;
            user-select: none;
        }

        /* Modal resizer styles */
        .modal-resizer {
            position: absolute;
            z-index: 10;
            transition: background-color 0.2s;
        }

        /* 左右调整器 */
        .modal-resizer-left,
        .modal-resizer-right {
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: ew-resize;
        }

        .modal-resizer-left {
            left: 0;
        }

        .modal-resizer-right {
            /* 调整位置，避免与滚动条重合，滚动条通常在右侧，宽度约15-17px */
            right: -4px; /* 稍微向外偏移，确保可以拖动，避免与滚动条重合 */
        }

        /* 上下调整器 */
        .modal-resizer-top,
        .modal-resizer-bottom {
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
        }

        .modal-resizer-top {
            top: 0;
        }

        .modal-resizer-bottom {
            bottom: 0;
        }

        .modal-resizer:hover {
            background-color: rgba(66, 133, 244, 0.3);
        }

        .modal-resizer:active {
            background-color: rgba(66, 133, 244, 0.5);
        }

        /* Hide resizers when maximized */
        #previewModal.maximized .modal-resizer {
            display: none;
        }

        /* SVG编辑器窗口特殊样式 - 显示在预览窗口上方 */
        #svgEditorModal {
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 2100;
        }

        #svgEditorModal .modal-content {
            position: relative;
            z-index: 2101;
        }

        /* SVG编辑器窗口最大化样式 */
        #svgEditorModal.maximized .modal-content {
            width: 100% !important;
            height: 100vh !important;
            margin: 0 !important;
            top: 0 !important;
            left: 0 !important;
            transform: none !important;
        }

        /* 配置窗口样式 - 类似预览窗口 */
        #configModal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
        }

        #configModal .modal-content {
            position: relative;
            z-index: 2001;
            max-width: 800px;
            height: auto;
            max-height: 90vh;
        }

        .modal-content {
            background-color: var(--bg-secondary);
            margin: 2% auto;
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            width: 90%;
            max-width: 1200px;
            height: 90vh;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            background: var(--color-accent);
            color: white;
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-primary);
            flex-shrink: 0;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 1.2em;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin-right: 10px;
        }

        .modal-header-buttons {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-shrink: 0;
        }

        .modal-button {
            color: white;
            font-size: 18px;
            cursor: pointer;
            line-height: 1;
            padding: 4px;
            border-radius: 4px;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
        }

        .modal-button:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .maximize-button i {
            font-size: 14px;
        }

        .maximize-button {
            position: relative;
            top: 2px;
        }

        .close {
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 24px;
        }

        .close:hover {
            opacity: 0.7;
        }

        /* 最大化状态的样式 */
        #previewModal.maximized .modal-content {
            width: 100% !important;
            height: 100% !important;
            max-width: 100% !important;
            max-height: 100% !important;
            margin: 0 !important;
            border-radius: 0 !important;
            top: 0 !important;
            left: 0 !important;
            transform: none !important;
        }

        #previewModal.maximized .modal-header {
            cursor: default;
        }

        #previewModal.maximized #previewContent iframe {
            height: calc(100vh - 70px) !important;
        }

        #previewModal.maximized .modal-body {
            height: calc(100vh - 70px);
        }

        .modal-body {
            padding: 20px;
            flex: 1;
            overflow-y: auto;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 0;
        }

        /* 预览模态框滚动条样式，增加宽度避免与调整器重合 */
        #previewModal .modal-body::-webkit-scrollbar {
            width: 12px;
        }

        #previewModal .modal-body::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 6px;
        }

        #previewModal .modal-body::-webkit-scrollbar-thumb {
            background: #569cd6;
            border-radius: 6px;
            border: 2px solid var(--bg-secondary);
        }

        #previewModal .modal-body::-webkit-scrollbar-thumb:hover {
            background: #007acc;
        }

        /* Special handling for preview modal */
        #previewModal .modal-content {
            width: 65%;
            max-width: none;
            height: 95%;
            max-height: none;
        }
        
        /* Mobile preview modal optimization */
        @media (max-width: 768px) {
            #previewModal .modal-content {
                width: 95% !important;
                min-width: 350px;
                max-width: 95% !important;
                height: 95vh !important;
            }
            
            /* 中等屏幕优化预览模态框中的按钮布局 */
            #previewModal .preview-button-group {
                justify-content: center !important;
                flex-wrap: wrap !important;
                gap: 8px !important;
            }
            
            #previewModal .preview-button-group a,
            #previewModal .preview-button-group button {
                flex: 1 1 calc(50% - 4px) !important;
                min-width: 120px !important;
                max-width: 200px !important;
                font-size: 16px !important;
                padding: 10px 8px !important;
            }
            
            /* 中等屏幕优化Markdown工具栏按钮布局 */
            #previewModal .markdown-toolbar-header {
                flex-direction: column !important;
                align-items: stretch !important;
                gap: 10px !important;
            }
            
            #previewModal .markdown-toolbar-buttons {
                flex-wrap: wrap !important;
                gap: 6px !important;
                justify-content: center !important;
            }
            
            #previewModal .markdown-toolbar-buttons button {
                min-width: 70px !important;
                max-width: calc(33.33% - 4px) !important;
                padding: 6px 8px !important;
                font-size: 14px !important;
                height: 32px !important;
                flex: 1 1 calc(33.33% - 4px) !important;
            }
        }
        
        /* Small mobile preview modal optimization */
        @media (max-width: 480px) {
            #previewModal .modal-content {
                width: 98% !important;
                min-width: 320px;
                max-width: 98% !important;
                height: 95vh !important;
            }
            
            #previewModal .modal-body {
                padding: 5px !important;
            }
            
            #previewContent iframe {
                height: calc(95vh - 80px) !important;
            }
            
            /* 优化预览模态框中的按钮布局 - 强制两行显示 */
            #previewModal .preview-button-group {
                flex-direction: column !important;
                align-items: stretch !important;
                gap: 8px !important;
            }
            
            #previewModal .preview-button-group a,
            #previewModal .preview-button-group button {
                width: 100% !important;
                min-width: unset !important;
                text-align: center !important;
                font-size: 16px !important;
                padding: 10px 12px !important;
            }
            
            /* 优化Markdown工具栏按钮布局 */
            #previewModal .markdown-toolbar-header {
                flex-direction: column !important;
                align-items: stretch !important;
                gap: 10px !important;
            }
            
            #previewModal .markdown-toolbar-buttons {
                flex-wrap: wrap !important;
                gap: 4px !important;
                justify-content: center !important;
            }
            
            #previewModal .markdown-toolbar-buttons button {
                min-width: unset !important;
                padding: 6px 8px !important;
                font-size: 14px !important;
                height: 32px !important;
                flex: 1 1 calc(50% - 2px) !important;
                max-width: calc(50% - 2px) !important;
            }
        }
        
        /* Tablet preview modal optimization */
        @media (min-width: 769px) and (max-width: 1024px) {
            #previewModal .modal-content {
                width: 80%;
                min-width: 600px;
            }
        }

        #previewModal .modal-body {
            padding: 10px;
        }

        /* iframe style optimization */
        #previewContent iframe {
            width: 100%;
            height: calc(95vh - 120px);
            border: none;
            border-radius: 4px;
        }

        /* Upload area styles */
        .upload-area {
            border: 2px dashed var(--border-upload-area);
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            background: var(--bg-upload-area);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: var(--border-upload-area-hover);
            background: var(--bg-upload-area-hover);
        }

        .upload-area.dragover {
            border-color: var(--border-upload-area-hover);
            background: var(--bg-upload-area-hover);
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 48px;
            color: var(--color-accent);
            margin-bottom: 20px;
        }

        .upload-text p {
            margin: 10px 0;
            font-size: 16px;
        }

        .upload-hint {
            font-size: 21px !important;
            color: var(--text-upload-hint) !important;
            opacity: 0.8;
        }

        .upload-btn {
            background: var(--bg-upload-btn);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 20px;
            transition: background 0.3s ease;
        }

        .upload-btn:hover {
            background: var(--bg-upload-btn-hover);
        }

        /* Progress bar styles */
        .upload-progress {
            margin-top: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-progress-bar);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--bg-progress-fill);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            margin-top: 10px;
            color: var(--text-progress);
        }

        /* Upload result styles */
        .upload-result {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            display: none;
        }

        .upload-result .success {
            color: #75b798;
            background: #0f5132;
            padding: 10px;
            border-radius: 4px;
            border-left: 3px solid #198754;
        }

        .upload-result .error {
            color: #f48771;
            background: #5a1d1d;
            padding: 10px;
            border-radius: 4px;
            border-left: 3px solid #f14c4c;
        }

        /* Scroll to bottom hint */
        .scroll-to-bottom-hint {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: #007acc;
            color: white;
            border: none;
            border-radius: 25px;
            width: 50px;
            height: 50px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            box-shadow: 0 4px 12px rgba(0, 122, 204, 0.4);
            transition: all 0.3s ease;
            z-index: 100;
            animation: bounceIn 0.3s ease;
        }

        .scroll-to-bottom-hint:hover {
            background: #005a9e;
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0, 122, 204, 0.6);
        }

        .scroll-to-bottom-hint.show {
            display: flex;
        }

        @keyframes bounceIn {
            0% {
                opacity: 0;
                transform: scale(0.3);
            }
            50% {
                opacity: 1;
                transform: scale(1.05);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* New message indicator (已禁用) */
        /* .new-message-indicator {
            position: absolute;
            bottom: 80px;
            right: 20px;
            background: #007acc;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 18px;
            display: none;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(0, 122, 204, 0.4);
            animation: slideInRight 0.3s ease;
            z-index: 99;
            cursor: pointer;
        }

        .new-message-indicator.show {
            display: flex;
        } */

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(100%);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }



        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-3px);
            }
            60% {
                transform: translateY(-2px);
            }
        }

        /* Markdown预览样式 */
        #markdownPreview {
            background: #ffffff !important;
            color: #000000 !important;
            font-size: 18px !important;
            line-height: 1.6 !important;
        }
        
        #markdownPreview img {
            width: 85% !important;
            height: auto !important;
            max-width: none !important;
            max-height: 1000px !important;
            object-fit: contain !important;
        }
        
        /* Markdown预览中SVG元素的高度限制 */
        #markdownPreview svg {
            max-height: 1000px !important;
            width: auto !important;
            height: auto !important;
        }
        
        /* plan.md中的mermaid图表不设置高度限制 */
        #markdownPreview.plan-md svg,
        #markdownPreview.plan-md .mermaid svg {
            max-height: none !important;
            width: auto !important;
            height: auto !important;
        }
        
        /* Mermaid SVG高度限制 */
        #mermaid-chart-container svg {
            max-height: 1000px !important;
            width: auto !important;
            height: auto !important;
        }
        
        #markdownPreview h1,
        #markdownPreview h2,
        #markdownPreview h3,
        #markdownPreview h4,
        #markdownPreview h5,
        #markdownPreview h6 {
            color: #000000 !important;
            margin: 24px 0 16px 0;
            font-weight: 600;
            line-height: 1.25;
        }

        #markdownPreview h1 {
            font-size: 2em;
            border-bottom: 1px solid #d0d7de;
            padding-bottom: 0.3em;
        }

        #markdownPreview h2 {
            font-size: 1.5em;
            border-bottom: 1px solid #d0d7de;
            padding-bottom: 0.3em;
        }

        #markdownPreview h3 {
            font-size: 1.25em;
        }

        #markdownPreview p {
            margin: 16px 0;
            line-height: 1.6;
            color: #000000 !important;
            font-size: inherit !important;
        }

        #markdownPreview a {
            color: #0066cc;
            text-decoration: none;
        }

        #markdownPreview a:hover {
            text-decoration: underline;
        }

        #markdownPreview ul,
        #markdownPreview ol {
            margin: 16px 0;
            padding-left: 32px;
        }

        #markdownPreview li {
            margin: 4px 0;
            color: #000000 !important;
            font-size: inherit !important;
        }

        #markdownPreview blockquote {
            margin: 16px 0;
            padding: 0 16px;
            border-left: 4px solid #666666;
            color: #333333;
            font-size: inherit !important;
        }

        #markdownPreview table {
            border-collapse: collapse;
            margin: 16px 0;
            width: 100%;
        }

        #markdownPreview th,
        #markdownPreview td {
            border: 1px solid #dddddd;
            padding: 8px 12px;
            text-align: left;
            color: #000000 !important;
            font-size: inherit !important;
        }

        #markdownPreview th {
            background-color: #e9ecef;
            font-weight: 600;
        }

        #markdownPreview tr:nth-child(even) {
            background-color: #f6f8fa;
        }

        #markdownPreview code {
            background-color: #2d2d2d;
            border-radius: 3px;
            padding: 2px 4px;
            font-size: 14px !important;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            color: #ffffff !important;
            font-weight: normal !important;
        }

        #markdownPreview hr {
            border: none;
            height: 1px;
            background-color: #dddddd;
            margin: 24px 0;
        }

        /* MathJax样式 */
        .MathJax {
            color: #000000 !important;
        }

        .MathJax_Display {
            margin: 16px 0 !important;
        }

        /* 代码块样式增强 */
        #markdownPreview pre {
            background-color: #1e1e1e !important;
            border: 1px solid #404040;
            border-radius: 6px;
            padding: 16px;
            overflow-x: auto;
            margin: 8px 0;
            font-size: inherit !important;
        }

        #markdownPreview pre code {
            background: transparent;
            padding: 0;
            border-radius: 0;
            color: #ffffff !important;
            font-size: 14px !important;
            font-weight: normal !important;
        }

        /* 覆盖Prism.js语法高亮颜色，适配深色主题 */
        #markdownPreview .token.comment,
        #markdownPreview .token.prolog,
        #markdownPreview .token.doctype,
        #markdownPreview .token.cdata {
            color: #6a9955 !important;
        }

        #markdownPreview .token.punctuation {
            color: #d4d4d4 !important;
        }

        #markdownPreview .token.property,
        #markdownPreview .token.tag,
        #markdownPreview .token.boolean,
        #markdownPreview .token.number,
        #markdownPreview .token.constant,
        #markdownPreview .token.symbol {
            color: #569cd6 !important;
        }

        #markdownPreview .token.selector,
        #markdownPreview .token.attr-name,
        #markdownPreview .token.string,
        #markdownPreview .token.char,
        #markdownPreview .token.builtin {
            color: #ce9178 !important;
        }

        #markdownPreview .token.operator,
        #markdownPreview .token.entity,
        #markdownPreview .token.url,
        #markdownPreview .language-css .token.string,
        #markdownPreview .style .token.string {
            color: #d4d4d4 !important;
        }

        #markdownPreview .token.atrule,
        #markdownPreview .token.attr-value,
        #markdownPreview .token.keyword {
            color: #c586c0 !important;
        }

        #markdownPreview .token.function,
        #markdownPreview .token.class-name {
            color: #dcdcaa !important;
        }

        #markdownPreview .token.regex,
        #markdownPreview .token.important,
        #markdownPreview .token.variable {
            color: #9cdcfe !important;
        }

        /* Configuration options responsive layout */
        .config-options .config-option {
            flex: 1;
            min-width: 140px;
        }

        /* Mobile responsive configuration options */
        @media (max-width: 768px) {
            .config-options .config-option {
                flex-basis: 100%;
                margin-bottom: 8px;
            }

            .config-options {
                flex-direction: column;
                gap: 6px;
            }
        }

        /* Tablet configuration options */
        @media (min-width: 769px) and (max-width: 1024px) {
            .config-options .config-option {
                flex-basis: calc(33.333% - 5px);
                min-width: 120px;
            }
        }

        /* MCP server options styling */
        .mcp-option {
            transition: all 0.2s ease;
        }

        .mcp-option:hover {
            background: #3e3e42 !important;
            border-color: #569cd6 !important;
        }

        .mcp-option input[type="checkbox"]:checked + span {
            color: #569cd6;
            font-weight: 500;
        }

        /* 任务描述双击复制相关样式 */
        .task-description {
            cursor: pointer;
            user-select: text;
            position: relative;
        }

        .task-description:hover {
            opacity: 0.8;
        }

        /* 已拷贝提示样式 */
        .copy-toast {
            position: fixed;
            /* top和left将通过JavaScript动态设置 */
            transform: translate(-50%, -120%);
            background: rgba(0, 122, 204, 0.95);
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            animation: fadeInOutAtMouse 1.5s ease-in-out;
            pointer-events: none;
            white-space: nowrap;
        }

        @keyframes fadeInOutAtMouse {
            0% {
                opacity: 0;
                transform: translate(-50%, -120%) translateY(10px) scale(0.8);
            }
            20% {
                opacity: 1;
                transform: translate(-50%, -120%) translateY(0) scale(1);
            }
            80% {
                opacity: 1;
                transform: translate(-50%, -120%) translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -120%) translateY(-10px) scale(0.8);
            }
        }

        [data-theme="light"] .copy-toast {
            background: rgba(3, 102, 214, 0.95);
        }
    </style>
</head>
<body>
    <!-- User Authentication Area -->
    <div class="user-auth-area">
        <div class="user-auth-left">
            <div class="logo-group">
                <img src="{% if is_app_mode and app_logo_url %}{{ app_logo_url }}{% else %}{{ url_for('static', filename='logo.png') }}{% endif %}" style="height: 2.2em; margin-right: 10px;" alt="Logo">
                <span class="logo-title">{% if is_app_mode %}{{ app_name }}{% else %}{{ i18n.app_title.replace(' GUI', '') }}{% endif %}</span>
            </div>
        </div>
        <div class="user-auth-right">
            {% if not is_hidden %}
            <div class="api-key-group">
                <label for="appSelect">
                    <i class="fas fa-th"></i>
                    {{ '平台' if lang == 'zh' else 'Platform' }}
                </label>
                <select id="appSelect" class="api-key-input" title="{{ '选择平台' if lang == 'zh' else 'Select Platform' }}" style="width: 180px;">
                    <option value="">{{ '加载中...' if lang == 'zh' else 'Loading...' }}</option>
                </select>
            </div>
            {% endif %}
            <div class="api-key-group">
                <label for="modelSelect">
                    <i class="fas fa-brain"></i>
                    {{ i18n.model_label }}
                </label>
                <select id="modelSelect" class="api-key-input" title="{{ i18n.model_tooltip }}" style="width: 210px;">
                    <option value="" disabled selected>{{ '加载中...' if lang == 'zh' else 'Loading...' }}</option>
                </select>
            </div>
            <div class="api-key-group">
                <label for="apiKeyInput">
                    <i class="fas fa-key"></i>
                    {{ i18n.api_key_label }}
                </label>
                <div style="position: relative;">
                    <input type="password" id="apiKeyInput" class="api-key-input" 
                           placeholder="{{ i18n.api_key_placeholder }}" 
                           title="{{ i18n.api_key_tooltip }}" 
                           style="padding-right: 40px;">
                    <button type="button" id="apiKeyToggle" onclick="togglePasswordVisibility('apiKeyInput')" 
                            class="api-key-toggle-btn"
                            style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%);" 
                            title="{{ '显示密码' if lang == 'zh' else 'Show password' }}">
                        <i class="fas fa-eye"></i>
                    </button>
                </div>
            </div>
            <button id="connectBtn" class="send-button" title="{{ i18n.connect_btn }}" style="width: 28px; height: 28px; min-width: 28px; padding: 0; background: transparent; border: 1px solid var(--color-accent); color: var(--color-accent);">
                <i class="fas fa-plug"></i>
            </button>
            <div class="user-info">
                <span id="userStatusText">{{ i18n.user_disconnected }}</span>
                <span id="userIdentity" style="margin-left: 10px;"></span>
            </div>
            <div class="action-buttons-group">
                <a id="registerLink" class="register-link" title="{{ '注册账号' if lang == 'zh' else 'Register' }}">
                    <i class="fas fa-user-plus"></i>
                    <span>{{ '注册' if lang == 'zh' else 'Register' }}</span>
                </a>
                <button id="langToggleBtn" class="lang-toggle-btn" title="{{ '切换语言' if lang == 'zh' else 'Switch Language' }}">
                    <span id="langToggleText">{{ 'EN' if lang == 'zh' else '中文' }}</span>
                </button>
                <button id="themeToggleBtn" class="theme-toggle-btn" title="{{ '切换主题' if lang == 'zh' else 'Toggle Theme' }}">
                    <i class="fas fa-sun"></i>
                </button>
                <button id="configToggleBtn" class="theme-toggle-btn" title="{{ i18n.get('show_config_options', '显示配置选项' if lang == 'zh' else 'Show Configuration') }}">
                    <i class="fas fa-cog" id="configToggleIcon"></i>
                </button>
                <button id="contactUsBtn" class="theme-toggle-btn" title="{{ '联系我们' if lang == 'zh' else 'Contact Us' }}">
                    <i class="fas fa-envelope"></i>
                </button>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="main-content">
            <div class="header" style="display: none;">
                <h1><img src="{% if is_app_mode and app_logo_url %}{{ app_logo_url }}{% else %}{{ url_for('static', filename='logo.png') }}{% endif %}" style="height: 1.8em; vertical-align: middle;" alt="Logo"> {% if is_app_mode %}{{ app_name }}{% else %}{{ i18n.app_title.replace(' GUI', '') }}{% endif %}</h1>
                <p>{{ i18n.app_subtitle }}</p>
            </div>

            <div class="chat-wrapper">
                <div class="chat-container">
                    <div class="chat-header">
                        <div class="chat-header-left">
                            <i class="fas fa-comments"></i>
                            <span>{{ i18n.get('chat_window', '聊天窗口' if lang == 'zh' else 'Chat Window') }}</span>
                        </div>
                        <div class="chat-header-right">
                            <div class="agent-select-wrapper" id="agentSelectWrapper" style="display: none;">
                                <select class="agent-select-dropdown" id="agentSelectDropdown">
                                    <option value="manager">manager</option>
                                </select>
                            </div>
                            <button class="load-history-btn" id="loadHistoryBtn" title="{{ i18n.get('load_history', '加载历史' if lang == 'zh' else 'Load History') }}">
                                <i class="fas fa-history"></i>
                            </button>
                            {% if gui_show_agent_view_button %}
                            <button class="agent-view-btn" id="agentViewBtn" title="{{ i18n.get('agent_view', '智能体视图' if lang == 'zh' else 'Agent View') }}">
                                <i class="fas fa-cube"></i>
                            </button>
                            {% endif %}
                            {% if gui_virtual_terminal %}
                            <button class="terminal-btn" id="terminalBtn" title="{{ i18n.get('terminal', '终端' if lang == 'zh' else 'Terminal') }}">
                                <i class="fas fa-terminal"></i>
                            </button>
                            {% endif %}
                            <button class="clear-chat-btn" id="clearChatButton" title="{{ i18n.clear_chat_tooltip }}">
                                <i class="fas fa-paint-brush"></i>
                            </button>
                        </div>
                    </div>
                    <div class="chat-messages scrollbar-custom" id="chatMessages">
                        <div class="message system">
                            <strong><i class="fas fa-info-circle"></i> {{ i18n.get('system_message', '系统消息' if lang == 'zh' else 'System Message') }}</strong><br>
                            {{ i18n.get('welcome_message', '欢迎使用 OfficeCowork！请在下方输入您的需求，系统将自动为您处理任务。' if lang == 'zh' else 'Welcome to OfficeCowork! Please enter your requirements below, and the system will automatically process tasks for you.') }}
                        </div>
                    </div>
                    
                    <!-- Scroll to bottom button -->
                    <button class="scroll-to-bottom-hint" id="scrollToBottomBtn" title="{{ i18n.get('scroll_to_bottom', '滚动到底部' if lang == 'zh' else 'Scroll to Bottom') }}">
                        <i class="fas fa-chevron-down"></i>
                    </button>
                    
                    <!-- New message indicator (已禁用) -->
                    <!-- <div class="new-message-indicator" id="newMessageIndicator">
                        <i class="fas fa-bell"></i>
                        <span id="newMessageCount">1</span> {{ i18n.get('new_messages', '条新消息' if lang == 'zh' else 'new messages') }}
                    </div> -->
                    

                </div>
                
                <!-- Vertical Resizer between chat and detail info -->
                <div class="vertical-resizer" id="verticalResizer"></div>
                
                <!-- Detail Info Window -->
                <div class="detail-info-container" id="detailInfoContainer">
                    <div class="detail-info-header">
                        <i class="fas fa-info-circle"></i>
                        <span>{{ i18n.get('tool_call_details', '工具调用细节' if lang == 'zh' else 'Tool Call Details') }}</span>
                        <button class="detail-info-toggle-btn" id="detailInfoToggleBtn" title="{{ i18n.get('hide_detail_info', '隐藏' if lang == 'zh' else 'Hide') }}">
                            <i class="fas fa-chevron-right"></i>
                        </button>
                    </div>
                    <div class="detail-info-messages scrollbar-custom" id="detailInfoMessages">
                        <!-- Detail messages will be added here -->
                    </div>
                </div>
                <div class="floating-restore-tag" id="detailInfoRestoreTag" role="button"
                     title="{{ i18n.get('show_tool_detail_panel', '显示工具调用' if lang == 'zh' else 'Show Tool Details') }}"
                     aria-label="{{ i18n.get('show_tool_detail_panel', '显示工具调用' if lang == 'zh' else 'Show Tool Details') }}">
                    <i class="fas fa-info-circle"></i>
                    <span>{{ i18n.get('tool_detail_short_label', '工具细节' if lang == 'zh' else 'Tool Log') }}</span>
                </div>
            </div>

            <div class="input-container">
                <div class="input-group">
                    <div class="input-wrapper">
                        <textarea 
                            id="userInput" 
                            placeholder="{{ i18n.input_placeholder }}"
                            rows="1"
                        ></textarea>
                        <div class="mode-selection">
                            <label style="display: flex; align-items: center; gap: 4px; color: var(--text-primary); font-size: 0.9em; white-space: nowrap;">
                                <span>{{ i18n.get('routine_file', '规则文件' if lang == 'zh' else 'Routine File') }}:</span>
                            </label>
                            <select id="routineSelect" style="padding: 4px 8px; border-radius: 4px; border: 1px solid var(--border-primary); background: var(--bg-primary); color: var(--text-primary); font-size: 0.9em; max-width: 180px;" title="{{ i18n.get('routine_file_tooltip', '选择指导文件' if lang == 'zh' else 'Select Routine File') }}">
                                <option value="">{{ i18n.get('no_routine', '请选择...' if lang == 'zh' else 'Please select...') }}</option>
                            </select>
                            <label style="display: flex; align-items: center; gap: 4px; color: var(--text-primary); font-size: 0.9em; white-space: nowrap;">
                                <span>{{ i18n.get('task_type', '技能' if lang == 'zh' else 'Skills') }}:</span>
                            </label>
                            <select id="executionModeSelect" style="padding: 4px 8px; border-radius: 4px; border: 1px solid var(--border-primary); background: var(--bg-primary); color: var(--text-primary); font-size: 0.9em; width: 110px;">
                                <option value="agent">{{ i18n.get('agent_mode', 'Agent模式' if lang == 'zh' else 'Agent Mode') }}</option>
                                <option value="plan">{{ i18n.get('plan_mode', 'Plan模式' if lang == 'zh' else 'Plan Mode') }}</option>
                            </select>
                            {% if gui_show_multi_agent_button %}
                            <button class="send-button" id="multiAgentButton" title="{{ i18n.get('enable_multi_agent', '启动多智能体' if lang == 'zh' else 'Multi-Agent') }}" style="width: 28px; height: 28px; min-width: 28px; padding: 0; background: transparent; border: 1px solid var(--color-accent); color: var(--color-accent);">
                                <i class="fas fa-users"></i>
                            </button>
                            {% endif %}
                            <button class="send-button" id="webSearchButton" title="{{ i18n.get('enable_web_search', '搜索网络' if lang == 'zh' else 'Web Search') }}" style="width: 28px; height: 28px; min-width: 28px; padding: 0; background: var(--color-accent); border: 1px solid var(--color-accent); color: white;">
                                <i class="fas fa-search"></i>
                            </button>
                            {% if gui_show_infinite_execute_button %}
                            <button class="send-button" id="infiniteExecuteButton" title="{{ i18n.get('infinite_execute_tooltip', '无限执行模式（loops=-1）' if lang == 'zh' else 'Infinite Execute Mode (loops=-1)') }}" style="width: 28px; height: 28px; min-width: 28px; padding: 0; background: transparent; border: 1px solid var(--color-accent); color: var(--color-accent);">
                                <i class="fas fa-infinity"></i>
                            </button>
                            {% endif %}
                            <button class="send-button" id="quickUploadButton" title="{{ i18n.get('quick_upload_tooltip', '上传文件到当前工作目录' if lang == 'zh' else 'Upload files to current workspace') }}" style="width: 28px; height: 28px; min-width: 28px; padding: 0;">
                                <i class="fas fa-upload"></i>
                            </button>
                            <button class="send-button" id="thinkingButton" title="{{ i18n.get('enable_thinking', '启用思考模式' if lang == 'zh' else 'Enable Thinking') }}" style="width: 28px; height: 28px; min-width: 28px; padding: 0; background: transparent; border: 1px solid var(--color-accent); color: var(--color-accent);">
                                <i class="fas fa-lightbulb"></i>
                            </button>
                            <input type="file" id="quickFileInput" multiple style="display: none;">
                            <input type="file" id="directoryFileInput" multiple style="display: none;">
                            <div class="button-row">
                                <button class="send-button" id="sendButton" title="{{ i18n.direct_tooltip }}">
                                    <i class="fas fa-arrow-up"></i>
                                </button>
                                <button class="send-button" id="stopButton" style="display: none;" title="{{ i18n.get('stop_task', '停止任务' if lang == 'zh' else 'Stop Task') }}">
                                    <i class="fas fa-stop"></i>
                                </button>
                                <button class="send-button" id="appendTaskButton" style="display: none;" title="{{ i18n.get('append_task', '追加任务' if lang == 'zh' else 'Append Task') }}">
                                    <i class="fas fa-plus-circle"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- User Input Modal for talk_to_user - 已删除，改为在聊天窗口中显示选择题 -->
                
            </div>
            
        </div>

        <div class="resizer" id="resizer"></div>

        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <i class="fas fa-folder-open" id="folderIconHint" style="cursor: pointer;" title="点击查看提示"></i>
                <h3>{{ i18n.get('workspace_title', '工作目录' if lang == 'zh' else 'Workspace') }}</h3>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <button class="action-btn" id="newTaskButton" title="{{ i18n.new_tooltip }}">
                        <i class="fas fa-plus"></i>
                    </button>
                    <button class="action-btn" onclick="manualRefresh()" title="{{ i18n.refresh_tooltip }}">
                        <i class="fas fa-sync-alt"></i>
                    </button>
                    <button class="detail-info-toggle-btn" id="sidebarToggleBtn" title="{{ i18n.get('hide_detail_info', '隐藏' if lang == 'zh' else 'Hide') }}">
                        <i class="fas fa-chevron-right"></i>
                    </button>
                </div>
            </div>
            
            <div class="loading" id="sidebarLoading">
                <div class="spinner"></div>
                <p>{{ i18n.loading }}</p>
            </div>
            
            <div class="directory-list scrollbar-custom" id="directoryList">
                <!-- Directory list will be dynamically generated through JavaScript -->
            </div>
        </div>
        <div class="floating-restore-tag" id="sidebarRestoreTag" role="button"
             title="{{ i18n.get('show_workspace_panel', '显示工作目录' if lang == 'zh' else 'Show Workspace') }}"
             aria-label="{{ i18n.get('show_workspace_panel', '显示工作目录' if lang == 'zh' else 'Show Workspace') }}">
            <i class="fas fa-folder-open"></i>
            <span>{{ i18n.get('workspace_title_short', '工作目录' if lang == 'zh' else 'Workspace') }}</span>
        </div>
    </div>

    <!-- File preview modal -->
    <div id="previewModal" class="modal">
        <div class="modal-content">
            <div class="modal-resizer modal-resizer-left"></div>
            <div class="modal-resizer modal-resizer-right"></div>
            <div class="modal-resizer modal-resizer-top"></div>
            <div class="modal-resizer modal-resizer-bottom"></div>
            <div class="modal-header">
                <h3 id="previewTitle">{{ i18n.get('file_preview', '文件预览' if lang == 'zh' else 'File Preview') }}</h3>
                <div class="modal-header-buttons">
                    <span class="modal-button maximize-button" id="previewMaximize" title="最大化">
                        <i class="fas fa-expand"></i>
                    </span>
                    <span class="close" id="previewClose">&times;</span>
                </div>
            </div>
            <div class="modal-body">
                <div id="previewContent"></div>
            </div>
        </div>
    </div>

    <!-- Configuration modal -->
    <div id="configModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="configModalTitle">{{ i18n.get('config_options', '配置选项' if lang == 'zh' else 'Configuration Options') }}</h3>
                <span class="close" id="configModalClose">&times;</span>
            </div>
            <div class="modal-body">
                <div id="configContainer" class="config-container" style="padding: 15px;">
                    <div class="config-options" style="display: flex; flex-direction: column; gap: 12px; font-size: 0.85em;">
                        <!-- 执行轮次配置 -->
                        <div class="config-option execution-rounds-config" style="display: flex; flex-direction: column; gap: 8px; color: var(--text-primary); width: 100%;">
                            <label for="configRoundsSlider" class="config-rounds-label" style="font-size: 0.9em; font-weight: 500;">
                                {{ i18n.get('execution_rounds', '执行轮次' if lang == 'zh' else 'Execution Rounds') }}:
                            </label>
                            <div class="config-slider-wrapper" style="display: flex; align-items: center; gap: 12px;">
                                <input type="range" id="configRoundsSlider" class="config-rounds-slider" min="1" max="200" value="100" 
                                       style="flex: 1; height: 6px; background: var(--bg-secondary); outline: none; border-radius: 3px; appearance: none; cursor: pointer;">
                                <span id="configRoundsValue" class="config-rounds-value" style="font-size: 0.9em; font-weight: 600; color: var(--text-primary); min-width: 35px; text-align: center; background: var(--bg-input); padding: 4px 8px; border-radius: 4px; border: 1px solid var(--border-primary);">100</span>
                            </div>
                            <div class="config-rounds-description" style="font-size: 0.75em; color: var(--text-secondary); margin-top: 2px;">
                                {{ i18n.get('execution_rounds_desc', '控制任务执行的轮次数量，范围1-200，典型值100' if lang == 'zh' else 'Controls the number of execution rounds for tasks, range 1-200, typical value 100') }}
                            </div>
                        </div>
                        <label class="config-option" style="display: flex; align-items: center; gap: 6px; color: var(--text-primary); cursor: pointer; width: 100%;">
                            <input type="checkbox" id="enableLongTermMemory" style="margin: 0;">
                            <span>{{ i18n.get('enable_long_term_memory', '启动长期记忆' if lang == 'zh' else 'Long-term Memory') }}</span>
                        </label>
                        <label class="config-option" style="display: flex; align-items: center; gap: 6px; color: var(--text-primary); cursor: pointer; width: 100%;">
                            <input type="checkbox" id="enableMCP" style="margin: 0;">
                            <span>{{ i18n.get('enable_mcp', '启动MCP' if lang == 'zh' else 'Enable MCP') }}</span>
                        </label>
                        <label class="config-option" style="display: flex; align-items: center; gap: 6px; color: var(--text-primary); cursor: pointer; width: 100%;">
                            <input type="checkbox" id="enableJieba" checked style="margin: 0;">
                            <span>{{ i18n.get('enable_jieba', '启用中文分词' if lang == 'zh' else 'Chinese Segmentation') }}</span>
                        </label>
                    </div>

                    <!-- MCP Server Selection (moved below all config options) -->
                    <div id="mcpServerSelection" style="display: none; margin-top: 12px; padding: 8px; background: var(--bg-secondary); border-radius: 6px; border: 1px solid var(--border-primary);">
                        <label style="color: var(--text-primary); font-size: 0.9em; margin-bottom: 6px; display: block; font-weight: 500;">
                            <i class="fas fa-server" style="margin-right: 6px;"></i>
                            {{ '选择MCP服务器' if lang == 'zh' else 'Select MCP Servers' }}:
                        </label>
                        <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                            {% for server_name, server_config in mcp_servers.items() %}
                            <label class="mcp-option" style="display: flex; align-items: center; gap: 4px; color: var(--text-primary); cursor: pointer; font-size: 0.8em; padding: 4px 6px; border-radius: 4px; background: var(--bg-secondary); border: 1px solid var(--border-primary);">
                                <input type="checkbox" class="mcp-server-checkbox" data-server="{{ server_name }}" style="margin: 0;">
                                <span>{{ server_name.replace('-', ' ').replace('_', ' ').title() }}</span>
                            </label>
                            {% endfor %}
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Folder Hint Modal -->
    <div id="folderHintModal" class="modal">
        <div class="modal-content" style="max-width: 500px; height: auto; max-height: 80vh;">
            <div class="modal-header">
                <h3 id="folderHintTitle">{{ '提示' if lang == 'zh' else 'Hint' }}</h3>
                <span class="close" id="folderHintClose">&times;</span>
            </div>
            <div class="modal-body" style="padding: 20px;">
                <p style="margin: 0; color: var(--text-primary); line-height: 1.6; font-size: 14px;">
                    {{ '单击目标文件夹，呈现蓝色则代表为选中的文件夹，大模型将基于此文件夹读写文件' if lang == 'zh' else 'Click on the target folder. When it appears blue, it means the folder is selected. The large model will read and write files based on this folder.' }}
                </p>
            </div>
        </div>
    </div>

    <!-- SVG编辑器模态框 -->
    <div id="svgEditorModal" class="modal">
        <div class="modal-content" style="width: 95%; height: 95vh; margin: 2.5vh auto;">
            <div class="modal-header">
                <h3 id="svgEditorTitle">{{ 'SVG编辑器' if lang == 'zh' else 'SVG Editor' }}</h3>
                <div class="modal-header-buttons">
                    <span class="modal-button maximize-button" id="svgEditorMaximize" title="{{ '最大化' if lang == 'zh' else 'Maximize' }}">
                        <i class="fas fa-expand"></i>
                    </span>
                    <span class="close" id="svgEditorClose">&times;</span>
                </div>
            </div>
            <div class="modal-body" style="padding: 10px; height: calc(100% - 60px); overflow: hidden;">
                <div id="svgEditorContent" style="width: 100%; height: 100%; display: flex; flex-direction: column;">
                    <div id="svgEditorToolbar" style="padding: 10px; border-bottom: 1px solid #404040; background: #1e1e1e;">
                        <button id="svgSaveBtn" style="background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-right: 10px;">
                            <i class="fas fa-save"></i> {{ '保存' if lang == 'zh' else 'Save' }}
                        </button>
                        <button id="svgDeleteBtn" style="background: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-right: 10px;">
                            <i class="fas fa-trash"></i> {{ '删除元素' if lang == 'zh' else 'Delete Element' }}
                        </button>
                        <button id="svgResetBtn" style="background: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-right: 20px;">
                            <i class="fas fa-undo"></i> {{ '重置' if lang == 'zh' else 'Reset' }}
                        </button>
                        <div style="display: inline-block; margin-right: 20px; vertical-align: middle;">
                            <button id="svgZoomOutBtn" style="background: #17a2b8; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; margin-right: 5px;" title="{{ '缩小' if lang == 'zh' else 'Zoom Out' }}">
                                <i class="fas fa-search-minus"></i>
                            </button>
                            <span id="svgZoomLevel" style="color: #9cdcfe; font-size: 14px; margin: 0 10px; min-width: 60px; display: inline-block; text-align: center;">100%</span>
                            <button id="svgZoomInBtn" style="background: #17a2b8; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer;" title="{{ '放大' if lang == 'zh' else 'Zoom In' }}">
                                <i class="fas fa-search-plus"></i>
                            </button>
                        </div>
                        <div style="color: #9cdcfe; font-size: 14px; display: inline-block;">
                            <strong>{{ '使用说明:' if lang == 'zh' else 'Instructions:' }}</strong>
                            <span style="margin-left: 10px;">🖱️ {{ '按下拖拽元素→移动位置，放开后选中高亮' if lang == 'zh' else 'Press and drag elements→move position, release to select/highlight' }}</span>
                            <span style="margin-left: 15px;">📦 {{ '圈选空白区域→选中多个元素' if lang == 'zh' else 'Drag-select empty area→select multiple elements' }}</span>
                            <span style="margin-left: 15px;">⌨️ Ctrl+{{ '点击' if lang == 'zh' else 'click' }}→{{ '多选元素' if lang == 'zh' else 'multi-select elements' }}</span>
                            <span style="margin-left: 15px;">📝 {{ '双击文字' if lang == 'zh' else 'Double-click text' }}→{{ '编辑内容' if lang == 'zh' else 'edit content' }}</span>
                            <span style="margin-left: 15px;">🔄 {{ '拖动蓝色圆点' if lang == 'zh' else 'Drag blue dot' }}→{{ '缩放矩形框' if lang == 'zh' else 'resize rectangle' }}</span>
                        </div>
                    </div>
                    <div id="svgCanvas" style="flex: 1; background: white; position: relative; overflow: auto; display: flex; justify-content: center; align-items: flex-start; padding: 20px;">
                        <!-- SVG内容将在这里加载 -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden file inputs for different upload scenarios -->
    <input type="file" id="quickFileInput" multiple style="display: none;">
    <input type="file" id="directoryFileInput" multiple style="display: none;">

    <!-- File upload modal -->
    <div id="uploadModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="uploadTitle">{{ i18n.upload_title }}</h3>
                <span class="close" id="uploadClose">&times;</span>
            </div>
            <div class="modal-body">
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">
                        <i class="fas fa-cloud-upload-alt"></i>
                    </div>
                    <div class="upload-text">
                        <p>{{ i18n.get('drag_files', '拖拽文件到此处或点击选择文件' if lang == 'zh' else 'Drag files here or click to select files') }}</p>
                        <p class="upload-hint">{{ i18n.get('upload_hint', '支持多文件上传，文件将保存到选定目录的workspace文件夹中' if lang == 'zh' else 'Supports multiple file upload, files will be saved to the workspace folder of the selected directory') }}</p>
                    </div>
                    <input type="file" id="fileInput" multiple style="display: none;">
                    <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                        <i class="fas fa-folder-open"></i> {{ i18n.get('select_files', '选择文件' if lang == 'zh' else 'Select Files') }}
                    </button>
                </div>
                <div class="upload-progress" id="uploadProgress" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="progress-text" id="progressText">{{ i18n.get('uploading', '上传中...' if lang == 'zh' else 'Uploading...') }}</div>
                </div>
                <div class="upload-result" id="uploadResult"></div>
            </div>
        </div>
    </div>

    <!-- Delete File Confirmation Modal -->
    <div id="deleteFileModal" class="modal">
        <div class="modal-content" style="width: 80%; max-width: 400px; height: auto;">
            <div class="modal-header">
                <h3>{{ i18n.get('delete_file_title', '删除文件' if lang == 'zh' else 'Delete File') }}</h3>
                <span class="close" id="deleteFileClose">&times;</span>
            </div>
            <div class="modal-body">
                <div style="padding: 20px; text-align: center;">
                    <div style="font-size: 48px; color: #ff6b6b; margin-bottom: 20px;">
                        <i class="fas fa-exclamation-triangle"></i>
                    </div>
                    <p style="font-size: 18px; margin-bottom: 10px; color: #ffffff;">
                        {{ i18n.get('delete_file_confirm', '确定要删除这个文件吗？' if lang == 'zh' else 'Are you sure you want to delete this file?') }}
                    </p>
                    <p id="deleteFileName" style="font-weight: bold; color: #666; margin-bottom: 30px; word-break: break-all;"></p>
                    <p style="color: #ff6b6b; font-size: 14px; margin-bottom: 30px;">
                        {{ i18n.get('delete_warning', '此操作无法撤销！' if lang == 'zh' else 'This action cannot be undone!') }}
                    </p>
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button id="confirmDeleteFile" class="btn btn-danger" style="background: #ff6b6b; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                            {{ i18n.get('delete_confirm', '删除' if lang == 'zh' else 'Delete') }}
                        </button>
                        <button id="cancelDeleteFile" class="btn btn-secondary" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                            {{ i18n.get('cancel', '取消' if lang == 'zh' else 'Cancel') }}
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Delete Folder Confirmation Modal -->
    <div id="deleteFolderModal" class="modal">
        <div class="modal-content" style="width: 80%; max-width: 400px; height: auto;">
            <div class="modal-header">
                <h3>{{ i18n.get('delete_folder_title', '删除文件夹' if lang == 'zh' else 'Delete Folder') }}</h3>
                <span class="close" id="deleteFolderClose">&times;</span>
            </div>
            <div class="modal-body">
                <div style="padding: 20px; text-align: center;">
                    <div style="font-size: 48px; color: #ff6b6b; margin-bottom: 20px;">
                        <i class="fas fa-exclamation-triangle"></i>
                    </div>
                    <p style="font-size: 18px; margin-bottom: 10px; color: #ffffff;">
                        {{ i18n.get('delete_folder_confirm', '确定要删除这个文件夹吗？' if lang == 'zh' else 'Are you sure you want to delete this folder?') }}
                    </p>
                    <p id="deleteFolderName" style="font-weight: bold; color: #666; margin-bottom: 30px; word-break: break-all;"></p>
                    <p style="color: #ff6b6b; font-size: 14px; margin-bottom: 30px;">
                        {{ i18n.get('delete_folder_warning', '此操作将删除文件夹及其所有内容，无法撤销！' if lang == 'zh' else 'This action will delete the folder and all its contents, and cannot be undone!') }}
                    </p>
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button id="confirmDeleteFolder" class="btn btn-danger" style="background: #ff6b6b; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                            {{ i18n.get('delete_confirm', '删除' if lang == 'zh' else 'Delete') }}
                        </button>
                        <button id="cancelDeleteFolder" class="btn btn-secondary" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                            {{ i18n.get('cancel', '取消' if lang == 'zh' else 'Cancel') }}
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Rename Directory Modal -->
    <div id="renameModal" class="modal">
        <div class="modal-content" style="width: 80%; max-width: 500px; height: auto;">
            <div class="modal-header">
                <h3><i class="fas fa-edit"></i> {{ i18n.rename_title }}</h3>
                <span class="close" id="renameClose">&times;</span>
            </div>
            <div class="modal-body" style="padding: 20px;">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #cccccc; font-weight: 500;">{{ i18n.current_name }}</label>
                    <div id="currentDirName" style="background: #2d2d30; padding: 10px; border-radius: 4px; color: #9cdcfe; font-family: monospace;"></div>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; color: #cccccc; font-weight: 500;">{{ i18n.new_name }}</label>
                    <input type="text" id="newDirName" placeholder="{{ i18n.get('rename_placeholder', 'Enter new directory name...' if lang == 'en' else '输入新的目录名称...') }}" 
                           style="width: 100%; padding: 10px; background: #1e1e1e; border: 1px solid #3e3e42; border-radius: 4px; color: #cccccc; font-family: monospace;">
                    <div style="margin-top: 5px; font-size: 0.9em; color: #9cdcfe;">
                        <i class="fas fa-info-circle"></i> {{ i18n.rename_info }}
                    </div>
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="renameCancel" class="action-btn" style="background: #6c757d; color: white; padding: 10px 20px;">
                        <i class="fas fa-times"></i> {{ i18n.cancel }}
                    </button>
                    <button id="renameConfirm" class="action-btn" style="background: #007acc; color: white; padding: 10px 20px;">
                        <i class="fas fa-check"></i> {{ i18n.confirm_rename }}
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Custom Model Configuration Modal -->
    <div id="customConfigModal" class="modal">
        <div class="modal-content" style="width: 80%; max-width: 600px; height: auto;">
            <div class="modal-header">
                <h3><i class="fas fa-cog"></i> {{ i18n.custom_config_title }}</h3>
                <span class="close" id="customConfigClose">&times;</span>
            </div>
            <div class="modal-body" style="padding: 20px;">
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; color: var(--text-label); font-weight: 500;">{{ i18n.custom_api_key_label }}</label>
                    <div style="position: relative;">
                        <input type="password" id="customApiKey" placeholder="{{ i18n.custom_api_key_placeholder }}" 
                               style="width: 100%; padding: 10px 40px 10px 10px; background: var(--bg-input); border: 1px solid var(--border-primary); border-radius: 4px; color: var(--text-primary); font-family: monospace;">
                        <button type="button" id="customApiKeyToggle" onclick="togglePasswordVisibility('customApiKey')" 
                                style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 21px; padding: 5px;" 
                                title="{{ '显示密码' if lang == 'zh' else 'Show password' }}">
                            <i class="fas fa-eye"></i>
                        </button>
                    </div>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; color: var(--text-label); font-weight: 500;">{{ i18n.custom_api_base_label }}</label>
                    <input type="text" id="customApiBase" placeholder="{{ i18n.custom_api_base_placeholder }}" 
                           style="width: 100%; padding: 10px; background: var(--bg-input); border: 1px solid var(--border-primary); border-radius: 4px; color: var(--text-primary); font-family: monospace;">
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; color: var(--text-label); font-weight: 500;">{{ i18n.custom_model_label }}</label>
                    <input type="text" id="customModel" placeholder="{{ i18n.custom_model_placeholder }}" 
                           style="width: 100%; padding: 10px; background: var(--bg-input); border: 1px solid var(--border-primary); border-radius: 4px; color: var(--text-primary); font-family: monospace;">
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; color: var(--text-label); font-weight: 500;">{{ i18n.custom_max_tokens_label }}</label>
                    <input type="number" id="customMaxTokens" placeholder="{{ i18n.custom_max_tokens_placeholder }}" value="8192" min="1" max="1000000"
                           style="width: 100%; padding: 10px; background: var(--bg-input); border: 1px solid var(--border-primary); border-radius: 4px; color: var(--text-primary); font-family: monospace;">
                </div>
                <div id="customConfigError" style="display: none; color: #ff6b6b; margin-bottom: 15px;">
                    <i class="fas fa-exclamation-triangle"></i> <span id="customConfigErrorText"></span>
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="customConfigCancel" class="action-btn" style="background: #6c757d; color: white; padding: 10px 20px;">
                        <i class="fas fa-times"></i> {{ i18n.custom_config_cancel }}
                    </button>
                    <button id="customConfigSave" class="action-btn" style="background: #007acc; color: white; padding: 10px 20px;">
                        <i class="fas fa-save"></i> {{ i18n.custom_config_save }}
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Contact Us Modal -->
    <div id="contactUsModal" class="modal">
        <div class="modal-content" style="width: 80%; max-width: 600px; height: auto;">
            <div class="modal-header">
                <h3><i class="fas fa-envelope"></i> {{ i18n.get('contact_us', '联系我们' if lang == 'zh' else 'Contact Us') }}</h3>
                <span class="close" id="contactUsClose">&times;</span>
            </div>
            <div class="modal-body" style="padding: 20px;">
                <div style="margin-bottom: 15px; padding: 10px; background: var(--bg-secondary); border-radius: 4px;">
                    <div style="color: var(--text-primary); font-size: 0.95em; line-height: 1.6;">
                        {{ '如果您对此软件有什么反馈意见，请在此留言，或发邮件到 bitcursor@2925.com' if lang == 'zh' else 'If you have any feedback about this software, please leave a message here or send an email to bitcursor@2925.com' }}
                    </div>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: var(--text-label); font-weight: 500;">{{ i18n.get('contact_current_dir_label', '当前工作目录' if lang == 'zh' else 'Current Workspace Directory') }}:</label>
                    <div id="contactCurrentDir" style="padding: 8px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: 4px; color: var(--text-secondary); font-family: monospace; font-size: 0.9em; word-break: break-all;">-</div>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: var(--text-label); font-weight: 500;">{{ i18n.get('contact_contact_info_label', '您的联系方式（邮箱或电话，选填）' if lang == 'zh' else 'Your Contact Information (Email or Phone, Optional)') }}:</label>
                    <input type="text" id="contactInfo" placeholder="{{ i18n.get('contact_contact_info_placeholder', '请输入您的邮箱或电话（选填）' if lang == 'zh' else 'Please enter your email or phone (optional)') }}" 
                           style="width: 100%; padding: 10px; background: var(--bg-input); border: 1px solid var(--border-primary); border-radius: 4px; color: var(--text-primary); font-family: inherit;">
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; color: var(--text-label); font-weight: 500;">{{ i18n.get('contact_message_label', '留言内容' if lang == 'zh' else 'Message') }}:</label>
                    <textarea id="contactMessage" placeholder="{{ i18n.get('contact_message_placeholder', '请输入您的留言...' if lang == 'zh' else 'Please enter your message...') }}" 
                              style="width: 100%; min-height: 200px; padding: 10px; background: var(--bg-input); border: 1px solid var(--border-primary); border-radius: 4px; color: var(--text-primary); font-family: inherit; resize: vertical;"></textarea>
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="contactCancel" class="action-btn" style="background: #6c757d; color: white; padding: 10px 20px;">
                        <i class="fas fa-times"></i> {{ i18n.cancel }}
                    </button>
                    <button id="contactSubmit" class="action-btn" style="background: #007acc; color: white; padding: 10px 20px;">
                        <i class="fas fa-paper-plane"></i> {{ i18n.get('submit', '提交' if lang == 'zh' else 'Submit') }}
                    </button>
                </div>
            </div>
        </div>
    </div>


    <script src="{{ url_for('static', filename='js/socket.io.js') }}"></script>
    <script src="{{ url_for('static', filename='js/marked.min.js') }}"></script>
    <!-- Mermaid.js for diagram rendering -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script id="i18nData" type="application/json">{{ i18n | tojson }}</script>
    <script>
        // Internationalization configuration
        const I18N = JSON.parse(document.getElementById('i18nData').textContent);
        const CURRENT_LANG = '{{ lang }}';
        
        /**
         * 获取当前语言设置（动态获取，优先从URL参数，然后localStorage，最后使用页面加载时的值）
         * @returns {string} 当前语言代码 ('zh' 或 'en')
         */
        function getCurrentLanguage() {
            // 优先从URL参数获取
            const urlParams = new URLSearchParams(window.location.search);
            let currentLang = urlParams.get('lang');
            
            // 如果没有URL参数，从localStorage获取
            if (!currentLang) {
                currentLang = localStorage.getItem('preferred_lang');
            }
            
            // 如果还是没有，使用页面加载时的值
            if (!currentLang) {
                currentLang = CURRENT_LANG;
            }
            
            // 确保返回值是有效的语言代码
            return (currentLang === 'zh' || currentLang === 'en') ? currentLang : 'en';
        }
    </script>
    <script>
        // User connection management
        let socket = null;
        let currentUser = null;
        let currentUserName = null;
        let isConnected = false;
        let isConnecting = false; // 标记是否处于连接中状态
        
        const MAX_AUTO_RECONNECT_ATTEMPTS = 5;
        let isManualDisconnect = false;
        let isAutoReconnectInProgress = false;
        let wasReconnected = false; // 标记是否是重连后的连接
        let heartbeatInterval = null;  // 心跳定时器
        const HEARTBEAT_INTERVAL = 55000;  // 每55秒发送一次心跳（小于服务器ping_interval=60秒）
        
        // 生成或获取持久化的客户端会话ID
        function getOrCreateClientSessionId() {
            try {
                let clientSessionId = localStorage.getItem('agia_client_session_id');
                if (!clientSessionId) {
                    // 生成一个唯一的客户端会话ID
                    clientSessionId = 'client_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem('agia_client_session_id', clientSessionId);
                }
                return clientSessionId;
            } catch (error) {
                // 如果localStorage不可用，生成一个临时ID
                return 'client_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }
        }
        
        // Socket.IO connection configuration (will be initialized when user connects)
        function createSocket(apiKey) {
            const clientSessionId = getOrCreateClientSessionId();
            
            return io({
                reconnection: true,
                reconnectionAttempts: MAX_AUTO_RECONNECT_ATTEMPTS,
                reconnectionDelay: 2000,
                reconnectionDelayMax: 10000,
                timeout: 120000,                // 🔧 增加连接超时到120秒，匹配服务器配置
                forceNew: true,                 // 🔧 改为true，确保每次创建全新的socket实例，避免事件监听器重复注册
                // 🔧 修复传输配置：优先使用WebSocket，fallback到polling
                transports: ['websocket', 'polling'],
                upgrade: true,                  // 允许传输升级
                rememberUpgrade: true,          // 记住升级状态
                // 🔧 修复：显式设置ping超时和ping间隔，匹配服务器配置
                pingTimeout: 600000,            // 10分钟，匹配服务器ping_timeout=600秒
                pingInterval: 55000,            // 55秒，略小于服务器ping_interval=60秒，确保客户端先发送心跳
                // 🔧 添加WebSocket特定配置
                transportOptions: {
                    websocket: {
                        maxHttpBufferSize: 1e8      // 增加缓冲区大小
                    }
                },
                auth: {
                    api_key: apiKey || null,
                    client_session_id: clientSessionId,  // 发送客户端会话ID
                    app_name: getCurrentAppFromPath()  // 发送当前应用名称（从URL路径获取）
                }
            });
        }
        
        // DOM elements
        const chatMessages = document.getElementById('chatMessages');
        const userInput = document.getElementById('userInput');
        const sendButton = document.getElementById('sendButton');

        const newTaskButton = document.getElementById('newTaskButton');
        const stopButton = document.getElementById('stopButton');
        const appendTaskButton = document.getElementById('appendTaskButton');
        const clearChatButton = document.getElementById('clearChatButton');
        const directoryList = document.getElementById('directoryList');
        const sidebarLoading = document.getElementById('sidebarLoading');
        
        // User authentication elements
        const apiKeyInput = document.getElementById('apiKeyInput');
        const connectBtn = document.getElementById('connectBtn');
        const userStatusText = document.getElementById('userStatusText');
        const userIdentity = document.getElementById('userIdentity');
        
        // State management
        let isTaskRunning = false;
        let infiniteExecuteMode = false; // 无限执行模式状态
        let multiAgentMode = false; // 多智能体模式状态
        let webSearchMode = true; // 搜索网络模式状态，默认开启
        let selectedDirectory = null;
        let taskMode = 'new'; // 'new', 'continue', 'selected' - 默认为新建模式
        let expandedDirectories = new Set();
        let collapsedSubDirectories = new Set(); // Save collapsed subdirectory state
        let expandedSubDirectories = new Set(); // Save expanded subdirectory state
        let isUserScrolling = false; // Whether user is manually scrolling
        let autoScrollEnabled = true; // Whether auto-scroll is enabled
        let detailInfoAutoScrollEnabled = false; // Whether auto-scroll is enabled for detail info messages
        let savedAutoScrollStateBeforeLoading = true; // 保存加载manager.out前的自动滚动状态
        let refreshTimeout = null; // Debounce timer
        let scrollDirection = 'down'; // 'up' or 'down'
        let lastScrollTop = 0;
        let isGuest = false; // 添加guest状态跟踪
        let isDirectoryLoading = false; // 标记目录是否正在加载
        let pendingUploadFiles = null; // 用于存储待上传的文件（当需要先创建目录时）
        // let newMessageCount = 0; // New message counter (已禁用)
        let lastMessageTime = 0;
        let pendingUserInput = ''; // 保存等待执行的用户输入
        let isCreatingDirectoryForTask = false; // 标记是否因为发送任务而创建目录
        let userInputTimeoutTimer = null; // 用户输入超时定时器
        let isWaitingForUserInput = false; // 标记是否有等待的user_input_request
        let currentTaskPlanMode = false; // 保存当前任务的plan_mode状态
        
        // File monitoring variables
        let fileMonitoringTimer = null;
        let lastFileCount = null;
        let fileMonitoringInterval = 2000; // 2 seconds

        // User connection management functions
        function updateUserStatus(status, message, identity = '', isGuest = false) {
            const statusClasses = {
                'disconnected': '',
                'connecting': 'connecting',
                'connected': 'connected',
                'error': 'error'
            };
            
            if (status === 'connected' && isGuest) {
                message = I18N.temporary_connection || '临时连接';
            }
            userStatusText.textContent = message;
            userIdentity.textContent = identity;
            
            // Update connect button
            if (status === 'connected') {
                connectBtn.style.background = 'var(--color-accent)';
                connectBtn.style.color = 'white';
                connectBtn.style.borderColor = 'var(--color-accent)';
                connectBtn.innerHTML = `<i class="fas fa-unlink"></i>`;
                connectBtn.disabled = false;
                connectBtn.title = I18N.disconnect_btn || '断开连接';
                isConnected = true;
                isConnecting = false;
                
                // Enable UI controls
                enableUI(true);
                
                // 如果目录正在加载，更新消息显示
                if (isDirectoryLoading && directoryList) {
                    renderDisconnectedWorkspaceMessage();
                }
            } else if (status === 'connecting') {
                connectBtn.disabled = true;
                connectBtn.innerHTML = `<i class="fas fa-spinner fa-spin"></i>`;
                connectBtn.style.opacity = '0.6';
                // 处于连接中状态：暂时视为"正在尝试连接"，不显示"请先连接"提示
                isConnected = false;
                isConnecting = true;
                
                // Disable UI controls
                enableUI(false);
                
                // 如果目录正在加载，更新消息显示
                if (isDirectoryLoading && directoryList) {
                    renderDisconnectedWorkspaceMessage();
                }
            } else {
                connectBtn.style.background = 'transparent';
                connectBtn.style.color = 'var(--color-accent)';
                connectBtn.style.borderColor = 'var(--color-accent)';
                connectBtn.innerHTML = `<i class="fas fa-plug"></i>`;
                connectBtn.disabled = false;
                connectBtn.style.opacity = '1';
                connectBtn.title = I18N.connect_btn || '连接网络';
                isConnected = false;
                isConnecting = false;
                
                // Disable UI controls
                enableUI(false);
                
                // 仅在最终确定为未连接/出错时显示“请先连接”提示
                if (status === 'disconnected' || status === 'error') {
                    renderDisconnectedWorkspaceMessage();
                }
            }
        }
        
        function enableUI(enabled) {
            // 允许用户在任务执行过程中输入新的需求，但不允许执行
            userInput.disabled = !enabled;
            sendButton.disabled = !enabled || isTaskRunning;
            newTaskButton.disabled = !enabled || isTaskRunning;
            
            // Enable/disable directory operations
            const actionBtns = document.querySelectorAll('.directory-item .action-btn');
            actionBtns.forEach(btn => {
                btn.disabled = !enabled;
            });
        }
        
        function connectUser() {
            const apiKey = apiKeyInput.value.trim();
            isManualDisconnect = false;
            isAutoReconnectInProgress = false;
            
            updateUserStatus('connecting', I18N.connecting);
            
            // 🔧 修复：在创建新socket之前，先关闭并清理旧的socket连接
            if (socket) {
                console.log('⚠️ 检测到旧的socket连接，先关闭它以避免重复消息');
                socket.removeAllListeners();  // 移除所有事件监听器
                socket.disconnect();
                socket = null;
            }
            
            // Create socket connection
            socket = createSocket(apiKey);
            currentUser = apiKey || 'default';
            
            // Setup socket event listeners
            setupSocketListeners();
            
            // Attempt to connect
            socket.connect();
        }
        
        function disconnectUser() {
            isManualDisconnect = true;
            isAutoReconnectInProgress = false;
            // 如果当前有任务在运行，先停止任务
            if (isTaskRunning && socket) {
                socket.emit('stop_task');
                // 等待任务停止后再断开连接
                setTimeout(() => {
                    performDisconnect();
                }, 500); // 给服务器500ms时间处理停止任务请求
            } else {
                performDisconnect();
            }
        }
        
        function performDisconnect() {
            if (socket) {
                socket.disconnect();
                socket = null;
            }
            // 手动断开时清空工具调用细节框
            const detailInfoMessages = document.getElementById('detailInfoMessages');
            if (detailInfoMessages) {
                detailInfoMessages.innerHTML = '';
            }
            resetAfterDisconnect();
            isManualDisconnect = false;
        }
        
        function resetAfterDisconnect(removeSession = true) {
            // 停止心跳
            stopHeartbeat();
            
            currentUser = null;
            currentUserName = null;
            isConnected = false;
            isConnecting = false;
            isGuest = false;
            isDirectoryLoading = false; // 重置目录加载状态
            selectedDirectory = null;
            taskMode = 'new';
            pendingUserInput = '';
            isCreatingDirectoryForTask = false;
            // Update agent view button state
            updateAgentViewButtonState();
            isAutoReconnectInProgress = false;
            expandedDirectories = new Set();
            collapsedSubDirectories = new Set();
            expandedSubDirectories = new Set();
            isWaitingForUserInput = false;
            if (userInputTimeoutTimer !== null) {
                clearTimeout(userInputTimeoutTimer);
                userInputTimeoutTimer = null;
            }
            
            updateUserStatus('disconnected', I18N.user_disconnected);
            
            if (typeof setTaskRunning === 'function') {
                setTaskRunning(false);
            } else {
                isTaskRunning = false;
            }
            
            if (removeSession) {
                try {
                    localStorage.removeItem('agia_api_key');
                } catch (error) {
                    // 静默处理错误
                }
            }
            
            chatMessages.innerHTML = `
                <div class="message system">
                    <strong><i class="fas fa-info-circle"></i> ${I18N.system_message || '系统消息'}</strong><br>
                    ${I18N.welcome_message || '欢迎使用 OfficeCowork！请在下方输入您的需求，系统将自动为您处理任务。'}
                </div>
            `;
            
            directoryList.innerHTML = '';
            
            stopFileMonitoring();
        }
        
        function handleAutoReconnectFailure() {
            if (socket) {
                try {
                    isManualDisconnect = true;
                    socket.disconnect();
                } catch (error) {
                    // ignore
                }
                socket = null;
            }
            isManualDisconnect = false;
            resetAfterDisconnect();
        }

        // File preview functionality
        const previewModal = document.getElementById('previewModal');
        const previewTitle = document.getElementById('previewTitle');
        const previewContent = document.getElementById('previewContent');
        const previewClose = document.getElementById('previewClose');

        // File upload functionality
        const uploadModal = document.getElementById('uploadModal');
        const uploadTitle = document.getElementById('uploadTitle');
        const uploadClose = document.getElementById('uploadClose');
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const uploadProgress = document.getElementById('uploadProgress');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const uploadResult = document.getElementById('uploadResult');
        
        let currentUploadDir = null;
        
        // 心跳机制：定期发送心跳消息保持连接活跃
        function startHeartbeat() {
            // 清除可能存在的旧定时器
            stopHeartbeat();
            
            // 如果socket未连接，不启动心跳
            if (!socket || !socket.connected) {
                return;
            }
            
            // 立即发送一次心跳
            sendHeartbeat();
            
            // 设置定时器，每55秒发送一次心跳（小于服务器ping_interval=60秒）
            heartbeatInterval = setInterval(function() {
                if (socket && socket.connected) {
                    // 始终发送心跳保持连接，即使在任务执行时也需要保持连接活跃
                    sendHeartbeat();
                }
            }, HEARTBEAT_INTERVAL);
        }
        
        function stopHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
        }
        
        function sendHeartbeat() {
            if (socket && socket.connected) {
                try {
                    // 发送心跳消息，服务器会响应以保持连接活跃
                    const ts = Date.now();
                    socket.emit('heartbeat', {
                        timestamp: ts
                    });
                    // 🔧 增强：记录心跳发送失败的情况
                } catch (error) {
                    console.error(`[${new Date().toISOString()}] ❌ 心跳发送失败:`, error);
                    // 如果心跳发送失败，可能是连接已断开，尝试重连
                    if (socket && !socket.connected) {
                        console.log(`[${new Date().toISOString()}] 🔄 检测到连接断开，尝试重连...`);
                        socket.connect();
                    }
                }
            } else {
                console.log(`[${new Date().toISOString()}] ⚠️ 心跳跳过: socket=${!!socket}, connected=${socket?.connected}`);
            }
        }
        
        // Setup socket event listeners
        function setupSocketListeners() {
            if (!socket) return;
            
            // 🔧 防止监听器重复注册：在注册新监听器之前，移除所有旧的监听器
            socket.off('connect');
            socket.off('status');
            socket.off('disconnect');
            socket.off('auth_failed');
            socket.off('connect_error');
            socket.off('reconnect_attempt');
            socket.off('reconnect_error');
            socket.off('reconnect');
            socket.off('reconnect_failed');
            socket.off('heartbeat_ack');
            socket.off('task_started');
            socket.off('output');
            socket.off('user_input_request');
            socket.off('task_completed');
            socket.off('task_stopped');
            socket.off('append_task_success');
            socket.off('error');
            socket.off('directory_selected');
            socket.off('directory_created');
            socket.off('chat_cleared');
            
            socket.on('connect', function() {
                // 🔧 修改：无论是首次连接还是重连，只要没有选择目录，就自动选择第一个目录
                const shouldAutoSelectFirst = !selectedDirectory;
                wasReconnected = false; // 重置标志
                isAutoReconnectInProgress = false;
                // 等待status事件获取用户名，如果还没有获取到则暂时显示API Key
                const identity = currentUser === 'default' ? I18N.default_user :
                    (currentUserName ? `${I18N.user_prefix}: ${currentUserName}` : `${I18N.user_prefix}: ${currentUser}`);
                updateUserStatus('connected', I18N.user_connected, identity);

                // Save API key to localStorage for session restoration
                try {
                    if (currentUser && currentUser !== 'default') {
                        localStorage.setItem('agia_api_key', currentUser);
                    } else {
                        // For default user, save a special marker
                        localStorage.setItem('agia_api_key', '');
                    }
                } catch (error) {
                    // 静默处理错误
                }
                
                // Refresh directories for this user
                // 如果是重连后且没有已选择的目录，则自动选择第一个目录
                refreshDirectories(shouldAutoSelectFirst);

                // 连接成功后，确保任务发起按钮处于就绪状态
                ensureTaskTriggerReady();
                
                // 启动心跳机制，定期发送心跳消息保持连接活跃
                startHeartbeat();
                
                // Ensure scroll to bottom after connection
                setTimeout(() => {
                    scrollToBottom(false);
                }, 100);
            });
            
            socket.on('status', function(data) {
                isGuest = data.is_guest || false; // 保存到全局变量
                currentUserName = data.user_name || 'unknown'; // 保存用户名到全局变量
                let identity = '';

                if (isGuest) {
                    identity = I18N.guest_user || '访客用户';
                } else {
                    identity = currentUser === 'default' ? I18N.default_user : `${I18N.user_prefix}: ${currentUserName}`;
                }

                updateUserStatus('connected', I18N.user_connected, identity, isGuest);
                
                // 检查是否是恢复的会话
                if (data.recovered) {
                    // 🔧 恢复任务状态
                    if (data.task_running) {
                        console.log(`[${new Date().toISOString()}] 🔄 任务仍在运行`);
                        addMessage('🔄 连接已恢复，任务继续运行中...', 'info');
                        setTaskRunning(true);
                    }
                    
                    // 🔧 恢复文件夹选择状态
                    if (data.selected_output_dir) {
                        selectedDirectory = data.selected_output_dir;
                        taskMode = 'selected';
                        // 更新UI显示选中状态
                        setTimeout(() => {
                            const selectedItem = document.querySelector(`[data-dir="${data.selected_output_dir}"]`);
                            if (selectedItem) {
                                selectedItem.classList.add('selected');
                            }
                        }, 500); // 延迟一点，等待目录列表加载
                    } else if (data.last_output_dir) {
                        console.log(`[${new Date().toISOString()}] 🔄 恢复上次使用的文件夹: ${data.last_output_dir}`);
                        // 如果没有选中的文件夹但有上次使用的，也显示出来
                        setTimeout(() => {
                            const lastItem = document.querySelector(`[data-dir="${data.last_output_dir}"]`);
                            if (lastItem) {
                                // 可以用不同的样式标记上次使用的（如果需要的话）
                            }
                        }, 500);
                    }
                }
            });

            socket.on('disconnect', function(reason) {
                console.log(`[${new Date().toISOString()}] ❌ 连接断开! reason=${reason}, isTaskRunning=${isTaskRunning}, isManualDisconnect=${isManualDisconnect}`);
                // 停止心跳
                stopHeartbeat();
                
                if (isManualDisconnect) {
                    console.log(`[${new Date().toISOString()}] 手动断开，跳过重连`);
                    isManualDisconnect = false;
                    return;
                }
                
                isAutoReconnectInProgress = true;
                updateUserStatus('disconnected', I18N.user_disconnected);
                // 不显示断开连接消息，只更新状态
                
                // If task is running, give special prompt
                if (isTaskRunning) {
                    console.log(`[${new Date().toISOString()}] ⚠️ 任务运行中断开连接!`);
                    const message = I18N.connection_interrupted_reconnecting || '连接中断，正在尝试重新连接...';
                    addMessage(`⚠️ ${message}`, 'warning');
                    // 连接中断时，清除所有蓝色勾选状态
                    clearAllDirectorySelections();
                }
            });

            socket.on('auth_failed', function(data) {
                updateUserStatus('error', '认证失败');
                addMessage('认证失败: ' + (data.message || '未知错误'), 'error');
                console.log('❌ Authentication failed:', data);
            });

            
            socket.on('connect_error', function(error) {
                if (isAutoReconnectInProgress) {
                    // 自动重连时出错，不显示消息，只保持未连接状态
                    return;
                }
                updateUserStatus('error', I18N.connection_error || '连接错误');
                addMessage(`${I18N.connection_error || '连接错误'}: ${error.message}`, 'error');
            });

            socket.on('reconnect_attempt', function(attemptNumber) {
                isAutoReconnectInProgress = true;
                const attempt = Math.min(attemptNumber || 1, MAX_AUTO_RECONNECT_ATTEMPTS);
                console.log(`[${new Date().toISOString()}] 🔁 重连尝试 ${attempt}/${MAX_AUTO_RECONNECT_ATTEMPTS}`);
                addMessage(`🔁 ${(I18N.reconnect_attempt || '正在尝试重新连接')} (${attempt}/${MAX_AUTO_RECONNECT_ATTEMPTS})`, 'warning');
                updateUserStatus('connecting', I18N.reconnecting || I18N.connecting);
            });

            socket.on('reconnect_error', function(error) {
                if (!isAutoReconnectInProgress) return;
                // 自动重连时出错，不显示消息，只保持未连接状态
            });

            socket.on('reconnect', function(attemptNumber) {
                isAutoReconnectInProgress = false;
                wasReconnected = true; // 标记为重连
                console.log(`[${new Date().toISOString()}] ✅ 重连成功！尝试次数: ${attemptNumber}`);
                addMessage(I18N.reconnect_success || '已重新连接到服务器', 'success');
                // 重连后，清除所有蓝色勾选状态
                clearAllDirectorySelections();
                ensureTaskTriggerReady();
            });

            socket.on('reconnect_failed', function() {
                console.log(`[${new Date().toISOString()}] ❌ 重连失败：已达到最大重连次数`);
                isAutoReconnectInProgress = false;
                addMessage(I18N.reconnect_failed_cleanup || '多次重连失败，已断开连接', 'error');
                handleAutoReconnectFailure();
            });

            socket.on('heartbeat_ack', function(data) {
                // 心跳响应，连接正常
                const latency = Date.now() - data.timestamp;
            });

            // 监听底层 engine 的 ping/pong 事件
            socket.io.engine.on('ping', function() {
                console.log(`[${new Date().toISOString()}] 🏓 收到服务器ping`);
            });
            
            socket.io.engine.on('pong', function(latency) {
            });

            socket.on('task_started', function(data) {
                // 任务成功启动后，清空pendingUserInput
                pendingUserInput = '';
                // 任务开始时重置消息状态，确保新的任务从新的info消息框开始
                lastMessageType = null;
                lastMessageDiv = null;
                lastMessageContent = null;
                // 重置JSON收集状态
                resetJsonCollectingState();
                
                addMessage(data.message, 'info');
                setTaskRunning(true);
                // 任务真正开始时才清空输入框和待执行内容
                userInput.value = '';
                pendingUserInput = '';
                resizeTextarea();
            });

            socket.on('output', function(data) {
                // 检查当前选择的agent，如果不是manager，则丢弃消息
                const wrapper = document.getElementById('agentSelectWrapper');
                const dropdown = document.getElementById('agentSelectDropdown');
                if (wrapper && wrapper.style.display !== 'none' && dropdown) {
                    const selectedAgent = dropdown.value || 'manager';
                    // 如果选择的不是manager，直接丢弃消息，不显示
                    if (selectedAgent !== 'manager') {
                        return; // 直接返回，不处理消息
                    }
                }
                
                // Pass is_update flag to addMessage
                addMessage(data.message, data.type || 'info', data.is_update || false);
                
                // 如果收到"没有任务运行"的消息，恢复到默认状态
                if (data.message && (
                    data.message.includes('没有任务在运行') || 
                    data.message.includes('No task is currently running') ||
                    data.message.includes('no_task_running')
                )) {
                    setTaskRunning(false);
                    // 确保按钮处于启用状态
                    if (sendButton) sendButton.disabled = false;
                    if (newTaskButton) newTaskButton.disabled = false;
                }
            });

            socket.on('user_input_request', function(data) {
                console.log('[DEBUG] 🔔 前端收到 user_input_request 事件');
                console.log('[DEBUG] 收到的数据:', data);
                
                // Clear any existing timeout timer
                if (userInputTimeoutTimer !== null) {
                    clearTimeout(userInputTimeoutTimer);
                    userInputTimeoutTimer = null;
                }
                
                // 设置等待用户输入标志
                isWaitingForUserInput = true;
                console.log('[DEBUG] ✅ 设置 isWaitingForUserInput = true');
                
                const query = data.query || '';
                const timeout = data.timeout || 10;
                console.log('[DEBUG] query:', query.substring(0, 100) + '...');
                console.log('[DEBUG] timeout:', timeout);
                
                // 解析选项
                const parseResult = parseOptions(query);
                const options = parseResult.options;
                const optionStartIndex = parseResult.optionStartIndex;
                
                // 调试信息：检查是否解析到选项
                console.log('=== 选项解析调试信息 ===');
                console.log('原始query长度:', query.length);
                console.log('query前200字符:', query.substring(0, 200));
                console.log('解析到的选项数量:', options.length);
                console.log('选项起始行索引:', optionStartIndex);
                if (options.length > 0) {
                    console.log('✅ 成功识别到选项:');
                    options.forEach((opt, idx) => {
                        console.log(`  选项 ${idx + 1}: ${opt.label}. ${opt.text.substring(0, 50)}... (hasCheckbox: ${opt.hasCheckbox}, fullText: ${opt.fullText.substring(0, 50)})`);
                    });
                } else {
                    console.log('❌ 未识别到任何选项');
                    // 尝试查找方框字符
                    const lines = query.split('\n');
                    const checkboxChars = ['\u25A1', '\u2610'];
                    let foundCheckboxes = [];
                    lines.forEach((line, idx) => {
                        checkboxChars.forEach(char => {
                            if (line.includes(char)) {
                                foundCheckboxes.push({line: idx + 1, content: line.substring(0, 80)});
                            }
                        });
                    });
                    if (foundCheckboxes.length > 0) {
                        console.log('⚠️ 发现包含方框字符的行，但未解析为选项:');
                        foundCheckboxes.forEach(item => {
                            console.log(`  第${item.line}行: ${item.content}`);
                            // 尝试手动解析这一行
                            const trimmed = item.content.trim();
                            const manualMatch = trimmed.match(/.*?[\u25A1\u2610]\s*([A-Z])[.)]\s*(.+)$/);
                            if (manualMatch) {
                                console.log(`    手动解析结果: label=${manualMatch[1]}, text=${manualMatch[2].substring(0, 30)}`);
                            }
                        });
                    }
                }
                console.log('======================');
                
                // 在聊天窗口中显示问题和选项
                // 如果有选项，需要从query中移除选项部分
                let questionText = query;
                if (options.length > 0 && optionStartIndex >= 0) {
                    // 只保留选项之前的内容作为问题
                    const lines = query.split('\n');
                    questionText = lines.slice(0, optionStartIndex).join('\n').trim();
                    
                    // 如果questionText为空或太短，尝试从query中移除所有选项行
                    if (!questionText || questionText.length < 10) {
                        // 移除所有包含选项的行
                        const allLines = query.split('\n');
                        const filteredLines = allLines.filter((line, idx) => {
                            // 检查这一行是否匹配选项格式
                            const trimmed = line.trim();
                            if (!trimmed) return true; // 保留空行
                            // 检查是否是选项行
                            const isOptionLine = /.*?[\u25A1\u2610\u25A0-\u25AF\u2611\u2612]\s*[A-Z][.)]\s*/.test(trimmed) ||
                                                 /^[-•]?\s*[A-Z][.)]\s*/.test(trimmed);
                            return !isOptionLine;
                        });
                        questionText = filteredLines.join('\n').trim();
                    }
                }
                
                // 显示问题（如果questionText不为空）
                if (questionText) {
                    addMessage(questionText, 'info');
                }
                
                // 如果有选项，显示选择题
                if (options.length > 0) {
                    console.log('✅ 准备显示', options.length, '个选项的复选框');
                    // 创建选择题容器
                    const choiceContainer = document.createElement('div');
                    choiceContainer.className = 'message choice-message';
                    choiceContainer.style.cssText = 'padding: 15px; background: var(--bg-secondary); border-radius: 8px; margin: 10px 0;';
                    
                    // 为每个选项创建复选框
                    options.forEach(function(option) {
                        const optionDiv = document.createElement('div');
                        optionDiv.style.cssText = 'display: flex; align-items: flex-start; padding: 8px 0; cursor: pointer;';
                        optionDiv.className = 'choice-option';
                        
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.value = option.fullText;
                        checkbox.style.cssText = 'margin-right: 10px; margin-top: 3px; cursor: pointer; width: 18px; height: 18px;';
                        checkbox.className = 'choice-checkbox';
                        
                        const label = document.createElement('label');
                        label.style.cssText = 'flex: 1; cursor: pointer; color: var(--text-primary); line-height: 1.5;';
                        label.textContent = option.fullText;
                        label.setAttribute('for', 'choice-' + option.label);
                        checkbox.id = 'choice-' + option.label;
                        
                        // 复选框状态变化时不再发送，改为仅显示状态
                        checkbox.addEventListener('change', function() {
                            // 不再发送user_input_response，用户需要在输入框中输入
                            // 仅更新UI状态
                            if (checkbox.checked) {
                                // 禁用所有复选框，防止重复选择
                                document.querySelectorAll('.choice-checkbox').forEach(function(cb) {
                                    cb.disabled = true;
                                });
                                // 显示已选择的状态
                                document.querySelectorAll('.choice-option').forEach(function(opt) {
                                    opt.style.opacity = '0.6';
                                });
                            }
                        });
                        
                        // 点击选项的其他部分时，切换复选框状态（仅用于显示，不发送）
                        optionDiv.addEventListener('click', function(e) {
                            // 如果点击的是复选框本身，不处理（change事件会处理）
                            if (e.target === checkbox) {
                                return;
                            }
                            // 点击选项的其他部分，切换复选框状态
                            checkbox.checked = !checkbox.checked;
                            // 触发change事件
                            checkbox.dispatchEvent(new Event('change'));
                        });
                        
                        optionDiv.appendChild(checkbox);
                        optionDiv.appendChild(label);
                        choiceContainer.appendChild(optionDiv);
                    });
                    
                    // 添加到聊天窗口
                    const chatMessages = document.getElementById('chatMessages');
                    if (chatMessages) {
                        chatMessages.appendChild(choiceContainer);
                        // 自动滚动到底部
                        throttledAutoScroll(true);
                    }
                } else {
                    // 如果没有选项，显示文本输入提示（保留原有功能作为后备）
                    addMessage('请直接在输入框中回复', 'info');
                }
                
                // Set timeout if specified
                if (timeout > 0 && timeout !== -1) {
                    console.log('🔔 Setting user input timeout:', timeout, 'seconds');
                    userInputTimeoutTimer = setTimeout(function() {
                        console.log('⏰ User input timeout reached');
                        // Timeout - send empty response
                        socket.emit('user_input_response', { input: '' });
                        userInputTimeoutTimer = null;
                        isWaitingForUserInput = false;
                    }, timeout * 1000);
                } else {
                    console.log('🔔 User input timeout disabled (timeout =', timeout, ')');
                }
            });

            socket.on('task_completed', function(data) {
                addMessage(data.message, data.success ? 'success' : 'error');
                setTaskRunning(false);
                // 任务完成时清理待执行内容
                pendingUserInput = '';
                
                // 任务完成时，清空工具调用信息显示框
                const detailInfoMessages = document.getElementById('detailInfoMessages');
                if (detailInfoMessages) {
                    detailInfoMessages.innerHTML = '';
                }
                
                // Check if this was a plan mode task using saved state
                const wasPlanMode = currentTaskPlanMode;
                
                // After task completion, if there's a selected directory, keep selection state, otherwise switch to continue mode
                if (selectedDirectory) {
                    taskMode = 'selected';
                    // If the completed task directory is the selected directory, auto-expand it
                    if (data.output_dir && data.output_dir === selectedDirectory) {
                        expandedDirectories.add(selectedDirectory);
                    }
                } else {
                    taskMode = 'continue';
                    // If there's a working directory, auto-expand the latest directory
                    if (data.output_dir) {
                        expandedDirectories.add(data.output_dir);
                    }
                }
                
                // If plan mode completed, auto-fill input and switch to agent mode
                if (wasPlanMode) {
                    const userInput = document.getElementById('userInput');
                    const modeSelect = document.getElementById('executionModeSelect');
                    if (userInput && modeSelect) {
                        userInput.value = '@plan.md 请按照这个计划执行';
                        modeSelect.value = 'agent';
                        // Trigger resize to adjust textarea height
                        if (typeof resizeTextarea === 'function') {
                            resizeTextarea();
                        }
                    }
                    // Reset plan mode state after handling
                    currentTaskPlanMode = false;
                }
                
                // Refresh directory list with longer delay to ensure files are generated
                setTimeout(() => {
                    refreshDirectories();
                }, 2000);
            });

            socket.on('task_stopped', function(data) {
                addMessage(data.message, data.type || 'error');
                setTaskRunning(false);
                // 🔧 Fix: 确保任务停止时结束绿框状态
                resetJsonCollectingState();
                lastMessageType = null;
                lastMessageDiv = null;
                lastMessageContent = null;
                // 任务停止时，如果有待执行的用户输入，恢复到输入框
                if (pendingUserInput) {
                    userInput.value = pendingUserInput;
                    pendingUserInput = '';
                    resizeTextarea();
                }
                // Reset plan mode state
                currentTaskPlanMode = false;
                // Keep current task mode
                // Refresh directories after stopping task
                setTimeout(refreshDirectories, 1000);
            });

            socket.on('append_task_success', function(data) {
                addMessage(data.message || I18N.get('append_task_success', '任务已成功发送给智能体'), 'success');
            });

            socket.on('error', function(data) {
                addMessage(data.message, 'error');
                setTaskRunning(false);
                // 特别处理"请先创建或者选择一个工作目录"的错误，确保恢复用户输入
                const isDirectorySelectionError = data.message && (
                    data.message.includes('请先创建或者选择一个工作目录') || 
                    data.message.includes('Please create or select a workspace directory')
                );
                
                // 如果有待执行的用户输入，恢复到输入框
                if (pendingUserInput) {
                    // 如果是目录选择错误，或者输入框为空，恢复用户输入
                    if (isDirectorySelectionError || !userInput.value.trim()) {
                        userInput.value = pendingUserInput;
                        resizeTextarea();
                    }
                    // 注意：对于目录选择错误，不清空pendingUserInput，以便用户可以重新尝试
                    // 只有在任务成功启动时才清空pendingUserInput（在task_started事件中处理）
                    if (!isDirectorySelectionError) {
                        pendingUserInput = '';
                    }
                }
                // Reset plan mode state
                currentTaskPlanMode = false;
            });

            socket.on('directory_selected', function(data) {
                selectedDirectory = data.dir_name;
                if (selectedDirectory) {
                    taskMode = 'selected';
                    // 不需要刷新整个目录列表，UI状态已经在 selectDirectory 中更新了
                    // refreshDirectories(); // 移除：避免不必要的网络请求和DOM重渲染
                    // 启动文件监测
                    startFileMonitoring();
                    
                    // 更新agent选择下拉框
                    updateAgentSelectDropdown(data.out_files || []);
                    
                    // 无论是否有manager.out内容，都先清空聊天记录框
                    // 这样可以确保切换目录时总是清空旧内容
                    const chatMessages = document.getElementById('chatMessages');
                    if (chatMessages) {
                        // 清空聊天框并显示欢迎信息
                        chatMessages.innerHTML = `
                            <div class="message system">
                                <strong><i class="fas fa-info-circle"></i> ${I18N.system_message || '系统消息'}</strong><br>
                                ${I18N.welcome_message || '欢迎使用 OfficeCowork！请在下方输入您的需求，系统将自动为您处理任务。'}
                            </div>
                        `;
                    }
                    
                    // 重置消息跟踪变量
                    lastMessageType = null;
                    lastMessageDiv = null;
                    lastMessageContent = null;
                    
                    // 重置JSON收集状态
                    resetJsonCollectingState();
                    
                    // 重置manager.out加载标志（如果之前正在加载，先清除并恢复自动滚动状态）
                    if (isLoadingFromManagerOut) {
                        // 如果之前正在加载，恢复自动滚动状态
                        autoScrollEnabled = savedAutoScrollStateBeforeLoading;
                        updateAutoScrollIndicator();
                    }
                    isLoadingFromManagerOut = false;
                    
                    // 清空工具调用信息显示框
                    const detailInfoMessages = document.getElementById('detailInfoMessages');
                    if (detailInfoMessages) {
                        detailInfoMessages.innerHTML = '';
                    }
                    
                    // 清理批处理队列和定时器
                    clearTimeout(batchProcessingTimer);
                    batchProcessingTimer = null;
                    messageBatchQueue = [];
                    isBatchProcessing = false;
                    batchScrollPending = false;
                    
                    // 不再自动加载manager.out内容，改为由用户手动点击加载历史按钮触发
                } else {
                    // 停止文件监测
                    stopFileMonitoring();
                    // 隐藏下拉框
                    updateAgentSelectDropdown([]);
                }
                // Update agent view button state and load history button state
                updateAgentViewButtonState();
                updateLoadHistoryButtonState();
            });
            
            socket.on('history_loaded', function(data) {
                if (data.success && data.manager_out_content) {
                    // 加载历史内容
                    loadHistoryFromManagerOut(data.manager_out_content);
                } else {
                    // 显示错误消息
                    const errorMsg = data.error || ((typeof I18N !== 'undefined' && I18N.lang === 'zh') ? '加载历史失败' : 'Failed to load history');
                    addMessage(errorMsg, 'error');
                }
            });

            socket.on('directory_created', function(data) {
                if (data.success) {
                    selectedDirectory = data.dir_name;
                    taskMode = 'selected';
                    // 将新创建的目录添加到展开列表中，使其自动展开
                    expandedDirectories.add(data.dir_name);
                    
                    // 如果用户手动点击新建工作目录按钮（不是为发送任务而创建），自动清理历史聊天记录和工具调用信息
                    if (!isCreatingDirectoryForTask) {
                        autoClearChat();
                    }
                    
                    addMessage(data.message, 'success');
                    refreshDirectories();
                    // 启动文件监测
                    startFileMonitoring();
                    // Update agent view button state
                    updateAgentViewButtonState();
                    
                    // 如果有待上传的文件，自动上传
                    if (pendingUploadFiles && pendingUploadFiles.length > 0) {
                        const filesToUpload = pendingUploadFiles;
                        pendingUploadFiles = null; // 清空待上传文件
                        // 延迟一点时间确保目录创建完成
                        setTimeout(() => {
                            quickUploadFiles(filesToUpload, selectedDirectory);
                        }, 500);
                    }
                    
                    // 只有当是因为发送任务而创建目录时，才自动发送任务
                    // 如果用户直接点击新建工作目录按钮，不应该自动发送任务
                    // 允许空消息也发送任务（pendingUserInput 可能是空字符串）
                    if (isCreatingDirectoryForTask && pendingUserInput !== null && pendingUserInput !== undefined) {
                        userInput.value = pendingUserInput;
                        // 延迟一点时间确保目录创建完成
                        setTimeout(() => {
                            sendMessage(null); // Pass null to auto-read from executionModeSelect
                        }, 500);
                        pendingUserInput = ''; // 清空待发送消息
                    }
                    // 重置标志
                    isCreatingDirectoryForTask = false;
                } else {
                    addMessage(`${I18N.create_directory_failed}: ${data.error}`, 'error');
                    pendingUserInput = ''; // 清空待发送消息
                    pendingUploadFiles = null; // 清空待上传文件
                    // 重置标志
                    isCreatingDirectoryForTask = false;
                }
            });

            socket.on('chat_cleared', function(data) {
                if (data.success) {
                    addMessage(data.message, 'success');
                } else {
                    addMessage(`${I18N.chat_cleared}: ${data.error}`, 'error');
                }
            });
        }

        // 解析选项的通用函数（识别 A. B. C. 或 - A. - B. 或 □ A. □ B. 等格式）
        // 提取为全局函数，可以在多个地方使用
        function parseOptions(queryText) {
            const lines = queryText.split('\n');
            const options = [];
            let currentOption = null;
            let optionStartIndex = -1;
            
            // 检查字符是否是方框字符（通过Unicode代码点）
            function isCheckboxChar(char) {
                if (!char) return false;
                const code = char.charCodeAt(0);
                // □ (U+25A1), ☐ (U+2610), 以及其他方框字符范围
                return (code === 0x25A1) || (code === 0x2610) || 
                       (code >= 0x25A0 && code <= 0x25AF) ||
                       (code === 0x2611) || (code === 0x2612); // ☑ ☒
            }
            
            // 匹配方框字符开头的选项：□ A. 内容 或 ☐ A. 内容
            // 匹配普通选项：A. 内容 或 - A. 内容 或 A) 内容
            // 改进：匹配包含方框字符的行，方框字符可以在任意位置（但通常在开头）
            const checkboxOptionRegex = /.*?[\u25A1\u2610\u25A0-\u25AF\u2611\u2612]\s*([A-Z])[.)]\s*(.+)$/;
            // 再匹配普通选项（不包含方框字符）
            const normalOptionRegex = /^[-•]?\s*([A-Z])[.)]\s*(.+)$/;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();
                
                // 跳过空行
                if (!trimmedLine) {
                    continue;
                }
                
                // 检查是否包含方框字符（不一定是第一个字符）
                const hasCheckbox = isCheckboxChar(trimmedLine.charAt(0)) || 
                                    trimmedLine.includes('\u25A1') || 
                                    trimmedLine.includes('\u2610') ||
                                    /[\u25A0-\u25AF\u2611\u2612]/.test(trimmedLine);
                
                // 先尝试匹配包含方框字符的选项，再匹配普通选项
                let optionMatch = null;
                if (hasCheckbox) {
                    // 尝试多种匹配方式
                    // 方式1: 标准格式 □ A. 内容
                    optionMatch = trimmedLine.match(/.*?[\u25A1\u2610\u25A0-\u25AF\u2611\u2612]\s*([A-Z])[.)]\s*(.+)$/);
                    // 方式2: 如果方式1失败，尝试更宽松的匹配
                    if (!optionMatch) {
                        optionMatch = trimmedLine.match(/.*?[\u25A1\u2610\u25A0-\u25AF\u2611\u2612].*?([A-Z])[.)]\s*(.+)$/);
                    }
                    // 方式3: 如果还是失败，尝试匹配checkboxOptionRegex
                    if (!optionMatch) {
                        optionMatch = trimmedLine.match(checkboxOptionRegex);
                    }
                }
                // 如果还是没有匹配到，尝试普通选项格式
                if (!optionMatch) {
                    optionMatch = trimmedLine.match(normalOptionRegex);
                }
                
                // 调试：如果包含方框字符但没有匹配到，打印调试信息
                if (hasCheckbox && !optionMatch) {
                    console.log(`⚠️ 包含方框字符但未匹配到选项，行内容: ${trimmedLine.substring(0, 80)}`);
                }
                
                if (optionMatch) {
                    const label = optionMatch[1];
                    const text = optionMatch[2];
                    
                    // 如果之前有选项，先保存
                    if (currentOption) {
                        options.push(currentOption);
                    }
                    if (optionStartIndex === -1) {
                        optionStartIndex = i;
                    }
                    // 移除方框字符，保留选项文本
                    // 移除行首的方框字符和空格，或者移除行中任意位置的方框字符
                    let optionText = trimmedLine;
                    // 先移除行首的方框字符
                    optionText = optionText.replace(/^[\s\u25A1\u2610\u25A0-\u25AF\u2611\u2612]+/, '');
                    // 再移除行中任意位置的方框字符（保留字母和内容）
                    optionText = optionText.replace(/[\u25A1\u2610\u25A0-\u25AF\u2611\u2612]/g, '').trim();
                    // 如果移除后格式不对，使用label和text重新构建
                    if (!optionText.match(new RegExp(`^${label}[.)]`))) {
                        optionText = `${label}. ${text}`;
                    }
                    currentOption = {
                        label: label,
                        text: text,
                        fullText: optionText, // 移除方框字符后的完整文本
                        originalText: trimmedLine, // 保留原始文本用于显示
                        startIndex: i,
                        hasCheckbox: hasCheckbox // 标记是否包含方框字符
                    };
                } else if (currentOption && trimmedLine) {
                    // 如果当前行不是新选项，但当前有选项，可能是选项的续行
                    // 检查是否是缩进的行（可能是选项的续行）
                    if (line.match(/^\s{2,}/) || line.match(/^\s*[-•]/) || isCheckboxChar(trimmedLine.charAt(0))) {
                        const cleanedLine = trimmedLine.replace(/^[\s\u25A1\u2610\u25A0-\u25AF\u2611\u2612]*/, '').trim();
                        currentOption.text += ' ' + cleanedLine;
                        currentOption.fullText += '\n' + cleanedLine;
                    } else {
                        // 如果不是缩进，可能是新内容，结束当前选项
                        options.push(currentOption);
                        currentOption = null;
                    }
                }
            }
            // 保存最后一个选项
            if (currentOption) {
                options.push(currentOption);
            }
            
            return { options: options, optionStartIndex: optionStartIndex };
        }

        // Message handling
        let lastMessageType = null;
        let lastMessageDiv = null;
        let lastMessageContent = null; // 跟踪上一个消息的内容
        
        // JSON折叠框状态跟踪
        let jsonCollectingState = {
            isCollecting: false,
            jsonContent: '',
            jsonContainer: null,
            braceCount: 0,
            toolName: null,
            waitingForJsonStart: false,  // 标记是否在等待JSON开始（遇到```json后）
            waitingForJsonEnd: false,    // 标记是否在等待JSON结束标记（```）
            contentType: 'json'          // 内容类型：'json' 或 'xml'
        };
        
        // 标记是否正在从manager.out加载历史内容
        let isLoadingFromManagerOut = false;
        
        // 批量消息处理相关变量
        let messageBatchQueue = [];
        let batchProcessingTimer = null;
        let isBatchProcessing = false;
        const BATCH_DELAY = 0; // 批量处理延迟时间(毫秒) - 改为0以实现立即处理
        const MAX_BATCH_SIZE = 1; // 最大批处理消息数量 - 改为1以实现每条消息立即处理
        let batchScrollPending = false;
        
        /**
         * 检查是否应该执行自动滚动到底部
         * @returns {boolean} 是否应该自动滚动
         * @description 智能判断自动滚动条件：
         * 1. 自动滚动功能必须启用
         * 2. 如果用户正在向上滚动且不在底部附近，则不自动滚动
         * 3. 其他情况下允许自动滚动
         */
        function shouldAutoScroll() {
            // 如果自动滚动被禁用，直接返回false
            if (!autoScrollEnabled) {
                return false;
            }
            
            // 使用统一的阈值检查是否已经接近底部
            const isNearBottom = chatMessages.scrollTop + chatMessages.clientHeight >= chatMessages.scrollHeight - SCROLL_THRESHOLD;
            
            // 如果用户正在向上滚动且不在底部附近，则不执行自动滚动
            if (isUserScrolling && scrollDirection === 'up' && !isNearBottom) {
                return false;
            }
            
            // 其他情况下，只要自动滚动启用就允许滚动
            return autoScrollEnabled;
        }
        
        // HTML escape function
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Convert URLs in text to clickable links
        function convertUrlsToLinks(text) {
            if (!text) return '';
            
            // URL正则表达式：匹配 http://, https://, 或 www. 开头的URL
            // 也匹配其他常见协议如 ftp://, mailto: 等
            const urlRegex = /(https?:\/\/[^\s<>"{}|\\^`\[\]]+|www\.[^\s<>"{}|\\^`\[\]]+|ftp:\/\/[^\s<>"{}|\\^`\[\]]+|mailto:[^\s<>"{}|\\^`\[\]]+)/gi;
            
            // 先转义HTML，防止XSS攻击
            const escapedText = escapeHtml(text);
            
            // 将URL替换为链接
            return escapedText.replace(urlRegex, function(url) {
                // 如果URL以www.开头，添加https://前缀
                let href = url;
                if (url.toLowerCase().startsWith('www.')) {
                    href = 'https://' + url;
                }
                
                // 创建链接，在新标签页中打开
                return `<a href="${escapeHtml(href)}" target="_blank" rel="noopener noreferrer">${escapeHtml(url)}</a>`;
            });
        }
        
        /**
         * 检测JSON开始（检测到{开头）
         * @param {string} message 消息内容
         * @returns {boolean} 是否是JSON开始
         */
        function detectJsonStart(message) {
            const trimmed = message.trim();
            // 检测是否以{开头（忽略前导空格）
            // 也检测是否以💬开头后跟{（处理带emoji前缀的情况）
            if (trimmed.startsWith('{')) {
                return true;
            }
            // 检测是否以💬开头，且后面包含{
            if (trimmed.startsWith('💬')) {
                // 移除💬后检查是否以{开头
                const withoutEmoji = trimmed.replace(/^💬\s*/, '').trim();
                return withoutEmoji.startsWith('{');
            }
            return false;
        }
        
        /**
         * 检测XML工具调用开始（检测到<invoke或<tool_call>）
         * @param {string} message 消息内容
         * @returns {boolean} 是否是XML工具调用开始
         */
        function detectXmlInvokeStart(message) {
            const trimmed = message.trim();
            // 检测是否包含<invoke或<tool_call>（忽略大小写，忽略前导空格）
            // 注意：/<tool_call/i 会匹配 <tool_call>、<tool_call name= 等格式
            if (/<invoke\s/i.test(trimmed) || /<tool_call/i.test(trimmed)) {
                return true;
            }
            // 检测是否以💬开头，且后面包含<invoke或<tool_call>
            // 这个检查是冗余的（因为上面已经检查了），但保留作为额外保险
            if (trimmed.startsWith('💬')) {
                const withoutEmoji = trimmed.replace(/^💬\s*/, '').trim();
                if (/<invoke\s/i.test(withoutEmoji) || /<tool_call/i.test(withoutEmoji)) {
                    return true;
                }
            }
            return false;
        }
        
        /**
         * 检测XML工具调用结束（检测到</invoke>或</tool_call>）
         * @param {string} message 消息内容
         * @returns {boolean} 是否包含XML工具调用结束标记
         */
        function detectXmlInvokeEnd(message) {
            return /<\/invoke>/i.test(message) || /<\/tool_call>/i.test(message);
        }
        
        /**
         * 计算XML标签匹配情况（用于检测<invoke>或<tool_call>是否闭合）
         * @param {string} text 文本内容
         * @returns {boolean} 是否已闭合（true表示已找到对应的结束标签）
         */
        function checkXmlInvokeClosed(text) {
            // 检测<invoke>标签
            const invokeOpenMatches = text.match(/<invoke\s[^>]*>/gi) || [];
            const invokeCloseMatches = text.match(/<\/invoke>/gi) || [];
            const invokeClosed = invokeCloseMatches.length >= invokeOpenMatches.length;
            
            // 检测<tool_call>标签
            const toolCallOpenMatches = text.match(/<tool_call[^>]*>/gi) || [];
            const toolCallCloseMatches = text.match(/<\/tool_call>/gi) || [];
            const toolCallClosed = toolCallCloseMatches.length >= toolCallOpenMatches.length;
            
            // 如果同时包含两种标签，需要都闭合才返回true
            if (invokeOpenMatches.length > 0 && toolCallOpenMatches.length > 0) {
                return invokeClosed && toolCallClosed;
            }
            // 如果只包含一种标签，检查对应标签是否闭合
            if (invokeOpenMatches.length > 0) {
                return invokeClosed;
            }
            if (toolCallOpenMatches.length > 0) {
                return toolCallClosed;
            }
            // 如果都没有标签，返回true（视为已闭合）
            return true;
        }
        
        /**
         * 计算JSON括号匹配情况
         * @param {string} text 文本内容
         * @returns {number} 括号计数（>0表示未闭合，0表示闭合）
         */
        function countJsonBraces(text) {
            let count = 0;
            let inString = false;
            let escapeNext = false;
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                
                if (escapeNext) {
                    escapeNext = false;
                    continue;
                }
                
                if (char === '\\') {
                    escapeNext = true;
                    continue;
                }
                
                if (char === '"' && !escapeNext) {
                    inString = !inString;
                    continue;
                }
                
                if (!inString) {
                    if (char === '{') {
                        count++;
                    } else if (char === '}') {
                        count--;
                    }
                }
            }
            
            return count;
        }
        
        /**
         * 从JSON内容中提取工具名称
         * @param {string} jsonText JSON文本
         * @returns {string|null} 工具名称
         */
        function extractToolName(jsonText) {
            try {
                // 尝试解析JSON（可能不完整）
                const nameMatch = jsonText.match(/"name"\s*:\s*"([^"]+)"/);
                if (nameMatch) {
                    return nameMatch[1];
                }
                
                // 尝试匹配tool字段
                const toolMatch = jsonText.match(/"tool"\s*:\s*"([^"]+)"/);
                if (toolMatch) {
                    return toolMatch[1];
                }
                
                // 尝试匹配tool_name字段
                const toolNameMatch = jsonText.match(/"tool_name"\s*:\s*"([^"]+)"/);
                if (toolNameMatch) {
                    return toolNameMatch[1];
                }
            } catch (e) {
                // 忽略解析错误
            }
            return null;
        }
        
        /**
         * 从XML内容中提取工具名称
         * @param {string} xmlText XML文本
         * @returns {string|null} 工具名称
         */
        function extractToolNameFromXml(xmlText) {
            try {
                // 优先匹配 <invoke name="tool_name"> 或 <invoke name='tool_name'>
                let nameMatch = xmlText.match(/<invoke\s+[^>]*name\s*=\s*["']([^"']+)["']/i);
                if (nameMatch) {
                    return nameMatch[1];
                }
                // 匹配 <tool_call name="tool_name"> 或 <tool_call name='tool_name'>
                nameMatch = xmlText.match(/<tool_call\s+[^>]*name\s*=\s*["']([^"']+)["']/i);
                if (nameMatch) {
                    return nameMatch[1];
                }
                // 匹配 <tool_call>tool_name> 格式（工具名称直接在标签后面）
                // 例如: <tool_call>edit_file> 或 <tool_call>tool_name>
                nameMatch = xmlText.match(/<tool_call>([^<>\s]+)>/i);
                if (nameMatch) {
                    return nameMatch[1].trim();
                }
            } catch (e) {
                // 忽略解析错误
            }
            return null;
        }
        
        /**
         * 创建JSON折叠框
         * @param {string} toolName 工具名称
         * @returns {HTMLElement} 折叠框元素
         */
        function createJsonCollapsible(toolName) {
            const container = document.createElement('div');
            container.className = 'json-collapsible collapsed';
            
            const header = document.createElement('div');
            header.className = 'json-collapsible-header';
            
            const title = document.createElement('div');
            title.className = 'json-collapsible-title';
            title.innerHTML = `<span class="json-collapsible-icon">▼</span><span>${escapeHtml(toolName || (I18N.tool_call || '工具调用'))}</span>`;
            
            header.appendChild(title);
            
            const content = document.createElement('div');
            content.className = 'json-collapsible-content';
            
            container.appendChild(header);
            container.appendChild(content);
            
            // 添加点击事件来切换折叠状态
            header.addEventListener('click', (e) => {
                e.stopPropagation(); // 防止事件冒泡到container
                container.classList.toggle('collapsed');
            });
            
            // 添加点击事件：点击绿框内容区域时，将内容显示到工具详细调用框
            content.addEventListener('click', (e) => {
                e.stopPropagation(); // 防止事件冒泡
                
                // 获取绿框中的内容
                const contentText = content.textContent || content.innerText || '';
                
                // 获取工具详细调用框
                const detailInfoMessages = document.getElementById('detailInfoMessages');
                if (detailInfoMessages) {
                    // 先清空工具详细调用框的内容
                    detailInfoMessages.innerHTML = '';
                    
                    // 将绿框的内容显示到工具详细调用框
                    if (contentText.trim()) {
                        const messageDiv = document.createElement('div');
                        messageDiv.className = 'detail-info-message';
                        messageDiv.textContent = contentText;
                        detailInfoMessages.appendChild(messageDiv);
                        
                        // 滚动到底部
                        detailInfoMessages.scrollTop = detailInfoMessages.scrollHeight;
                    }
                }
            });
            
            // 在container上添加点击事件，用于点击绿框其他区域时也显示内容
            container.addEventListener('click', (e) => {
                // 如果点击的是header，不处理（header有自己的折叠/展开功能）
                if (e.target.closest('.json-collapsible-header')) {
                    return;
                }
                // 如果点击的是content，不处理（content有自己的点击事件）
                if (e.target.closest('.json-collapsible-content')) {
                    return;
                }
                
                // 点击绿框的其他区域（如边框），也显示内容到工具详细调用框
                const contentText = content.textContent || content.innerText || '';
                const detailInfoMessages = document.getElementById('detailInfoMessages');
                if (detailInfoMessages && contentText.trim()) {
                    detailInfoMessages.innerHTML = '';
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'detail-info-message';
                    messageDiv.textContent = contentText;
                    detailInfoMessages.appendChild(messageDiv);
                    detailInfoMessages.scrollTop = detailInfoMessages.scrollHeight;
                }
            });
            
            return container;
        }
        
        /**
         * 重置JSON收集状态
         */
        function resetJsonCollectingState() {
            jsonCollectingState.isCollecting = false;
            jsonCollectingState.jsonContent = '';
            jsonCollectingState.jsonContainer = null;
            jsonCollectingState.braceCount = 0;
            jsonCollectingState.toolName = null;
            jsonCollectingState.waitingForJsonStart = false;
            jsonCollectingState.waitingForJsonEnd = false;
            jsonCollectingState.contentType = 'json';
        }
        
        /**
         * 批量处理消息队列
         * @description 将队列中的所有消息一次性添加到DOM，然后执行一次滚动
         */
        function processBatchMessages() {
            if (messageBatchQueue.length === 0) {
                return;
            }
            
            isBatchProcessing = true;
            
            // 处理队列中的所有消息（使用addMessageImmediate以确保JSON检测正常工作）
            for (const messageData of messageBatchQueue) {
                const { message, type, isUpdate } = messageData;
                addMessageImmediate(message, type, isUpdate || false);
            }
            
            // 清空队列
            messageBatchQueue = [];
            isBatchProcessing = false;
            
            // 批量处理完成后执行一次滚动
            const shouldScroll = shouldAutoScroll();
            if (shouldScroll && batchScrollPending) {
                // 使用requestAnimationFrame确保DOM更新完成后再滚动
                requestAnimationFrame(() => {
                    throttledAutoScroll(true);
                    batchScrollPending = false;
                });
            } else if (!shouldScroll && batchScrollPending) {
                // 如果不能自动滚动，显示新消息指示器
                // showNewMessageIndicator(); // 已禁用
                batchScrollPending = false;
            }
        }
        
        /**
         * 调度批量消息处理
         * @description 设置定时器来延迟处理消息，如果队列满了则立即处理
         */
        function scheduleBatchProcessing() {
            // 如果队列已满，立即处理
            if (messageBatchQueue.length >= MAX_BATCH_SIZE) {
                clearTimeout(batchProcessingTimer);
                processBatchMessages();
                return;
            }
            
            // 如果延迟为0，使用requestAnimationFrame立即处理，确保DOM更新后滚动
            if (BATCH_DELAY === 0) {
                if (batchProcessingTimer) {
                    clearTimeout(batchProcessingTimer);
                }
                // 使用requestAnimationFrame确保在下一帧立即处理
                requestAnimationFrame(() => {
                    processBatchMessages();
                    batchProcessingTimer = null;
                });
                return;
            }
            
            // 否则设置延迟处理
            if (batchProcessingTimer) {
                clearTimeout(batchProcessingTimer);
            }
            
            batchProcessingTimer = setTimeout(() => {
                processBatchMessages();
                batchProcessingTimer = null;
            }, BATCH_DELAY);
        }
        
        function addMessage(message, type = 'info', isUpdate = false) {
            const trimmedMessage = message.trim();
            const originalMessage = message; // 保存原始消息用于JSON检测
            
            // 如果是更新类型的消息（进度条更新），立即处理并更新最后一行
            if (isUpdate) {
                addMessageImmediate(message, type, isUpdate);
                return;
            }
            
            // 对于JSON标记相关的消息，需要先让JSON检测逻辑处理，但不显示
            // 检查是否是等待JSON结束或开始的状态
            if ((jsonCollectingState.waitingForJsonEnd || jsonCollectingState.waitingForJsonStart) && 
                (trimmedMessage === '```' || trimmedMessage === '```json')) {
                // 先让JSON检测逻辑处理原始消息（用于JSON状态管理）
                addMessageImmediate(originalMessage, type, false);
                return; // 不显示这些标记
            }
            
            // Special filtering: hide lines containing specific content (only if entire message is just the marker)
            // 对于单独的标记，也需要让JSON检测逻辑处理（用于开始JSON收集）
            if (trimmedMessage === '```' || trimmedMessage === '```xml' || trimmedMessage === '```json') {
                // 让JSON检测逻辑处理（如果是```json或```，可能用于开始JSON收集）
                if (trimmedMessage === '```json' || trimmedMessage === '```') {
                    addMessageImmediate(originalMessage, type, false);
                }
                return; // Don't display these lines
            }
            
            // Filter out ```json and ``` markers from message content (keep the rest)
            // 简化逻辑：只替换 ```json 和 ```
            let displayMessage = message;
            // 先替换```json
            displayMessage = displayMessage.replace(/```json/g, '');
            // 再替换```
            displayMessage = displayMessage.replace(/```/g, '');
            // 如果过滤后为空行（trim后为空），不显示
            if (!displayMessage.trim()) {
                return;
            }
            
            // Check if message contains warning and treat it as normal text
            const messageLower = displayMessage.toLowerCase();
            if (type === 'info' && (messageLower.includes('warning') || messageLower.includes('userwarning') || messageLower.includes('warnings.warn') || displayMessage.includes('⚠️') || displayMessage.includes('W: '))) {
                type = 'normal'; // Use normal style for warning messages
            }
            
            // 对于用户消息或重要消息，立即处理不进入批处理队列
            if (type === 'user' || type === 'system' || isBatchProcessing) {
                addMessageImmediate(displayMessage, type, false);
                return;
            }
            
            // 将消息添加到批处理队列（使用过滤后的消息）
            messageBatchQueue.push({ message: displayMessage, type, isUpdate: false });
            
            // 标记需要滚动（如果满足条件）
            if (shouldAutoScroll()) {
                batchScrollPending = true;
            }
            
            // 调度批量处理
            scheduleBatchProcessing();
        }
        
        /**
         * 过滤JSON内容中的```标记
         * @param {string} jsonContent JSON内容
         * @returns {string} 过滤后的JSON内容
         * @description 过滤掉```json和```标记，用于在显示JSON内容前清理
         */
        function filterJsonMarkers(jsonContent) {
            if (!jsonContent) {
                return jsonContent;
            }
            let filtered = jsonContent;
            filtered = filtered.replace(/```json/g, '');
            filtered = filtered.replace(/```/g, '');
            // 移除💬 emoji前缀
            filtered = filtered.replace(/^💬\s*/g, '');
            filtered = filtered.replace(/\s*💬\s*/g, '');
            
            // 清理多余的换行，使其与终端打印一致
            // 移除开头的空行和空白
            filtered = filtered.replace(/^\s*\n+/, '');
            // 移除结尾的空行和空白
            filtered = filtered.replace(/\n+\s*$/, '');
            
            // 将连续的多个换行（3个或更多）替换为单个换行
            // 这样可以移除多余的空行，但保留JSON格式中的正常换行
            filtered = filtered.replace(/\n{3,}/g, '\n');
            
            // 清理行尾空白（但保留行首空白，用于JSON缩进）
            const lines = filtered.split('\n');
            const cleanedLines = lines.map(line => {
                // 如果行是空的或只包含空白，返回空字符串
                if (!line.trim()) {
                    return '';
                }
                // 保留行首空白（用于JSON缩进），但移除行尾空白
                return line.replace(/\s+$/, '');
            });
            
            // 重新组合，移除连续的空行（最多保留一个空行）
            filtered = cleanedLines.join('\n').replace(/\n\n\n+/g, '\n\n');
            
            // 最后清理：移除开头和结尾的空行
            filtered = filtered.replace(/^\n+/, '').replace(/\n+$/, '');
            
            return filtered;
        }
        
        /**
         * 更新细节窗口显示JSON内容
         * @param {string} jsonContent JSON内容
         * @description 当日志打印窗口处于绿框打印状态（JSON收集）时，将JSON内容显示到细节窗口
         */
        function updateDetailInfoWithJson(jsonContent) {
            // 如果正在从manager.out加载历史内容，跳过工具调用详细框的更新
            if (isLoadingFromManagerOut) {
                return;
            }
            
            const detailInfoMessages = document.getElementById('detailInfoMessages');
            if (!detailInfoMessages) {
                return;
            }
            
            // 如果JSON内容为空，不添加
            if (!jsonContent || !jsonContent.trim()) {
                return;
            }
            
            // 过滤掉 ```json 和 ``` 标记（在显示到细节窗口前）
            const filteredContent = filterJsonMarkers(jsonContent);
            
            // 获取最后一个消息元素
            let lastDetailMessage = detailInfoMessages.lastElementChild;
            
            // 如果存在最后一个消息元素且是detail-info-message，更新内容
            if (lastDetailMessage && lastDetailMessage.classList.contains('detail-info-message')) {
                lastDetailMessage.textContent = filteredContent;
            } else {
                // 创建新的消息元素
                const messageDiv = document.createElement('div');
                messageDiv.className = 'detail-info-message';
                messageDiv.textContent = filteredContent;
                detailInfoMessages.appendChild(messageDiv);
            }
            
            // 自动滚动到底部（根据鼠标位置决定）
            if (detailInfoAutoScrollEnabled) {
                detailInfoMessages.scrollTop = detailInfoMessages.scrollHeight;
            }
        }

        /**
         * 立即添加消息（不使用批处理）
         * @param {string} message 消息内容
         * @param {string} type 消息类型
         * @description 用于处理用户消息、系统消息或批处理过程中的消息
         */
        function addMessageImmediate(message, type = 'info', isUpdate = false) {
            const shouldScroll = shouldAutoScroll();
            
            // 🔧 Fix: 全局检测💬标志，无论当前处于什么状态，都强制结束工具调用框
            // 检测消息中是否包含💬（无论位置）
            if (message.includes('💬')) {
                // 如果当前正在收集JSON/XML或等待JSON结束/开始，强制结束
                // 注意：即使消息中包含新的工具调用标记，也应该先结束之前的收集，
                // 然后让后续的检测逻辑（第6254行）来处理新工具调用的开始
                if (jsonCollectingState.isCollecting || 
                    jsonCollectingState.waitingForJsonEnd || 
                    jsonCollectingState.waitingForJsonStart) {
                    // 完成收集，重置状态
                    resetJsonCollectingState();
                    lastMessageType = null;
                    lastMessageDiv = null;
                    lastMessageContent = null;
                    // 继续处理当前消息（不会return，继续执行下面的逻辑）
                }
            }
            
            // 如果是更新类型的消息（进度条更新），更新最后一行而不是添加新行
            if (isUpdate) {
                // 优先更新最后一条 info 类型的消息
                if (lastMessageDiv && lastMessageDiv.parentNode === chatMessages &&
                    lastMessageType === 'info' &&
                    !lastMessageDiv.classList.contains('json-collapsible') &&
                    !jsonCollectingState.isCollecting &&
                    !jsonCollectingState.waitingForJsonEnd &&
                    !jsonCollectingState.waitingForJsonStart) {
                    // 更新最后一条消息的内容
                    const textSpan = lastMessageDiv.querySelector('.message-text');
                    if (textSpan) {
                        // 直接替换内容，不添加换行
                        textSpan.innerHTML = convertUrlsToLinks(message);
                    } else {
                        lastMessageDiv.innerHTML = convertUrlsToLinks(message);
                    }
                    // 更新lastMessageContent
                    lastMessageContent = message;
                    // 不滚动，保持当前位置
                    return;
                } else if (!lastMessageDiv || lastMessageType !== 'info') {
                    // 如果没有最后一条消息或最后一条不是 info 类型，创建新的消息
                    // 但标记为更新类型，这样下次更新时可以更新这条消息
                    // 继续执行下面的逻辑创建新消息
                } else {
                    // 其他情况，不更新，直接返回
                    return;
                }
            }
            
            // 过滤掉 ```json 和 ``` 标记（在实际显示前）
            let filteredMessage = message;
            filteredMessage = filteredMessage.replace(/```json/g, '');
            filteredMessage = filteredMessage.replace(/```/g, '');
            
            // 如果过滤后为空行（trim后为空），不显示（但需要先让JSON检测逻辑处理）
            // 注意：空行检查在JSON检测之后进行，因为JSON检测可能需要这些标记
            // 如果正在收集JSON或XML，继续追加内容
            if (jsonCollectingState.isCollecting) {
                // 🔧 Fix: 如果消息包含💬（无论位置），强制结束收集
                // 由于全局检测已经在函数开始处处理了💬，这里作为双重检查
                // 如果全局检测没有捕获到（理论上不应该发生），这里也能确保结束
                if (message.includes('💬')) {
                    // 完成收集（不包含💬消息）
                    resetJsonCollectingState();
                    lastMessageType = null;
                    lastMessageDiv = null;
                    lastMessageContent = null;
                    
                    // 将💬消息作为普通消息显示（会继续执行下面的逻辑）
                    // 不return，继续处理当前消息
                } else {
                    // 对于XML类型，先检查当前内容是否已经闭合
                    // 如果已经闭合，不应该追加新消息，而应该重置状态并让新消息正常显示
                    if (jsonCollectingState.contentType === 'xml') {
                        const wasClosed = checkXmlInvokeClosed(jsonCollectingState.jsonContent);
                        if (wasClosed) {
                            // XML已经闭合（在之前的消息中），不应该追加当前消息
                            // 更新折叠框内容
                            if (jsonCollectingState.jsonContainer) {
                                const contentDiv = jsonCollectingState.jsonContainer.querySelector('.json-collapsible-content');
                                if (contentDiv) {
                                    contentDiv.textContent = jsonCollectingState.jsonContent;
                                }
                                
                                // 如果还没有提取工具名称，尝试提取
                                if (!jsonCollectingState.toolName) {
                                    const toolName = extractToolNameFromXml(jsonCollectingState.jsonContent);
                                    if (toolName) {
                                        jsonCollectingState.toolName = toolName;
                                        const titleSpan = jsonCollectingState.jsonContainer.querySelector('.json-collapsible-title span:last-child');
                                        if (titleSpan) {
                                            titleSpan.textContent = toolName;
                                        }
                                    }
                                }
                            }
                            
                            // 更新细节窗口显示内容
                            updateDetailInfoWithJson(jsonCollectingState.jsonContent);
                            
                            // XML已闭合，完成收集并重置状态
                            resetJsonCollectingState();
                            lastMessageType = null;
                            lastMessageDiv = null;
                            lastMessageContent = null;
                            
                            if (shouldScroll) {
                                throttledAutoScroll(true);
                            }
                            // 不return，让当前消息继续执行下面的逻辑正常显示
                            // 这样XML闭合后的搜索结果就能正常显示了
                        } else {
                            // XML未闭合，追加当前消息
                            // 智能添加换行：如果消息本身已经以换行结尾，不再添加
                            // 如果消息不以换行结尾，添加换行
                            if (message.endsWith('\n')) {
                                jsonCollectingState.jsonContent += message;
                            } else {
                                jsonCollectingState.jsonContent += message + '\n';
                            }
                            
                            // 检查追加后是否闭合
                            const isClosed = checkXmlInvokeClosed(jsonCollectingState.jsonContent);
                            if (isClosed) {
                                // XML结构完成
                                jsonCollectingState.isCollecting = false;
                            }
                            
                            // 更新折叠框内容
                            if (jsonCollectingState.jsonContainer) {
                                const contentDiv = jsonCollectingState.jsonContainer.querySelector('.json-collapsible-content');
                                if (contentDiv) {
                                    contentDiv.textContent = jsonCollectingState.jsonContent;
                                }
                                
                                // 如果还没有提取工具名称，尝试提取
                                if (!jsonCollectingState.toolName) {
                                    const toolName = extractToolNameFromXml(jsonCollectingState.jsonContent);
                                    if (toolName) {
                                        jsonCollectingState.toolName = toolName;
                                        const titleSpan = jsonCollectingState.jsonContainer.querySelector('.json-collapsible-title span:last-child');
                                        if (titleSpan) {
                                            titleSpan.textContent = toolName;
                                        }
                                    }
                                }
                            }
                            
                            // 更新细节窗口显示内容
                            updateDetailInfoWithJson(jsonCollectingState.jsonContent);
                            
                            // 检查是否结束
                            if (!jsonCollectingState.isCollecting) {
                                // XML已闭合，完成收集
                                resetJsonCollectingState();
                                lastMessageType = null;
                                lastMessageDiv = null;
                                lastMessageContent = null;
                            }
                            
                            if (shouldScroll) {
                                throttledAutoScroll(true);
                            } else {
                                // showNewMessageIndicator(); // 已禁用
                            }
                            return;
                        }
                    } else {
                        // JSON或其他类型，继续原有逻辑
                        // 智能添加换行：如果消息本身已经以换行结尾，不再添加
                        // 如果消息不以换行结尾，添加换行
                        if (message.endsWith('\n')) {
                            jsonCollectingState.jsonContent += message;
                        } else {
                            jsonCollectingState.jsonContent += message + '\n';
                        }
                        
                        // 根据内容类型处理
                        if (jsonCollectingState.contentType === 'json') {
                            jsonCollectingState.braceCount = countJsonBraces(jsonCollectingState.jsonContent);
                        }
                        
                        // 更新折叠框内容
                        if (jsonCollectingState.jsonContainer) {
                            const contentDiv = jsonCollectingState.jsonContainer.querySelector('.json-collapsible-content');
                            if (contentDiv) {
                                if (jsonCollectingState.contentType === 'json') {
                                    contentDiv.textContent = filterJsonMarkers(jsonCollectingState.jsonContent);
                                } else {
                                    contentDiv.textContent = jsonCollectingState.jsonContent;
                                }
                            }
                            
                            // 如果还没有提取工具名称，尝试提取
                            if (!jsonCollectingState.toolName) {
                                let toolName = null;
                                if (jsonCollectingState.contentType === 'json') {
                                    toolName = extractToolName(jsonCollectingState.jsonContent);
                                } else if (jsonCollectingState.contentType === 'xml') {
                                    toolName = extractToolNameFromXml(jsonCollectingState.jsonContent);
                                }
                                if (toolName) {
                                    jsonCollectingState.toolName = toolName;
                                    const titleSpan = jsonCollectingState.jsonContainer.querySelector('.json-collapsible-title span:last-child');
                                    if (titleSpan) {
                                        titleSpan.textContent = toolName;
                                    }
                                }
                            }
                        }
                        
                        // 更新细节窗口显示内容
                        updateDetailInfoWithJson(jsonCollectingState.jsonContent);
                        
                        // 检查是否结束
                        if (jsonCollectingState.contentType === 'json') {
                            if (jsonCollectingState.braceCount === 0) {
                                // JSON结构完成，但可能还有结束标记```，等待下一个消息
                                jsonCollectingState.isCollecting = false;
                                jsonCollectingState.waitingForJsonEnd = true;
                                // 不重置状态，等待下一个消息
                            }
                        }
                        
                        if (shouldScroll) {
                            throttledAutoScroll(true);
                        } else {
                            // showNewMessageIndicator(); // 已禁用
                        }
                        return;
                    }
                }
            }
            
            // JSON检测和处理逻辑
            // 如果正在等待JSON结束标记（```）
            if (jsonCollectingState.waitingForJsonEnd && type === 'info') {
                // 强制检测：如果消息包含💬（新工具调用开始），强制结束之前的JSON收集
                // 注意：如果💬在消息开头，会在detectJsonStart中识别为新JSON，这里结束之前的收集
                if (message.includes('💬')) {
                    // 完成收集，重置状态（不包含💬消息）
                    resetJsonCollectingState();
                    lastMessageType = null;
                    lastMessageDiv = null;
                    lastMessageContent = null;
                    // 继续处理当前消息（不会return，继续执行下面的逻辑）
                } else {
                    const trimmedMessage = message.trim();
                    if (trimmedMessage === '```') {
                        // 将结束标记包含到JSON内容中
                        // 智能添加换行：如果消息本身已经以换行结尾，不再添加
                        if (message.endsWith('\n')) {
                            jsonCollectingState.jsonContent += message;
                        } else {
                            jsonCollectingState.jsonContent += message + '\n';
                        }
                        
                        // 更新折叠框内容
                        if (jsonCollectingState.jsonContainer) {
                            const contentDiv = jsonCollectingState.jsonContainer.querySelector('.json-collapsible-content');
                            if (contentDiv) {
                                contentDiv.textContent = filterJsonMarkers(jsonCollectingState.jsonContent);
                            }
                        }
                        
                        // 更新细节窗口显示完整的JSON内容
                        updateDetailInfoWithJson(jsonCollectingState.jsonContent);
                        
                        // 完成收集，重置状态
                        resetJsonCollectingState();
                        lastMessageType = null;
                        lastMessageDiv = null;
                        lastMessageContent = null;
                        
                        if (shouldScroll) {
                            throttledAutoScroll(true);
                        } else {
                            // showNewMessageIndicator(); // 已禁用
                        }
                        return;
                    } else {
                        // 如果不是结束标记，完成收集（不包含结束标记）
                        // 确保清空lastMessageDiv的引用，防止后续消息被追加到JSON容器
                        resetJsonCollectingState();
                        lastMessageType = null;
                        lastMessageDiv = null;
                        lastMessageContent = null;
                        // 继续处理当前消息（不会return，继续执行下面的逻辑）
                    }
                }
            }
            
            // 如果正在等待JSON开始（之前遇到了```json），检查当前消息是否是JSON或XML
            if (jsonCollectingState.waitingForJsonStart && type === 'info') {
                // 优先检测XML（因为XML检测更具体）
                if (detectXmlInvokeStart(message)) {
                    // 开始收集XML
                    jsonCollectingState.isCollecting = true;
                    jsonCollectingState.contentType = 'xml';
                    jsonCollectingState.waitingForJsonStart = false;
                    // 智能添加换行：如果消息本身已经以换行结尾，不再添加
                    if (message.endsWith('\n')) {
                        jsonCollectingState.jsonContent = jsonCollectingState.jsonContent + message;
                    } else {
                        jsonCollectingState.jsonContent = jsonCollectingState.jsonContent + message + '\n';
                    }
                    
                    // 尝试提取工具名称
                    const toolName = extractToolNameFromXml(jsonCollectingState.jsonContent);
                    jsonCollectingState.toolName = toolName;
                    
                    // 更新折叠框内容
                    if (jsonCollectingState.jsonContainer) {
                        const contentDiv = jsonCollectingState.jsonContainer.querySelector('.json-collapsible-content');
                        if (contentDiv) {
                            contentDiv.textContent = jsonCollectingState.jsonContent;
                        }
                        // 更新标题
                        if (toolName) {
                            const titleSpan = jsonCollectingState.jsonContainer.querySelector('.json-collapsible-title span:last-child');
                            if (titleSpan) {
                                titleSpan.textContent = toolName;
                            }
                        }
                    }
                    
                    // 更新细节窗口显示XML内容
                    updateDetailInfoWithJson(jsonCollectingState.jsonContent);
                    
                    // 检查XML是否已闭合
                    const isClosed = checkXmlInvokeClosed(jsonCollectingState.jsonContent);
                    if (isClosed) {
                        // XML结构完成
                        jsonCollectingState.isCollecting = false;
                        lastMessageType = null;
                        lastMessageDiv = null;
                        lastMessageContent = null;
                    } else {
                        lastMessageType = null;
                        lastMessageDiv = jsonCollectingState.jsonContainer;
                        lastMessageContent = null;
                    }
                    
                    if (shouldScroll) {
                        throttledAutoScroll(true);
                    } else {
                        // showNewMessageIndicator(); // 已禁用
                    }
                    return;
                } else if (detectJsonStart(message)) {
                    // 开始收集JSON
                    jsonCollectingState.isCollecting = true;
                    jsonCollectingState.contentType = 'json';
                    jsonCollectingState.waitingForJsonStart = false;
                    // 智能添加换行：如果消息本身已经以换行结尾，不再添加
                    if (message.endsWith('\n')) {
                        jsonCollectingState.jsonContent = jsonCollectingState.jsonContent + message;
                    } else {
                        jsonCollectingState.jsonContent = jsonCollectingState.jsonContent + message + '\n';
                    }
                    jsonCollectingState.braceCount = countJsonBraces(jsonCollectingState.jsonContent);
                    
                    // 尝试提取工具名称
                    const toolName = extractToolName(jsonCollectingState.jsonContent);
                    jsonCollectingState.toolName = toolName;
                    
                    // 更新折叠框内容
                    if (jsonCollectingState.jsonContainer) {
                        const contentDiv = jsonCollectingState.jsonContainer.querySelector('.json-collapsible-content');
                        if (contentDiv) {
                            contentDiv.textContent = filterJsonMarkers(jsonCollectingState.jsonContent);
                        }
                        // 更新标题
                        if (toolName) {
                            const titleSpan = jsonCollectingState.jsonContainer.querySelector('.json-collapsible-title span:last-child');
                            if (titleSpan) {
                                titleSpan.textContent = toolName;
                            }
                        }
                    }
                    
                    // 更新细节窗口显示JSON内容
                    updateDetailInfoWithJson(jsonCollectingState.jsonContent);
                    
                    // 如果JSON已经完成（单行完整JSON），检查是否需要等待结束标记
                    if (jsonCollectingState.braceCount === 0) {
                        // JSON结构完成，但可能还有结束标记```，等待下一个消息
                        jsonCollectingState.isCollecting = false;
                        jsonCollectingState.waitingForJsonEnd = true;
                        lastMessageType = null;
                        lastMessageDiv = jsonCollectingState.jsonContainer;
                        lastMessageContent = null;
                    } else {
                        lastMessageType = null;
                        lastMessageDiv = jsonCollectingState.jsonContainer;
                        lastMessageContent = null;
                    }
                    
                    if (shouldScroll) {
                        throttledAutoScroll(true);
                    } else {
                        // showNewMessageIndicator(); // 已禁用
                    }
                    return;
                } else {
                    // 如果不是JSON或XML开始，取消等待状态，移除临时折叠框，将```json作为普通消息显示
                    const jsonMarker = jsonCollectingState.jsonContent.trim();
                    if (jsonCollectingState.jsonContainer && jsonCollectingState.jsonContainer.parentNode === chatMessages) {
                        jsonCollectingState.jsonContainer.remove();
                    }
                    resetJsonCollectingState();
                    // 将```json作为普通消息显示（过滤掉标记）
                    let filteredMarker = jsonMarker;
                    filteredMarker = filteredMarker.replace(/```json/g, '');
                    filteredMarker = filteredMarker.replace(/```/g, '');
                    // 如果过滤后为空行，不显示
                    if (!filteredMarker.trim()) {
                        // 继续处理当前消息（不会return，继续执行下面的逻辑）
                        return;
                    }
                    const messageDiv = document.createElement('div');
                    messageDiv.className = `message ${type}`;
                    const textSpan = document.createElement('span');
                    textSpan.className = 'message-text';
                    textSpan.innerHTML = convertUrlsToLinks(filteredMarker);
                    messageDiv.appendChild(textSpan);
                    chatMessages.appendChild(messageDiv);
                    lastMessageType = type;
                    lastMessageDiv = messageDiv;
                    lastMessageContent = filteredMarker;
                    // 继续处理当前消息（不会return，继续执行下面的逻辑）
                }
            }
            
            // 检测```json标记（单独的消息）
            if (type === 'info') {
                const trimmedMessage = message.trim();
                if (trimmedMessage === '```json' || trimmedMessage === '```') {
                    // 开始等待JSON开始
                    jsonCollectingState.waitingForJsonStart = true;
                    // 智能添加换行：如果消息本身已经以换行结尾，不再添加
                    if (message.endsWith('\n')) {
                        jsonCollectingState.jsonContent = message;
                    } else {
                        jsonCollectingState.jsonContent = message + '\n';
                    }
                    
                    // 创建一个临时的折叠框（但先不显示内容，等待JSON开始）
                    jsonCollectingState.jsonContainer = createJsonCollapsible(I18N.tool_call || '工具调用');
                    const contentDiv = jsonCollectingState.jsonContainer.querySelector('.json-collapsible-content');
                    contentDiv.textContent = filterJsonMarkers(jsonCollectingState.jsonContent);
                    
                    chatMessages.appendChild(jsonCollectingState.jsonContainer);
                    lastMessageType = null;
                    lastMessageDiv = jsonCollectingState.jsonContainer;
                    lastMessageContent = null;
                    
                    if (shouldScroll) {
                        throttledAutoScroll(true);
                    } else {
                        // showNewMessageIndicator(); // 已禁用
                    }
                    return;
                }
            }
            
            // 检测XML工具调用开始（检测到<invoke）
            if (type === 'info' && detectXmlInvokeStart(message)) {
                // 开始收集XML
                jsonCollectingState.isCollecting = true;
                jsonCollectingState.contentType = 'xml';
                // 智能添加换行：如果消息本身已经以换行结尾，不再添加
                if (message.endsWith('\n')) {
                    jsonCollectingState.jsonContent = message;
                } else {
                    jsonCollectingState.jsonContent = message + '\n';
                }
                
                // 尝试提取工具名称
                const toolName = extractToolNameFromXml(jsonCollectingState.jsonContent);
                jsonCollectingState.toolName = toolName;
                
                // 创建折叠框
                jsonCollectingState.jsonContainer = createJsonCollapsible(toolName || (I18N.tool_call || '工具调用'));
                const contentDiv = jsonCollectingState.jsonContainer.querySelector('.json-collapsible-content');
                contentDiv.textContent = jsonCollectingState.jsonContent;
                
                // 添加到聊天窗口
                chatMessages.appendChild(jsonCollectingState.jsonContainer);
                
                // 更新细节窗口显示XML内容
                updateDetailInfoWithJson(jsonCollectingState.jsonContent);
                
                // 检查XML是否已闭合
                const isClosed = checkXmlInvokeClosed(jsonCollectingState.jsonContent);
                if (isClosed) {
                    // XML结构完成
                    jsonCollectingState.isCollecting = false;
                    // 不要将lastMessageDiv设置为容器，防止后续消息被追加
                    lastMessageType = null;
                    lastMessageDiv = null;
                    lastMessageContent = null;
                } else {
                    // 更新lastMessage引用为容器
                    lastMessageType = null;
                    lastMessageDiv = jsonCollectingState.jsonContainer;
                    lastMessageContent = null;
                }
                
                if (shouldScroll) {
                    throttledAutoScroll(true);
                } else {
                    // showNewMessageIndicator(); // 已禁用
                }
                return;
            }
            
            // 检测JSON开始（直接以{开头，没有```json标记）
            if (type === 'info' && detectJsonStart(message)) {
                // 开始收集JSON
                jsonCollectingState.isCollecting = true;
                jsonCollectingState.contentType = 'json';
                // 智能添加换行：如果消息本身已经以换行结尾，不再添加
                if (message.endsWith('\n')) {
                    jsonCollectingState.jsonContent = message;
                } else {
                    jsonCollectingState.jsonContent = message + '\n';
                }
                jsonCollectingState.braceCount = countJsonBraces(jsonCollectingState.jsonContent);
                
                // 尝试提取工具名称
                const toolName = extractToolName(jsonCollectingState.jsonContent);
                jsonCollectingState.toolName = toolName;
                
                // 创建JSON折叠框
                jsonCollectingState.jsonContainer = createJsonCollapsible(toolName || (I18N.tool_call || '工具调用'));
                const contentDiv = jsonCollectingState.jsonContainer.querySelector('.json-collapsible-content');
                contentDiv.textContent = filterJsonMarkers(jsonCollectingState.jsonContent);
                
                // 添加到聊天窗口
                chatMessages.appendChild(jsonCollectingState.jsonContainer);
                
                // 更新细节窗口显示JSON内容
                updateDetailInfoWithJson(jsonCollectingState.jsonContent);
                
                // 如果JSON已经完成（单行完整JSON），检查是否需要等待结束标记
                if (jsonCollectingState.braceCount === 0) {
                    // JSON结构完成，但可能还有结束标记```，等待下一个消息
                    jsonCollectingState.isCollecting = false;
                    jsonCollectingState.waitingForJsonEnd = true;
                    // 不要将lastMessageDiv设置为JSON容器，防止后续消息被追加
                    lastMessageType = null;
                    lastMessageDiv = null;
                    lastMessageContent = null;
                } else {
                    // 更新lastMessage引用为JSON容器
                    lastMessageType = null;
                    lastMessageDiv = jsonCollectingState.jsonContainer;
                    lastMessageContent = null;
                }
                
                if (shouldScroll) {
                    throttledAutoScroll(true);
                } else {
                    // showNewMessageIndicator(); // 已禁用
                }
                return;
            }
            
            // 对于info类型的消息，总是尝试追加到上一个info消息框中
            // 也包括normal类型的消息，如果它们是警告信息的话
            // 但确保不会追加到JSON/XML折叠框中
            // 注意：如果当前消息包含工具调用开始标记，不应该追加，应该创建新的工具调用框
            if ((type === 'info' || (type === 'normal' && (message.includes('⚠️') || message.includes('W: ')))) &&
                !detectXmlInvokeStart(message) && // 如果消息包含工具调用标记，不追加
                lastMessageType === 'info' && lastMessageDiv && lastMessageDiv.parentNode === chatMessages &&
                !lastMessageDiv.classList.contains('json-collapsible') &&
                !jsonCollectingState.isCollecting &&
                !jsonCollectingState.waitingForJsonEnd) {
                // 如果过滤后为空行，不显示
                if (!filteredMessage.trim()) {
                    return;
                }
                // 追加到现有的info消息框（使用过滤后的消息）
                const textSpan = lastMessageDiv.querySelector('.message-text');
                if (textSpan) {
                    textSpan.innerHTML += '<br>' + convertUrlsToLinks(filteredMessage);
                } else {
                    // If no text span found, fallback to original method but with escaping
                    lastMessageDiv.innerHTML += '<br>' + convertUrlsToLinks(filteredMessage);
                }
                // 更新lastMessageContent（使用过滤后的消息）
                if (lastMessageContent) {
                    lastMessageContent += '\n' + filteredMessage;
                } else {
                    lastMessageContent = filteredMessage;
                }
                if (shouldScroll) {
                    // 使用节流的自动滚动函数，减少跳动
                    throttledAutoScroll(true);
                } else {
                    // If can't auto-scroll, show new message indicator
                    // showNewMessageIndicator(); // 已禁用
                }
                return;
            }
            
            // 对于其他类型的消息，保持原有逻辑
            if (['error', 'success'].includes(type) && lastMessageType === type && lastMessageDiv) {
                // 如果过滤后为空行，不显示
                if (!filteredMessage.trim()) {
                    return;
                }
                // For consecutive messages of the same type, safely add content（使用过滤后的消息）
                const textSpan = lastMessageDiv.querySelector('.message-text');
                if (textSpan) {
                    textSpan.innerHTML += '<br>' + convertUrlsToLinks(filteredMessage);
                } else {
                    // If no text span found, fallback to original method but with escaping
                    lastMessageDiv.innerHTML += '<br>' + convertUrlsToLinks(filteredMessage);
                }
                // 更新lastMessageContent（使用过滤后的消息）
                if (lastMessageContent) {
                    lastMessageContent += '\n' + filteredMessage;
                } else {
                    lastMessageContent = filteredMessage;
                }
                if (shouldScroll) {
                    // 使用节流的自动滚动函数，减少跳动
                    throttledAutoScroll(true);
                } else {
                    // If can't auto-scroll, show new message indicator
                    // showNewMessageIndicator(); // 已禁用
                }
                return;
            }
            
            // 如果过滤后为空行，不显示
            if (!filteredMessage.trim()) {
                return;
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            // 对于info类型的消息，检测是否包含方框字符和选项
            // 如果包含，将方框字符替换为checkbox
            if (type === 'info') {
                const parseResult = parseOptions(filteredMessage);
                const options = parseResult.options;
                const optionStartIndex = parseResult.optionStartIndex;
                
                // 检查是否有包含方框字符的选项
                const hasCheckboxOptions = options.some(opt => opt.hasCheckbox);
                
                if (hasCheckboxOptions && options.length > 0) {
                    // 分离问题部分和选项部分
                    let questionText = filteredMessage;
                    if (optionStartIndex >= 0) {
                        const lines = filteredMessage.split('\n');
                        questionText = lines.slice(0, optionStartIndex).join('\n').trim();
                        
                        // 如果questionText为空或太短，尝试从消息中移除所有选项行
                        if (!questionText || questionText.length < 10) {
                            const allLines = filteredMessage.split('\n');
                            const filteredLines = allLines.filter((line, idx) => {
                                const trimmed = line.trim();
                                if (!trimmed) return true; // 保留空行
                                // 检查是否是选项行
                                const isOptionLine = /.*?[\u25A1\u2610\u25A0-\u25AF\u2611\u2612]\s*[A-Z][.)]\s*/.test(trimmed) ||
                                                     /^[-•]?\s*[A-Z][.)]\s*/.test(trimmed);
                                return !isOptionLine;
                            });
                            questionText = filteredLines.join('\n').trim();
                        }
                    }
                    
                    // 显示问题部分（如果有）
                    if (questionText) {
                        const questionSpan = document.createElement('span');
                        questionSpan.className = 'message-text';
                        questionSpan.innerHTML = convertUrlsToLinks(questionText);
                        messageDiv.appendChild(questionSpan);
                    }
                    
                    // 创建选项容器
                    const choiceContainer = document.createElement('div');
                    choiceContainer.className = 'message choice-message';
                    choiceContainer.style.cssText = 'padding: 15px; background: var(--bg-secondary); border-radius: 8px; margin: 10px 0;';
                    
                    // 为每个选项创建复选框
                    options.forEach(function(option) {
                        // 只处理包含方框字符的选项
                        if (!option.hasCheckbox) {
                            return;
                        }
                        
                        const optionDiv = document.createElement('div');
                        optionDiv.style.cssText = 'display: flex; align-items: flex-start; padding: 8px 0; cursor: pointer;';
                        optionDiv.className = 'choice-option';
                        
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.value = option.fullText;
                        checkbox.style.cssText = 'margin-right: 10px; margin-top: 3px; cursor: pointer; width: 18px; height: 18px;';
                        checkbox.className = 'choice-checkbox';
                        
                        const label = document.createElement('label');
                        label.style.cssText = 'flex: 1; cursor: pointer; color: var(--text-primary); line-height: 1.5;';
                        label.textContent = option.fullText;
                        label.setAttribute('for', 'choice-' + option.label);
                        checkbox.id = 'choice-' + option.label;
                        
                        // 复选框状态变化时不再发送，改为仅显示状态
                        checkbox.addEventListener('change', function() {
                            // 不再发送user_input_response，用户需要在输入框中输入
                            // 仅更新UI状态
                            if (checkbox.checked) {
                                // 禁用所有复选框，防止重复选择
                                document.querySelectorAll('.choice-checkbox').forEach(function(cb) {
                                    cb.disabled = true;
                                });
                                // 显示已选择的状态
                                document.querySelectorAll('.choice-option').forEach(function(opt) {
                                    opt.style.opacity = '0.6';
                                });
                            }
                        });
                        
                        // 点击选项的其他部分时，切换复选框状态（仅用于显示，不发送）
                        optionDiv.addEventListener('click', function(e) {
                            // 如果点击的是复选框本身，不处理（change事件会处理）
                            if (e.target === checkbox) {
                                return;
                            }
                            // 点击选项的其他部分，切换复选框状态
                            checkbox.checked = !checkbox.checked;
                            // 触发change事件
                            checkbox.dispatchEvent(new Event('change'));
                        });
                        
                        optionDiv.appendChild(checkbox);
                        optionDiv.appendChild(label);
                        choiceContainer.appendChild(optionDiv);
                    });
                    
                    // 如果有选项，添加到消息容器
                    if (choiceContainer.children.length > 0) {
                        messageDiv.appendChild(choiceContainer);
                    }
                } else {
                    // 如果没有方框字符选项，正常显示消息
                    const textSpan = document.createElement('span');
                    textSpan.className = 'message-text';
                    textSpan.innerHTML = convertUrlsToLinks(filteredMessage);
                    messageDiv.appendChild(textSpan);
                }
            } else {
                // 对于其他类型的消息，正常显示
                const textSpan = document.createElement('span');
                textSpan.className = 'message-text';
                textSpan.innerHTML = convertUrlsToLinks(filteredMessage);
                messageDiv.appendChild(textSpan);
            }
            
            chatMessages.appendChild(messageDiv);
            
            // Only scroll when auto-scroll is enabled
            if (shouldScroll) {
                // 使用节流的自动滚动函数，减少跳动
                throttledAutoScroll(true);
            } else {
                // If can't auto-scroll, show new message indicator (except for user messages)
                if (type !== 'user') {
                    // showNewMessageIndicator(); // 已禁用
                }
            }

            if (['info', 'error', 'success'].includes(type)) {
                lastMessageType = type;
                lastMessageDiv = messageDiv;
                lastMessageContent = filteredMessage; // 保存过滤后的消息内容
            } else {
                lastMessageType = null;
                lastMessageDiv = null;
                lastMessageContent = null;
            }
        }


















        function setTaskRunning(running) {
            isTaskRunning = running;
            // 允许用户在任务执行过程中输入新的需求，但不允许执行
            userInput.disabled = false;
            
            // 获取无限执行按钮和追加任务按钮
            const infiniteExecuteButton = document.getElementById('infiniteExecuteButton');
            const appendTaskButton = document.getElementById('appendTaskButton');
            
            if (running) {
                sendButton.style.display = 'none';
                newTaskButton.style.display = 'none';
                // 在多智能体模式下同时显示停止按钮和追加按钮
                stopButton.style.display = 'flex';
                if (multiAgentMode && appendTaskButton) {
                    appendTaskButton.style.display = 'flex';
                } else {
                    if (appendTaskButton) {
                        appendTaskButton.style.display = 'none';
                    }
                }
                // 禁用无限执行按钮
                if (infiniteExecuteButton) {
                    infiniteExecuteButton.disabled = true;
                    infiniteExecuteButton.style.opacity = '0.6';
                    infiniteExecuteButton.style.cursor = 'not-allowed';
                }
                // 更新输入框提示文本
                userInput.placeholder = I18N.running_input_placeholder || 'Task is running. You can type a new request (will execute after current task)...';
            } else {
                sendButton.style.display = 'flex';
                newTaskButton.style.display = 'flex';
                stopButton.style.display = 'none';
                if (appendTaskButton) {
                    appendTaskButton.style.display = 'none';
                }
                // 启用无限执行按钮
                if (infiniteExecuteButton) {
                    infiniteExecuteButton.disabled = false;
                    infiniteExecuteButton.style.opacity = '1';
                    infiniteExecuteButton.style.cursor = 'pointer';
                }
                // 恢复原始提示文本
                userInput.placeholder = '{{ i18n.input_placeholder }}';
            }
        }

        function ensureTaskTriggerReady() {
            if (!sendButton || !newTaskButton || !stopButton) {
                return;
            }

            if (!isConnected) {
                return;
            }

            const stopDisplay = typeof window !== 'undefined' && window.getComputedStyle
                ? window.getComputedStyle(stopButton).display
                : stopButton.style.display;

            const sendHidden = sendButton.style.display === 'none';
            const newHidden = newTaskButton.style.display === 'none';
            const stopVisible = stopDisplay && stopDisplay !== 'none';
            const sendDisabled = sendButton.disabled;
            const newDisabled = newTaskButton.disabled;

            if (!isTaskRunning && (sendHidden || newHidden || stopVisible || sendDisabled || newDisabled)) {
                console.log('[UI] 恢复任务发起按钮到就绪状态');
                setTaskRunning(false);
                sendButton.disabled = false;
                newTaskButton.disabled = false;
            }
        }

        // Input handling
        async function sendMessage(planMode = null) {
            // Get mode from select if not provided
            if (planMode === null) {
                const modeSelect = document.getElementById('executionModeSelect');
                planMode = modeSelect ? modeSelect.value === 'plan' : false;
                console.log('🔧 Frontend: planMode from executionModeSelect:', planMode, 'select value:', modeSelect ? modeSelect.value : 'N/A');
            } else {
                console.log('🔧 Frontend: planMode passed as parameter:', planMode);
            }
            
            // Save current task's plan_mode state
            currentTaskPlanMode = planMode;
            
            let message = userInput.value.trim();
            if (isTaskRunning || !socket || !isConnected) return;

            // 处理@文件名引用，收集文件路径信息
            let attachedFilePaths = [];
            if (window.attachedFiles && window.attachedFiles.size > 0) {
                const fileReferenceRegex = /@([^\s@]+)/g;
                const fileReferences = message.match(fileReferenceRegex);
                
                if (fileReferences) {
                    for (const ref of fileReferences) {
                        const filePath = window.attachedFiles.get(ref);
                        if (filePath) {
                            attachedFilePaths.push({
                                reference: ref,
                                path: filePath,
                                name: ref.substring(1) // 移除@符号
                            });
                        }
                    }
                }
                
                // 清空已处理的文件引用
                window.attachedFiles.clear();
            }

            // 保存当前输入内容，以防出错时需要恢复
            pendingUserInput = userInput.value.trim();

            // 检查guest用户权限
            if (isGuest) {
                addMessage(I18N.guest_cannot_execute, 'error');
                return;
            }

            // In new mode, automatically create new directory first
            if (taskMode === 'new') {
                addMessage(I18N.creating_directory || 'Creating new workspace directory...', 'info');
                // 标记是因为发送任务而创建目录
                isCreatingDirectoryForTask = true;
                // Store the message to be sent after directory creation
                pendingUserInput = message;
                createNewDirectory();
                return;
            }

            // Get selected model configuration (async)
            const modelConfig = await getSelectedModelConfig();
            if (!modelConfig) {
                addMessage(I18N.select_valid_config, 'error');
                return;
            }
            
            // Validate configuration before execution
            try {
                const response = await fetch('/api/validate-config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        config: modelConfig
                    })
                });
                
                const result = await response.json();
                
                if (!result.success) {
                    addMessage(`${I18N.config_error_title}: ${result.error}`, 'error');
                    return;
                }
                
                // Configuration is valid, proceed with execution

                // Immediately set task running state for better user experience
                setTaskRunning(true);

                // Get execution rounds from config slider
                // 如果无限执行模式启用，则设置为-1
                const configRoundsSlider = document.getElementById('configRoundsSlider');
                const executionRounds = infiniteExecuteMode ? -1 : (configRoundsSlider ? parseInt(configRoundsSlider.value) : 100);

                // Get GUI configuration options
                const guiConfig = {
                    enable_web_search: webSearchMode,
                    enable_multi_agent: multiAgentMode,
                    enable_long_term_memory: document.getElementById('enableLongTermMemory').checked,
                    enable_mcp: document.getElementById('enableMCP').checked,
                    enable_jieba: document.getElementById('enableJieba').checked,
                    enable_thinking: thinkingMode,
                    routine_file: document.getElementById('routineSelect').value,
                    // Add app_name from current path (简化设计：每次前端发起routine都携带app信息)
                    app_name: getCurrentAppFromPath(),
                    // Add model configuration
                    selected_model: modelConfig.model,
                    // 对于内置配置，不发送 api_key 和 api_base（后端会从服务器端读取）
                    // 对于自定义配置，才发送用户输入的密钥
                    model_max_tokens: result.config.max_tokens,
                    // Add selected MCP servers
                    selected_mcp_servers: getSelectedMCPServers(),
                    // Add language preference (动态获取当前语言)
                    language: getCurrentLanguage(),
                    // Add execution rounds
                    execution_rounds: executionRounds
                };
                
                // 只有自定义配置才发送 api_key 和 api_base
                // 通过检查 modelSelect 的值来判断是否为自定义配置
                const modelSelect = document.getElementById('modelSelect');
                if (modelSelect && modelSelect.value === 'custom' && modelConfig && modelConfig.api_key && modelConfig.api_base) {
                    guiConfig.model_api_key = modelConfig.api_key;
                    guiConfig.model_api_base = modelConfig.api_base;
                } else if (modelConfig && modelConfig.api_key && modelConfig.api_base) {
                    // 对于从服务器获取的内置配置，也发送api_key和api_base
                    guiConfig.model_api_key = modelConfig.api_key;
                    guiConfig.model_api_base = modelConfig.api_base;
                }

                if (taskMode === 'selected' && selectedDirectory) {
                    console.log('[DEBUG] Emitting execute_task with type=selected, taskMode:', taskMode, 'selectedDirectory:', selectedDirectory);
                    socket.emit('execute_task', {
                        requirement: message,
                        type: 'selected',
                        plan_mode: planMode,
                        gui_config: guiConfig,
                        attached_files: attachedFilePaths,
                        selected_directory: selectedDirectory  // 🔧 确保发送选中的目录
                    });
                } else {
                    console.log('[DEBUG] Emitting execute_task with type=continue, taskMode:', taskMode);
                    socket.emit('execute_task', {
                        requirement: message,
                        type: 'continue',
                        plan_mode: planMode,
                        gui_config: guiConfig,
                        attached_files: attachedFilePaths
                    });
                }
                
                // 🔧 任务发送后立即设置任务运行状态，防止重复提交
                setTaskRunning(true);
                
                // 任务发送成功后立即清空输入框
                userInput.value = '';
                pendingUserInput = '';
                // 清空文件引用（已在sendMessage中处理并清空，这里确保清空）
                if (window.attachedFiles) {
                    window.attachedFiles.clear();
                }
                resizeTextarea();
                
            } catch (error) {
                console.error('Configuration validation error:', error);
                addMessage(`${I18N.config_error_title}: ${I18N.config_validation_failed}`, 'error');
            }
        }

        function createNewDirectory() {
            if (isTaskRunning || !socket || !isConnected) return;
            
            // 检查guest用户权限
            if (isGuest) {
                addMessage(I18N.guest_cannot_create, 'error');
                isCreatingDirectoryForTask = false; // 重置标志
                return;
            }
            
            // 如果不是因为发送任务而创建目录（即用户直接点击新建工作目录按钮），清空待发送消息
            if (!isCreatingDirectoryForTask) {
                pendingUserInput = '';
            }
            
            socket.emit('create_new_directory', {
                language: getCurrentLanguage()
            });
        }

        /**
         * 自动清理聊天记录和工具调用信息（不需要确认对话框）
         * 用于新建工作目录时自动清理
         */
        function autoClearChat() {
            if (!socket || !isConnected) return;
            
            // 清理批处理队列和定时器
            clearTimeout(batchProcessingTimer);
            batchProcessingTimer = null;
            messageBatchQueue = [];
            isBatchProcessing = false;
            batchScrollPending = false;
            
            // Clear the chat messages immediately for better user experience
            chatMessages.innerHTML = `
                <div class="message system">
                    <strong><i class="fas fa-info-circle"></i> ${I18N.system_message || '系统消息'}</strong><br>
                    ${I18N.welcome_message || '欢迎使用 OfficeCowork！请在下方输入您的需求，系统将自动为您处理任务。'}
                </div>
            `;
            
            // Reset message tracking variables
            lastMessageType = null;
            lastMessageDiv = null;
            lastMessageContent = null;
            
            // 重置JSON收集状态
            resetJsonCollectingState();
            
            // 清空细节信息窗口（工具调用信息显示框）
            const detailInfoMessages = document.getElementById('detailInfoMessages');
            if (detailInfoMessages) {
                detailInfoMessages.innerHTML = '';
            }
            
            // Reset scroll state
            autoScrollEnabled = true;
            updateAutoScrollIndicator();
            
            // Clear attached files
            if (window.attachedFiles) {
                window.attachedFiles.clear();
            }
            
            // Scroll to bottom
            scrollToBottom(false);
            
            // Notify server with language preference
            socket.emit('clear_chat', { language: getCurrentLanguage() });
        }

        function clearChat() {
            if (!socket || !isConnected) return;
            
            // Show confirmation dialog
            if (confirm(I18N.confirm_clear_chat)) {
                // 清理批处理队列和定时器
                clearTimeout(batchProcessingTimer);
                batchProcessingTimer = null;
                messageBatchQueue = [];
                isBatchProcessing = false;
                batchScrollPending = false;
                
                // Clear the chat messages immediately for better user experience
                chatMessages.innerHTML = `
                    <div class="message system">
                        <strong><i class="fas fa-info-circle"></i> ${I18N.system_message || '系统消息'}</strong><br>
                        ${I18N.welcome_message || '欢迎使用 OfficeCowork！请在下方输入您的需求，系统将自动为您处理任务。'}
                    </div>
                `;
                
                // Reset message tracking variables
                lastMessageType = null;
                lastMessageDiv = null;
                lastMessageContent = null;
                
                // 重置JSON收集状态
                resetJsonCollectingState();
                
                // 清空细节信息窗口
                const detailInfoMessages = document.getElementById('detailInfoMessages');
                if (detailInfoMessages) {
                    detailInfoMessages.innerHTML = '';
                }
                
                // Reset scroll state
                autoScrollEnabled = true;
                updateAutoScrollIndicator();
                
                // Clear attached files
                if (window.attachedFiles) {
                    window.attachedFiles.clear();
                }
                
                // Scroll to bottom
                scrollToBottom(false);
                
                // Notify server with language preference
                socket.emit('clear_chat', { language: getCurrentLanguage() });
            }
        }

        /**
         * 检查sessionStorage中是否有注册后的API key
         * 从注册页面跳转过来时，API key会保存在sessionStorage中
         */
        function checkRegisteredApiKey() {
            try {
                const registeredApiKey = sessionStorage.getItem('registered_api_key');
                
                if (registeredApiKey) {
                    console.log('🔑 Found registered API key in sessionStorage');
                    
                    // 🔧 修复：清除localStorage中可能存在的旧访客API key（空字符串）
                    // 确保使用新的注册API key而不是旧的访客状态
                    try {
                        const oldApiKey = localStorage.getItem('agia_api_key');
                        if (oldApiKey === '' || oldApiKey === null) {
                            console.log('🧹 Clearing old guest API key from localStorage');
                            localStorage.removeItem('agia_api_key');
                        }
                    } catch (e) {
                        // 静默处理错误
                    }
                    
                    // 先断开旧的连接（如果存在），确保清除旧的访客状态
                    if (socket && socket.connected) {
                        console.log('🔌 Disconnecting old session before connecting with new API key');
                        socket.removeAllListeners();
                        socket.disconnect();
                        socket = null;
                        // 重置连接状态
                        resetAfterDisconnect(false); // false表示不删除localStorage，因为我们马上要保存新的
                    }
                    
                    // 填入API Key输入框
                    apiKeyInput.value = registeredApiKey;
                    
                    // 清除sessionStorage中的API key（一次性使用）
                    sessionStorage.removeItem('registered_api_key');
                    
                    // 延迟一点时间确保DOM完全加载和旧连接完全断开
                    setTimeout(() => {
                        console.log('🚀 Auto-filling API key from registration...');
                        // 自动连接到服务器
                        connectUser();
                    }, 200); // 增加延迟时间，确保旧连接完全断开
                    
                    return true; // 返回true表示找到了注册的API key
                }
            } catch (error) {
                console.error('❌ Error reading sessionStorage:', error);
            }
            
            return false; // 返回false表示没有找到注册的API key
        }

        /**
         * 检查并恢复localStorage中保存的会话
         * 当页面刷新时自动恢复上次的登录状态
         */
        function checkSessionRestore() {
            try {
                const savedApiKey = localStorage.getItem('agia_api_key');
                
                if (savedApiKey !== null) { // null means no item, empty string is valid for default user
                    // 填入API Key输入框
                    apiKeyInput.value = savedApiKey;
                    
                    // 延迟一点时间确保DOM完全加载
                    setTimeout(() => {
                        connectUser();
                    }, 500);
                    
                    return true; // 返回true表示找到了保存的会话并尝试恢复
                }
            } catch (error) {
                console.error('❌ Error restoring session from localStorage:', error);
            }
            
            return false; // 返回false表示没有找到保存的会话
        }

        async function executeSelectedTask() {
            const message = userInput.value.trim();
            if (isTaskRunning) return;

            // 保存当前输入内容，以防出错时需要恢复
            pendingUserInput = message;

            if (!selectedDirectory && !ensureSelectedDirectoryFromUI()) {
                addMessage(I18N.select_directory_first, 'error');
                // 显示错误消息时不清空用户输入框，保留用户输入的内容
                // pendingUserInput 已经保存了用户输入，不需要额外处理
                return;
            }

            // Get selected model configuration (async)
            const modelConfig = await getSelectedModelConfig();
            if (!modelConfig) {
                addMessage(I18N.select_valid_config, 'error');
                return;
            }
            
            // Validate configuration before execution
            try {
                const response = await fetch('/api/validate-config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        config: modelConfig
                    })
                });
                
                const result = await response.json();
                
                if (!result.success) {
                    addMessage(`${I18N.config_error_title}: ${result.error}`, 'error');
                    return;
                }
                
                // Configuration is valid, proceed with execution
                // Only display user message if it's not empty
                if (message) {
                    addMessage(message, 'user');
                }

                // Get GUI configuration options
                const guiConfig = {
                    enable_web_search: webSearchMode,
                    enable_multi_agent: multiAgentMode,
                    enable_long_term_memory: document.getElementById('enableLongTermMemory').checked,
                    enable_mcp: document.getElementById('enableMCP').checked,
                    enable_jieba: document.getElementById('enableJieba').checked,
                    enable_thinking: thinkingMode,
                    routine_file: document.getElementById('routineSelect').value,
                    // Add app_name from current path (简化设计：每次前端发起routine都携带app信息)
                    app_name: getCurrentAppFromPath(),
                    // Add model configuration
                    selected_model: modelConfig.model,
                    // 对于内置配置，不发送 api_key 和 api_base（后端会从服务器端读取）
                    // 对于自定义配置，才发送用户输入的密钥
                    model_max_tokens: result.config.max_tokens,
                    // Add selected MCP servers
                    selected_mcp_servers: getSelectedMCPServers(),
                    // Add language preference (动态获取当前语言)
                    language: getCurrentLanguage(),
                    // Add execution rounds (如果无限执行模式启用，则设置为-1)
                    execution_rounds: infiniteExecuteMode ? -1 : (() => {
                        const configRoundsSlider = document.getElementById('configRoundsSlider');
                        return configRoundsSlider ? parseInt(configRoundsSlider.value) : 100;
                    })()
                };
                
                // 只有自定义配置才发送 api_key 和 api_base
                // 通过检查 modelSelect 的值来判断是否为自定义配置
                const modelSelect = document.getElementById('modelSelect');
                if (modelSelect && modelSelect.value === 'custom' && modelConfig && modelConfig.api_key && modelConfig.api_base) {
                    guiConfig.model_api_key = modelConfig.api_key;
                    guiConfig.model_api_base = modelConfig.api_base;
                } else if (modelConfig && modelConfig.api_key && modelConfig.api_base) {
                    // 对于从服务器获取的内置配置，也发送api_key和api_base
                    guiConfig.model_api_key = modelConfig.api_key;
                    guiConfig.model_api_base = modelConfig.api_base;
                }

                // Get plan_mode from executionModeSelect
                const modeSelect = document.getElementById('executionModeSelect');
                const planMode = modeSelect ? modeSelect.value === 'plan' : false;
                console.log('🔧 Frontend (executeSelectedTask): planMode:', planMode, 'select value:', modeSelect ? modeSelect.value : 'N/A');
                
                // Save current task's plan_mode state
                currentTaskPlanMode = planMode;

                socket.emit('execute_task', {
                    requirement: message,
                    type: 'selected',
                    plan_mode: planMode,
                    gui_config: guiConfig
                });
                
                // 🔧 任务发送后立即设置任务运行状态，防止重复提交
                setTaskRunning(true);
                
                // 任务发送后立即清空输入框（但保留pendingUserInput以便错误时恢复）
                userInput.value = '';
                // 注意：不清空pendingUserInput，以便在错误时可以恢复用户输入
                // pendingUserInput 将在任务成功启动或确认失败后清空
                // 清空文件引用（已在sendMessage中处理并清空，这里确保清空）
                if (window.attachedFiles) {
                    window.attachedFiles.clear();
                }
                resizeTextarea();
                
            } catch (error) {
                console.error('Configuration validation error:', error);
                addMessage(`${I18N.config_error_title}: ${I18N.config_validation_failed}`, 'error');
            }
        }

        function selectDirectory(dirName) {
            if (!socket || !isConnected) return;
            
            console.log(`🎯 Selecting directory: ${dirName}`);
            
            // 总是更新选择的目录，即使是同一个目录
            selectedDirectory = dirName;
            
            // Switch to selected directory mode
            taskMode = 'selected';
            
            // Update agent view button state
            updateAgentViewButtonState();
            
            // 发送选择目录的请求
            socket.emit('select_directory', {
                dir_name: dirName
            });
            
            // Update UI to show selected state, but don't refresh entire list
            document.querySelectorAll('.directory-item').forEach(item => {
                item.classList.remove('selected');
            });
            const selectedItem = document.querySelector(`[data-dir="${dirName}"]`);
            if (selectedItem) {
                selectedItem.classList.add('selected');
            }
            
            // 启动文件监测
            startFileMonitoring();
            
            console.log(`✅ Directory selected: ${dirName}, mode: ${taskMode}`);
        }

        function getHighlightedDirectoryFromUI() {
            const highlightedElement = document.querySelector('.directory-item.selected[data-dir]');
            if (highlightedElement) {
                return highlightedElement.getAttribute('data-dir');
            }
            return null;
        }

        function ensureSelectedDirectoryFromUI() {
            if (selectedDirectory) {
                return true;
            }

            const highlightedDir = getHighlightedDirectoryFromUI();
            if (highlightedDir) {
                console.log(`🔁 Restoring selected directory from UI highlight: ${highlightedDir}`);
                selectDirectory(highlightedDir);
                return true;
            }

            return false;
        }

        /**
         * 清除所有目录项的选中状态（蓝色勾选）
         */
        function clearAllDirectorySelections() {
            document.querySelectorAll('.directory-item').forEach(item => {
                item.classList.remove('selected');
            });
            selectedDirectory = null;
            console.log('🧹 Cleared all directory selections');
        }

        function selectAndToggleDirectory(dirName) {
            // 只选择目录，不自动展开
            selectDirectory(dirName);
        }

        /**
         * 处理目录项的点击事件
         * @param {Event} event - 点击事件对象
         * @param {string} dirName - 目录名称
         */
        function handleDirectoryItemClick(event, dirName) {
            console.log(`[DEBUG] 🎯 Click detected on directory item: ${dirName}`);
            console.log(`[CLICK DEBUG] 点击目标: ${event.target.tagName}.${event.target.className} 坐标:(${event.clientX},${event.clientY})`);
            console.log(`[CLICK DEBUG] 目录项: ${dirName}`);
            
            // 检查点击目标是否是按钮或操作区域
            const clickedElement = event.target;
            const isButton = clickedElement.closest('.action-btn');
            const isFileTree = clickedElement.closest('.file-tree');
            
            // 如果点击的是按钮或文件树，不处理目录选择
            if (isButton || isFileTree) {
                console.log(`[DEBUG] ❌ Click on button or file tree, ignoring directory selection`);
                return;
            }
            
            console.log(`[DEBUG] ✅ Valid directory selection click detected`);
            console.log(`[DEBUG] 🎯 selectAndToggleDirectory called for: ${dirName}`);
            
            // 调用原有的选择目录函数
            selectAndToggleDirectory(dirName);
        }


        function resizeTextarea() {
            userInput.style.height = 'auto';
            userInput.style.height = Math.min(userInput.scrollHeight, 120) + 'px';
        }

        // Event listeners
        connectBtn.addEventListener('click', function() {
            if (isConnected) {
                disconnectUser();
            } else {
                connectUser();
            }
        });

        // 注册链接点击事件
        const registerLink = document.getElementById('registerLink');
        registerLink.addEventListener('click', function(e) {
            e.preventDefault(); // 阻止默认的链接跳转

            // 获取当前路径作为来源页面标记
            const currentPath = window.location.pathname;
            const registerUrl = currentPath === '/' ? '/register' : `/register?from=${encodeURIComponent(currentPath)}`;

            if (isConnected) {
                // 如果当前处于连接状态，先断开连接
                disconnectUser();
                // 等待断开连接完成后再跳转到注册页面
                setTimeout(() => {
                    window.location.href = registerUrl;
                }, 1000); // 给1秒时间让断开连接操作完成
            } else {
                // 如果没有连接，直接跳转到注册页面
                window.location.href = registerUrl;
            }
        });

        apiKeyInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (!isConnected) {
                    connectUser();
                }
            }
        });

        sendButton.addEventListener('click', () => sendMessage(null)); // Pass null to auto-read from executionModeSelect
        
        // User input modal handlers - 已删除，改为在聊天窗口中显示选择题

        newTaskButton.addEventListener('click', createNewDirectory);

        let stopButtonClickCount = 0;
        let stopButtonTimeout = null;
        
        stopButton.addEventListener('click', function() {
            if (socket && isTaskRunning) {
                stopButtonClickCount++;
                
                // Clear previous timeout
                if (stopButtonTimeout) {
                    clearTimeout(stopButtonTimeout);
                }
                
                // 🔧 Fix: 立即结束绿框状态，防止新任务的消息显示在旧的绿框中
                resetJsonCollectingState();
                lastMessageType = null;
                lastMessageDiv = null;
                lastMessageContent = null;
                
                if (stopButtonClickCount === 1) {
                    // First click: try normal stop
                    socket.emit('stop_task', { force: false });
                    
                    // Reset counter after 2 seconds
                    stopButtonTimeout = setTimeout(() => {
                        stopButtonClickCount = 0;
                    }, 2000);
                } else if (stopButtonClickCount >= 2) {
                    // Second click (within 2 seconds): force stop
                    stopButtonClickCount = 0;
                    if (stopButtonTimeout) {
                        clearTimeout(stopButtonTimeout);
                        stopButtonTimeout = null;
                    }
                    socket.emit('stop_task', { force: true });
                }
            }
        });

        // 追加任务按钮点击事件（仅多智能体模式）
        if (appendTaskButton) {
            appendTaskButton.addEventListener('click', function() {
                if (socket && isTaskRunning && multiAgentMode) {
                    const message = userInput.value.trim();
                    if (!message) {
                        addMessage(I18N.get('append_task_empty', '请输入要追加的任务内容'), 'warning');
                        return;
                    }
                    
                    // 发送追加任务请求
                    socket.emit('append_task', {
                        content: message
                    });
                    
                    // 清空输入框
                    userInput.value = '';
                    resizeTextarea();
                }
            });
        }

        clearChatButton.addEventListener('click', clearChat);
        
        // Agent view button
        // Load history button
        const loadHistoryBtn = document.getElementById('loadHistoryBtn');
        function updateLoadHistoryButtonState() {
            if (loadHistoryBtn) {
                if (selectedDirectory) {
                    loadHistoryBtn.disabled = false;
                    loadHistoryBtn.style.opacity = '1';
                    loadHistoryBtn.style.cursor = 'pointer';
                } else {
                    loadHistoryBtn.disabled = true;
                    loadHistoryBtn.style.opacity = '0.5';
                    loadHistoryBtn.style.cursor = 'not-allowed';
                }
            }
        }
        
        const agentViewBtn = document.getElementById('agentViewBtn');
        function updateAgentViewButtonState() {
            if (agentViewBtn) {
                if (selectedDirectory) {
                    agentViewBtn.disabled = false;
                    agentViewBtn.style.opacity = '1';
                    agentViewBtn.style.cursor = 'pointer';
                } else {
                    agentViewBtn.disabled = true;
                    agentViewBtn.style.opacity = '0.5';
                    agentViewBtn.style.cursor = 'not-allowed';
                }
            }
            // Also update load history button state
            updateLoadHistoryButtonState();
        }
        
        // Function to load and display history from manager.out
        function loadHistoryFromManagerOut(managerOutContent) {
            // 先清空聊天记录框
            const chatMessages = document.getElementById('chatMessages');
            if (chatMessages) {
                chatMessages.innerHTML = '';
            }
            
            // 重置消息跟踪变量
            lastMessageType = null;
            lastMessageDiv = null;
            lastMessageContent = null;
            
            // 重置JSON收集状态
            resetJsonCollectingState();
            
            // 清空工具调用信息显示框
            const detailInfoMessages = document.getElementById('detailInfoMessages');
            if (detailInfoMessages) {
                detailInfoMessages.innerHTML = '';
            }
            
            // 清理批处理队列和定时器
            clearTimeout(batchProcessingTimer);
            batchProcessingTimer = null;
            messageBatchQueue = [];
            isBatchProcessing = false;
            batchScrollPending = false;
            
            // 设置标志，表示正在从manager.out加载历史内容
            isLoadingFromManagerOut = true;
            
            // 保存当前自动滚动状态，并在加载期间禁用自动滚动
            savedAutoScrollStateBeforeLoading = autoScrollEnabled;
            autoScrollEnabled = false;
            
            // 稍等一下，确保清空操作完成，然后再加载manager.out内容
            setTimeout(function() {
                // 解析manager.out内容，收集所有消息
                const lines = managerOutContent.split('\n');
                const messagesToDisplay = []; // 收集所有消息
                
                // 预处理：收集所有消息到数组
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const lineTrimmed = line.trim();
                    
                    // 跳过空行（但保留换行符以维持格式）
                    if (!lineTrimmed && i < lines.length - 1) {
                        // 空行也保留
                        messagesToDisplay.push({ message: line, type: 'info' });
                        continue;
                    }
                    
                    // 判断消息类型
                    let messageType = 'info';
                    
                    // 检测用户输入消息
                    if (lineTrimmed.startsWith('Received user requirement:')) {
                        messageType = 'user';
                    }
                    // 检测错误消息
                    else if (lineTrimmed.startsWith('⚠️') || lineTrimmed.startsWith('Status: failed') || lineTrimmed.includes('Permission denied')) {
                        messageType = 'error';
                    }
                    // 检测成功消息
                    else if (lineTrimmed.startsWith('✅') || lineTrimmed.startsWith('Status: success')) {
                        messageType = 'success';
                    }
                    // 检测工具调用标记（💬开头的消息）
                    else if (lineTrimmed.startsWith('💬')) {
                        messageType = 'info';
                    }
                    
                    messagesToDisplay.push({ message: line, type: messageType });
                }
                
                // 批量显示消息，使用更粗粒度的批量渲染
                // 如果消息数量较少，直接一次性显示；否则分批显示
                if (messagesToDisplay.length <= 500) {
                    // 消息数量较少，一次性显示所有消息
                    for (let i = 0; i < messagesToDisplay.length; i++) {
                        const msgData = messagesToDisplay[i];
                        addMessageImmediate(msgData.message, msgData.type);
                    }
                    // 加载完成
                    isLoadingFromManagerOut = false;
                    autoScrollEnabled = savedAutoScrollStateBeforeLoading;
                    updateAutoScrollIndicator();
                } else {
                    // 消息数量较多，使用粗粒度分批显示
                    let messageIndex = 0;
                    const BATCH_SIZE = 1000; // 每批显示1000条消息
                    const TIME_DELAY = 500; // 每500ms处理一批，大幅降低刷新频率
                    
                    function renderBatch() {
                        if (messageIndex >= messagesToDisplay.length) {
                            // 所有消息已显示完成
                            isLoadingFromManagerOut = false;
                            autoScrollEnabled = savedAutoScrollStateBeforeLoading;
                            updateAutoScrollIndicator();
                            return;
                        }
                        
                        // 处理一批消息（一次性处理BATCH_SIZE条）
                        const endIndex = Math.min(messageIndex + BATCH_SIZE, messagesToDisplay.length);
                        
                        // 批量添加消息，减少DOM操作
                        for (let i = messageIndex; i < endIndex; i++) {
                            const msgData = messagesToDisplay[i];
                            // 直接调用addMessageImmediate，跳过批处理队列
                            addMessageImmediate(msgData.message, msgData.type);
                        }
                        
                        messageIndex = endIndex;
                        
                        // 延迟处理下一批，大幅降低刷新频率
                        setTimeout(renderBatch, TIME_DELAY);
                    }
                    
                    // 开始批量渲染
                    setTimeout(renderBatch, TIME_DELAY);
                }
            }, 100); // 延迟100ms，确保欢迎信息先显示
        }
        
        /**
         * 加载指定agent的历史记录
         * @param {string} agentName - agent名称，默认为'manager'
         */
        function loadAgentHistory(agentName = 'manager') {
            // Check if a directory is selected
            if (!selectedDirectory) {
                const message = (typeof I18N !== 'undefined' && I18N.lang === 'zh') ? '请先选择一个工作目录' : 'Please select a workspace directory first';
                alert(message);
                return;
            }
            
            // 发送加载历史请求
            if (socket && isConnected) {
                socket.emit('load_history', {
                    dir_name: selectedDirectory,
                    agent_name: agentName
                });
            } else {
                const message = (typeof I18N !== 'undefined' && I18N.lang === 'zh') ? '连接未建立，无法加载历史' : 'Connection not established, cannot load history';
                alert(message);
            }
        }
        
        // Agent选择下拉框相关函数
        function updateAgentSelectDropdown(outFiles) {
            const wrapper = document.getElementById('agentSelectWrapper');
            const dropdown = document.getElementById('agentSelectDropdown');
            
            if (!wrapper || !dropdown) {
                return;
            }
            
            // 如果只有manager或者没有任何.out文件，则不显示下拉框
            if (outFiles.length <= 1) {
                wrapper.style.display = 'none';
                return;
            }
            
            // 如果有多个.out文件，显示下拉框并列出所有.out文件（不包括.out后缀）
            wrapper.style.display = 'flex';
            
            // 保存当前选择的值（如果存在且不是默认值）
            const currentValue = dropdown.value;
            const shouldPreserveSelection = currentValue && currentValue !== outFiles[0] && outFiles.includes(currentValue);
            
            // 清空现有选项
            dropdown.innerHTML = '';
            
            // 添加所有.out文件选项
            outFiles.forEach(agentName => {
                const option = document.createElement('option');
                option.value = agentName;
                option.textContent = agentName;
                dropdown.appendChild(option);
            });
            
            // 初始化change事件监听器（如果还没有绑定）
            initAgentSelectDropdownListener();
            
            // 如果用户之前选择了非manager的选项，且该选项仍然存在，则保持选择
            // 否则默认选择第一个（通常是manager，如果存在的话）
            // 注意：不再自动加载历史记录，用户需要手动点击"加载历史"按钮
            if (outFiles.length > 0) {
                if (shouldPreserveSelection) {
                    dropdown.value = currentValue;
                } else {
                    dropdown.value = outFiles[0];
                }
            }
        }
        
        // 初始化agent选择框的change事件监听器（只绑定一次）
        function initAgentSelectDropdownListener() {
            const dropdown = document.getElementById('agentSelectDropdown');
            if (!dropdown) {
                return;
            }
            
            // 检查是否已经绑定过（通过检查是否有data-listener属性）
            if (dropdown.dataset.listenerBound === 'true') {
                return;
            }
            
            // 添加change事件监听器（仅用于更新UI状态，不自动加载历史）
            // 用户需要手动点击"加载历史"按钮来加载历史记录
            dropdown.addEventListener('change', function() {
                // 只更新按钮状态，不自动加载
                updateLoadHistoryButtonState();
            });
            
            // 标记已绑定
            dropdown.dataset.listenerBound = 'true';
        }
        
        // 初始化agent选择框的change事件监听器
        initAgentSelectDropdownListener();
        
        if (loadHistoryBtn) {
            // Initial state
            updateLoadHistoryButtonState();
            
            loadHistoryBtn.addEventListener('click', function() {
                // 获取选择的agent名字（如果下拉框存在且可见，使用下拉框的值，否则使用manager）
                let agentName = 'manager';
                const wrapper = document.getElementById('agentSelectWrapper');
                const dropdown = document.getElementById('agentSelectDropdown');
                if (wrapper && wrapper.style.display !== 'none' && dropdown) {
                    agentName = dropdown.value || 'manager';
                }
                
                // 使用统一的加载历史函数
                loadAgentHistory(agentName);
            });
        }
        
        if (agentViewBtn) {
            // Initial state
            updateAgentViewButtonState();
            
            agentViewBtn.addEventListener('click', function() {
                // Check if a directory is selected
                if (!selectedDirectory) {
                    const message = (typeof I18N !== 'undefined' && I18N.lang === 'zh') ? '请先选择一个工作目录' : 'Please select a workspace directory first';
                    alert(message);
                    return;
                }
                
                // Get API key from localStorage or input field
                let apiKey = null;
                try {
                    apiKey = localStorage.getItem('agia_api_key');
                    if (!apiKey) {
                        const apiKeyInputEl = document.getElementById('apiKeyInput');
                        if (apiKeyInputEl) {
                            apiKey = apiKeyInputEl.value.trim() || null;
                        }
                    }
                } catch (e) {
                    console.warn('Failed to get API key:', e);
                }
                
                // Open agent status visualizer in a new window with selected directory and API key
                let agentViewUrl = `/agent-status-visualizer?dir=${encodeURIComponent(selectedDirectory)}`;
                if (apiKey) {
                    agentViewUrl += `&api_key=${encodeURIComponent(apiKey)}`;
                }
                window.open(agentViewUrl, '_blank', 'width=1400,height=900,resizable=yes,scrollbars=yes');
            });
        }

        userInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                
                console.log('[DEBUG] 回车键按下');
                console.log('[DEBUG] isWaitingForUserInput:', isWaitingForUserInput);
                console.log('[DEBUG] 输入框内容:', userInput.value);
                console.log('[DEBUG] socket状态:', socket ? 'connected' : 'null');
                
                // 如果正在等待user_input_request，发送输入内容到终端
                if (isWaitingForUserInput) {
                    const inputText = userInput.value.trim();
                    console.log('[DEBUG] ✅ 检测到等待用户输入，准备发送');
                    console.log('[DEBUG] 发送内容:', inputText);
                    console.log('[DEBUG] 发送数据:', { input: inputText });
                    
                    // 发送用户输入到终端
                    socket.emit('user_input_response', { input: inputText });
                    console.log('[DEBUG] ✅ 已发送 user_input_response 事件');
                    
                    // 清除等待标志
                    isWaitingForUserInput = false;
                    console.log('[DEBUG] ✅ 已清除 isWaitingForUserInput 标志');
                    
                    // 清除超时定时器
                    if (userInputTimeoutTimer !== null) {
                        clearTimeout(userInputTimeoutTimer);
                        userInputTimeoutTimer = null;
                        console.log('[DEBUG] ✅ 已清除超时定时器');
                    }
                    
                    // 清空输入框（立即执行，确保在return之前完成）
                    console.log('[DEBUG] 清空前输入框内容:', userInput.value);
                    userInput.value = '';
                    console.log('[DEBUG] ✅ 已清空输入框，当前内容:', userInput.value);
                    resizeTextarea();
                    console.log('[DEBUG] ✅ 已调用 resizeTextarea()');
                    
                    // 再次确认清空（防止被其他代码覆盖）
                    setTimeout(function() {
                        if (userInput.value !== '') {
                            console.log('[DEBUG] ⚠️ 检测到输入框被重新设置，再次清空');
                            userInput.value = '';
                            resizeTextarea();
                        }
                    }, 10);
                    
                    return;
                } else {
                    console.log('[DEBUG] ⚠️ 不在等待用户输入状态，检查是否可以发起任务');
                    // 如果处于非运行状态，则在需求框回车可以直接发起任务
                    if (!isTaskRunning && socket && isConnected && userInput.value.trim()) {
                        console.log('[DEBUG] ✅ 检测到非运行状态且有输入内容，自动发起任务');
                        sendMessage(null); // 使用null让函数自动读取executionModeSelect的值
                    } else {
                        console.log('[DEBUG] ⚠️ 无法发起任务：isTaskRunning=', isTaskRunning, 'socket=', !!socket, 'isConnected=', isConnected, 'hasContent=', !!userInput.value.trim());
                    }
                }
            }
        });

        userInput.addEventListener('input', resizeTextarea);

        // File drag and drop functionality
        let draggedFileInfo = null;

        function handleFileDragStart(event, filePath, fileName, dirName) {
            draggedFileInfo = { path: filePath, name: fileName, dirName: dirName };
            event.dataTransfer.effectAllowed = 'copy';
            event.dataTransfer.setData('text/plain', `@${fileName}`);
            // Add visual feedback
            event.currentTarget.classList.add('dragging');
        }

        function handleFileDragEnd(event) {
            event.currentTarget.classList.remove('dragging');
        }

        // Enable drag and drop on userInput
        userInput.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.stopPropagation();
            e.dataTransfer.dropEffect = 'copy';
            userInput.classList.add('drag-over');
        });

        userInput.addEventListener('dragleave', function(e) {
            e.preventDefault();
            e.stopPropagation();
            // Only remove drag-over if we're actually leaving the input area
            if (!userInput.contains(e.relatedTarget)) {
                userInput.classList.remove('drag-over');
            }
        });

        userInput.addEventListener('drop', function(e) {
            e.preventDefault();
            e.stopPropagation();
            userInput.classList.remove('drag-over');
            
            // Check if this is a file drag from workspace
            if (draggedFileInfo) {
                // Check if the file belongs to the selected directory
                if (draggedFileInfo.dirName) {
                    // If no directory is selected, or the file belongs to a different directory, show warning
                    if (!selectedDirectory || draggedFileInfo.dirName !== selectedDirectory) {
                        // Show warning message
                        const I18N = window.I18N || JSON.parse(document.getElementById('i18nData')?.textContent || '{}');
                        const warningMsg = I18N.drag_unselected_dir_warning || '请先选择此工作目录后再拖动';
                        alert(warningMsg);
                        draggedFileInfo = null;
                        return;
                    }
                }
                
                const fileReference = `@${draggedFileInfo.name}`;
                const currentValue = userInput.value;
                const cursorPos = userInput.selectionStart;
                
                // Insert file reference at cursor position
                const newValue = currentValue.slice(0, cursorPos) + 
                                (currentValue.slice(cursorPos - 1, cursorPos) !== ' ' && cursorPos > 0 ? ' ' : '') +
                                fileReference + 
                                (currentValue.slice(cursorPos, cursorPos + 1) !== ' ' && cursorPos < currentValue.length ? ' ' : '') +
                                currentValue.slice(cursorPos);
                
                userInput.value = newValue;
                
                // Set cursor position after the inserted text
                const newCursorPos = cursorPos + fileReference.length + 
                                    (currentValue.slice(cursorPos - 1, cursorPos) !== ' ' && cursorPos > 0 ? 1 : 0) +
                                    (currentValue.slice(cursorPos, cursorPos + 1) !== ' ' && cursorPos < currentValue.length ? 1 : 0);
                userInput.setSelectionRange(newCursorPos, newCursorPos);
                
                // Store file reference for later processing
                if (!window.attachedFiles) {
                    window.attachedFiles = new Map();
                }
                window.attachedFiles.set(fileReference, draggedFileInfo.path);
                
                resizeTextarea();
                draggedFileInfo = null;
            }
        });

        // Chat scroll behavior management
        let scrollTimeout;
        let scrollThrottleTimeout;
        let lastScrollHandlerTime = 0;
        const SCROLL_THRESHOLD = 50; // 统一使用50px阈值
        const SCROLL_DEBOUNCE_TIME = 300; // 增加防抖时间到300ms
        const SCROLL_THROTTLE_TIME = 100; // 添加100ms节流时间
        
        let autoScrollPending = false;
        let lastAutoScrollTime = 0;
        const AUTO_SCROLL_THROTTLE_TIME = 16; // 自动滚动节流时间16ms（约一帧时间），实现更及时的滚动
        
        // 节流的自动滚动函数
        function throttledAutoScroll(smooth = true) {
            const now = Date.now();
            if (autoScrollPending || (now - lastAutoScrollTime < AUTO_SCROLL_THROTTLE_TIME)) {
                return; // 如果已有滚动在等待或距离上次滚动时间太短，则跳过
            }
            
            autoScrollPending = true;
            lastAutoScrollTime = now;
            
            requestAnimationFrame(() => {
                if (smooth) {
                    chatMessages.scrollTo({
                        top: chatMessages.scrollHeight,
                        behavior: 'smooth'
                    });
                } else {
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
                autoScrollPending = false;
            });
        }
        
        chatMessages.addEventListener('scroll', function() {
            const now = Date.now();
            
            // 节流：限制滚动处理频率
            if (now - lastScrollHandlerTime < SCROLL_THROTTLE_TIME) {
                return;
            }
            lastScrollHandlerTime = now;
            
            // Clear previous timeout
            clearTimeout(scrollTimeout);
            
            // Detect scroll direction
            const currentScrollTop = chatMessages.scrollTop;
            scrollDirection = currentScrollTop > lastScrollTop ? 'down' : 'up';
            lastScrollTop = currentScrollTop;
            
            // Mark user is scrolling
            isUserScrolling = true;
            
            // Check if scrolled near bottom - 使用统一阈值
            const isNearBottom = chatMessages.scrollTop + chatMessages.clientHeight >= chatMessages.scrollHeight - SCROLL_THRESHOLD;
            
            // 智能自动滚动控制逻辑 - 减少状态切换频率
            if (isNearBottom) {
                // 用户滚动到底部附近，自动启用自动滚动功能
                if (!autoScrollEnabled) {
                    autoScrollEnabled = true;
                    updateAutoScrollIndicator();
                    console.log('🔄 User scrolled to bottom, enabling auto-scroll');
                }
                hideScrollToBottomHint();
            } else {
                // 当用户主动向上滚动且距离底部较远时，禁用自动滚动
                const farFromBottom = chatMessages.scrollTop + chatMessages.clientHeight < chatMessages.scrollHeight - (SCROLL_THRESHOLD * 3);
                if (autoScrollEnabled && scrollDirection === 'up' && farFromBottom) {
                    autoScrollEnabled = false;
                    updateAutoScrollIndicator();
                }
                
                // 仅在非自动滚动状态下显示滚动提示
                if (!autoScrollEnabled) {
                    showScrollToBottomHint();
                }
            }
            
            // 增加防抖时间，减少状态重置频率
            scrollTimeout = setTimeout(() => {
                isUserScrolling = false;
            }, SCROLL_DEBOUNCE_TIME);
        });

        // Scroll hint management
        function showScrollToBottomHint() {
            const scrollBtn = document.getElementById('scrollToBottomBtn');
            if (scrollBtn && !scrollBtn.classList.contains('show')) {
                scrollBtn.classList.add('show');
            }
        }

        function hideScrollToBottomHint() {
            const scrollBtn = document.getElementById('scrollToBottomBtn');
            if (scrollBtn && scrollBtn.classList.contains('show')) {
                scrollBtn.classList.remove('show');
            }
            // hideNewMessageIndicator(); // 已禁用 - Also hide new message indicator
        }

        // 新消息指示器功能（已禁用）
        /*
        function showNewMessageIndicator() {
            if (!autoScrollEnabled) {
                newMessageCount++;
                const indicator = document.getElementById('newMessageIndicator');
                const countSpan = document.getElementById('newMessageCount');
                if (indicator && countSpan) {
                    countSpan.textContent = newMessageCount;
                    indicator.classList.add('show');
                }
            }
        }

        function hideNewMessageIndicator() {
            newMessageCount = 0;
            const indicator = document.getElementById('newMessageIndicator');
            if (indicator && indicator.classList.contains('show')) {
                indicator.classList.remove('show');
            }
        }
        */

        /**
         * 更新自动滚动状态指示器 (已移除UI指示器)
         * 根据当前自动滚动状态更新UI指示器的显示和样式
         * @description 当自动滚动启用时显示向下箭头，禁用时显示暂停图标
         */
        function updateAutoScrollIndicator() {
            // Auto-scroll indicator UI has been removed
        }

        /**
         * 滚动到聊天窗口底部
         * @param {boolean} smooth - 是否使用平滑滚动动画，默认为true
         * @description 执行滚动操作后会自动启用自动滚动功能并隐藏滚动提示
         */
        function scrollToBottom(smooth = true) {
            if (smooth) {
                throttledAutoScroll(true);
            } else {
                throttledAutoScroll(false);
            }
            autoScrollEnabled = true;
            updateAutoScrollIndicator();
            hideScrollToBottomHint();
        }

        /**
         * 绑定滚动到底部按钮的点击事件
         * @description 用户点击滚动按钮时，平滑滚动到聊天窗口底部
         */
        const scrollToBottomBtn = document.getElementById('scrollToBottomBtn');
        if (scrollToBottomBtn) {
            scrollToBottomBtn.addEventListener('click', () => {
                scrollToBottom(true);
            });
        }

        /**
         * 绑定新消息提示的点击事件  
         * @description 用户点击新消息提示时，平滑滚动到聊天窗口底部
         */
        const newMessageIndicator = document.getElementById('newMessageIndicator');
        if (newMessageIndicator) {
            newMessageIndicator.addEventListener('click', () => {
                scrollToBottom(true);
            });
        }
        
        /**
         * 工具调用详细显示框的自动滚动控制
         * @description 当鼠标移出框时启用自动滚动，鼠标移入框时禁用自动滚动
         */
        const detailInfoMessages = document.getElementById('detailInfoMessages');
        if (detailInfoMessages) {
            // 鼠标移出框时，启用自动滚动
            detailInfoMessages.addEventListener('mouseleave', function() {
                detailInfoAutoScrollEnabled = true;
                // 立即滚动到底部
                detailInfoMessages.scrollTop = detailInfoMessages.scrollHeight;
            });
            
            // 鼠标移入框时，禁用自动滚动（允许用户查看内容）
            detailInfoMessages.addEventListener('mouseenter', function() {
                detailInfoAutoScrollEnabled = false;
            });
        }
        
        /**
         * 页面离开时清理批处理资源
         * @description 确保在页面卸载前处理完所有排队的消息并清理定时器
         */
        window.addEventListener('beforeunload', function() {
            // 强制处理剩余的批处理消息
            if (messageBatchQueue.length > 0) {
                processBatchMessages();
            }
            
            // 清理定时器
            clearTimeout(batchProcessingTimer);
        });
        
        /**
         * 测试批量消息处理性能
         * @description 开发调试用函数，模拟高频消息场景
         */
        window.testBatchMessagePerformance = function(messageCount = 100, interval = 10) {
            console.log(`🧪 开始测试批量消息性能：${messageCount}条消息，间隔${interval}ms`);
            const startTime = performance.now();
            
            let count = 0;
            const testInterval = setInterval(() => {
                addMessage(`测试消息 ${count + 1}/${messageCount} - ${new Date().toLocaleTimeString()}`, 'info');
                count++;
                
                if (count >= messageCount) {
                    clearInterval(testInterval);
                    
                    // 等待批处理完成后测量结果
                    setTimeout(() => {
                        const endTime = performance.now();
                        const duration = endTime - startTime;
                        console.log(`✅ 测试完成！总用时：${duration.toFixed(2)}ms，平均每条消息：${(duration / messageCount).toFixed(2)}ms`);
                        console.log(`📊 批处理队列当前状态：${messageBatchQueue.length}条消息等待处理`);
                    }, BATCH_DELAY + 100);
                }
            }, interval);
        };

        /**
         * 目录管理 - 刷新目录列表
         * @description 从后端获取最新的工作目录列表并更新UI显示
         * 保持用户的展开/收起状态、目录列表滚动位置和每个展开目录的文件树滚动位置，直接更新列表不显示加载状态
         * @param {boolean} autoSelectFirst - 如果为true且没有已选择的目录，则自动选择第一个目录
         */
                        function refreshDirectories(autoSelectFirst = false) {
            // 设置目录加载状态
            isDirectoryLoading = true;
            // 如果正在连接或已连接，显示刷新目录消息
            if ((isConnecting || isConnected) && directoryList) {
                renderDisconnectedWorkspaceMessage();
            }
            
            // 保存当前展开状态，避免刷新后用户展开的目录被重置
            // 🔧 修复：不仅从expandedDirectories Set中读取，还要从DOM中读取当前真实的展开状态
            // 这样可以确保即使expandedDirectories没有及时更新，也能正确保存展开状态
            const currentExpanded = new Set(expandedDirectories);
            
            // 从DOM中读取所有当前展开的目录（通过检查tree元素是否有'show'类）
            // 🔧 修复：确保在读取DOM状态时，directoryList存在且包含有效的目录项
            if (directoryList && directoryList.children.length > 0) {
                const allDirectoryItems = directoryList.querySelectorAll('[data-dir]');
                allDirectoryItems.forEach(item => {
                    const dirName = item.getAttribute('data-dir');
                    if (dirName) {
                        const treeElement = document.getElementById(`tree-${dirName}`);
                        // 🔧 修复：同时检查'show'类和'expanded'类，确保状态读取完整
                        if (treeElement && (treeElement.classList.contains('show') || item.classList.contains('expanded'))) {
                            // 如果DOM中显示为展开，添加到展开集合中
                            currentExpanded.add(dirName);
                            // 同时更新expandedDirectories Set，确保状态同步
                            expandedDirectories.add(dirName);
                        }
                    }
                });
            }

            // 保存当前滚动位置
            const currentScrollTop = directoryList ? directoryList.scrollTop : 0;

            // 保存所有展开目录的文件树滚动位置
            const fileTreeScrollPositions = {};
            currentExpanded.forEach(dirName => {
                const treeElement = document.getElementById(`tree-${dirName}`);
                if (treeElement) {
                    fileTreeScrollPositions[dirName] = treeElement.scrollTop;
                }
            });

            // Include current user info in API call
            const params = new URLSearchParams();
            if (currentUser && currentUser !== 'default') {
                params.set('api_key', currentUser);
            }

            const headers = {};
            if (currentUser && currentUser !== 'default') {
                headers['X-API-Key'] = currentUser;
            }

            fetch(`/api/output-dirs?${params}`, {
                headers: headers
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // 清空列表并渲染新数据（数据准备好后一次性更新）
                        directoryList.innerHTML = '';
                        // 恢复展开状态 - 只保留仍然存在的目录
                        const validExpanded = new Set();
                        const directoryNames = new Set(data.directories.map(dir => dir.name));
                        currentExpanded.forEach(dirName => {
                            if (directoryNames.has(dirName)) {
                                validExpanded.add(dirName);
                            }
                        });
                        expandedDirectories = validExpanded;
                        
                        // 🔧 修复：重连后从后端恢复selectedDirectory状态
                        // 优先信任前端的selectedDirectory变量（用户可能刚刚点击选择）
                        // 只有在selectedDirectory为空时，才从后端恢复状态
                        if (!selectedDirectory) {
                            // 检查后端返回的目录中是否有is_selected为true的目录
                            const selectedDirFromBackend = data.directories.find(dir => dir.is_selected);
                            if (selectedDirFromBackend && selectedDirFromBackend.name) {
                                console.log(`🔄 Restoring selected directory from backend: ${selectedDirFromBackend.name}`);
                                selectedDirectory = selectedDirFromBackend.name;
                                taskMode = 'selected';
                                // 启动文件监测
                                startFileMonitoring();
                            }
                        } else {
                            // 前端已经有selectedDirectory，验证它是否在后端目录列表中
                            const dirExists = data.directories.some(dir => dir.name === selectedDirectory);
                            if (!dirExists) {
                                // 如果前端选择的目录在后端列表中不存在，清空它
                                console.log(`🔄 Clearing selected directory as it no longer exists: ${selectedDirectory}`);
                                selectedDirectory = null;
                                taskMode = 'new';
                                // 停止文件监测
                                stopFileMonitoring();
                            } else {
                                // 目录存在，确保文件监测已启动
                                startFileMonitoring();
                            }
                        }
                        
                        renderDirectories(data.directories);

                        // 恢复滚动位置和展开状态
                        // 🔧 修复：使用requestAnimationFrame确保DOM完全渲染后再恢复状态
                        requestAnimationFrame(() => {
                            setTimeout(() => {
                                if (directoryList) {
                                    directoryList.scrollTop = currentScrollTop;
                                }

                                // 恢复每个展开目录的文件树滚动位置，并确保展开状态正确应用
                                validExpanded.forEach(dirName => {
                                    const treeElement = document.getElementById(`tree-${dirName}`);
                                    if (treeElement) {
                                        // 确保展开状态正确应用
                                        if (!treeElement.classList.contains('show')) {
                                            treeElement.classList.add('show');
                                        }
                                        const directoryItem = document.querySelector(`[data-dir="${dirName}"]`);
                                        if (directoryItem) {
                                            if (!directoryItem.classList.contains('expanded')) {
                                                directoryItem.classList.add('expanded');
                                            }
                                            // 恢复滚动位置
                                            if (fileTreeScrollPositions[dirName] !== undefined) {
                                                treeElement.scrollTop = fileTreeScrollPositions[dirName];
                                            }
                                            // 更新按钮图标
                                            const button = directoryItem.querySelector('.directory-actions button:first-child');
                                            const icon = button ? button.querySelector('i') : null;
                                            if (icon) {
                                                icon.className = 'fas fa-chevron-up';
                                            }
                                        }
                                    }
                                });
                                
                                // 如果是重连后且没有已选择的目录，自动选择第一个目录
                                if (autoSelectFirst && !selectedDirectory && data.directories && data.directories.length > 0) {
                                    const firstDirectory = data.directories[0].name;
                                    console.log(`🔄 Auto-selecting first directory after reconnect: ${firstDirectory}`);
                                    selectDirectory(firstDirectory);
                                }
                                
                                // 目录加载完成，清除加载状态
                                isDirectoryLoading = false;
                            }, 0);
                        });
                    } else {
                        directoryList.innerHTML = `
                            <div class="message error">
                                <i class="fas fa-exclamation-triangle"></i>
                                ${I18N.load_directory_failed}: ${data.error}
                            </div>
                        `;
                        // 目录加载失败，清除加载状态
                        isDirectoryLoading = false;
                    }
                })
                .catch(error => {
                    directoryList.innerHTML = `
                        <div class="message error">
                            <i class="fas fa-exclamation-triangle"></i>
                            ${I18N.network_error}: ${error.message}
                        </div>
                    `;
                    // 目录加载出错，清除加载状态
                    isDirectoryLoading = false;
                });
        }

        /**
         * 复制文本到剪贴板
         * @param {string} text - 要复制的文本
         * @returns {Promise<boolean>} - 复制是否成功
         */
        async function copyToClipboard(text) {
            try {
                // 尝试使用现代Clipboard API
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(text);
                    return true;
                } else {
                    // 降级方案：使用传统的document.execCommand
                    const textArea = document.createElement('textarea');
                    textArea.value = text;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-999999px';
                    textArea.style.top = '-999999px';
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    const successful = document.execCommand('copy');
                    document.body.removeChild(textArea);
                    return successful;
                }
            } catch (err) {
                console.error('复制失败:', err);
                return false;
            }
        }

        /**
         * 显示复制成功的提示
         * @param {string} message - 提示信息
         * @param {number} x - 鼠标X坐标
         * @param {number} y - 鼠标Y坐标
         */
        function showCopyToast(message, x, y) {
            // 移除可能存在的旧提示
            const existingToast = document.querySelector('.copy-toast');
            if (existingToast) {
                existingToast.remove();
            }

            // 创建新提示
            const toast = document.createElement('div');
            toast.className = 'copy-toast';
            toast.textContent = message || '已拷贝';
            
            // 设置提示位置在鼠标位置上方
            toast.style.left = x + 'px';
            toast.style.top = y + 'px';
            
            document.body.appendChild(toast);

            // 1.5秒后移除提示（与CSS动画时长一致）
            setTimeout(() => {
                toast.remove();
            }, 1500);
        }

        /**
         * 处理任务描述的双击事件
         * @param {MouseEvent} event - 鼠标事件
         * @param {string} text - 要复制的文本
         */
        async function handleTaskDescriptionDoubleClick(event, text) {
            event.stopPropagation(); // 阻止事件冒泡，避免触发目录项点击
            
            // 如果文本是默认值，不复制
            const noTaskText = I18N.no_task_assigned || '未布置任务';
            if (text === noTaskText || text === '未布置任务' || text === 'No task assigned') {
                return;
            }

            const success = await copyToClipboard(text);
            if (success) {
                showCopyToast('已拷贝', event.clientX, event.clientY);
            } else {
                showCopyToast('复制失败', event.clientX, event.clientY);
            }
        }

        /**
         * 渲染目录列表到UI
         * @param {Array} directories - 目录数据数组
         * @description 根据目录数据生成HTML结构，包括：
         * - 目录状态标识（当前执行、已选择、上次使用）
         * - 目录操作按钮（展开/收起、上传、下载、重命名、删除）
         * - 文件树展开状态管理
         */
        function renderDirectories(directories) {
            // 重置子目录ID计数器，确保每次渲染时ID保持一致
            window.subDirIdCounter = 0;
            
            if (directories.length === 0) {
                directoryList.innerHTML = `
                    <div class="message system">
                        <i class="fas fa-folder-open"></i>
                        ${I18N.no_workspace_directories}
                    </div>
                `;
                return;
            }

            directoryList.innerHTML = directories.map(dir => {
                let classes = ['directory-item'];
                let statusText = '';
                
                // 根据目录状态添加相应的CSS类和状态文本
                if (dir.is_current) {
                    classes.push('current');
                    statusText += '<span style="font-size: 0.8em; margin-left: 8px;">(' + I18N.current_executing + ')</span>';
                }
                
                // 优先使用前端的selectedDirectory变量，这样可以确保新建目录后立即高亮正确
                const isSelectedByFrontend = selectedDirectory === dir.name;
                const isSelectedByBackend = dir.is_selected;
                
                if (isSelectedByFrontend || isSelectedByBackend) {
                    classes.push('selected');
                    // 去除"已选择"状态标签，只保留视觉高亮效果
                }
                
                if (dir.is_last && !dir.is_current && !isSelectedByFrontend && !isSelectedByBackend) {
                    classes.push('last');
                    statusText += '<span style="font-size: 0.8em; margin-left: 8px;">(' + I18N.last_used + ')</span>';
                }
                
                // 检查该目录是否应该展开显示文件树
                const isExpanded = expandedDirectories.has(dir.name);
                if (isExpanded) {
                    classes.push('expanded');
                }
                
                // 获取任务描述，如果没有则使用默认值
                const noTaskText = I18N.no_task_assigned || '未布置任务';
                let taskDesc = dir.task_description || noTaskText;
                
                // 如果任务描述是默认值（无论是中文还是英文），统一替换为当前语言的I18N翻译
                if (taskDesc === "未布置任务" || taskDesc === "No task assigned" || taskDesc === noTaskText) {
                    taskDesc = noTaskText;
                } else {
                    // 过滤掉"current request:"前缀（不区分大小写）
                    // 使用正则表达式匹配开头的"current request:"（不区分大小写，允许开头有空白字符）
                    // 匹配模式：开头 + 可选空白 + "current" + 空白 + "request" + 可选空白 + ":" + 可选空白
                    const match = taskDesc.match(/^\s*current\s+request\s*:\s*/i);
                    if (match) {
                        // 去掉匹配到的前缀，保留后面的实际任务描述
                        taskDesc = taskDesc.substring(match[0].length).trim();
                        // 如果过滤后为空，则使用默认值
                        if (!taskDesc) {
                            taskDesc = noTaskText;
                        }
                    }
                }
                
                // 为双击事件转义任务描述中的特殊字符
                const taskDescEscaped = taskDesc.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/\n/g, '\\n').replace(/\r/g, '\\r');
                
                return `
                    <div class="${classes.join(' ')}" data-dir="${dir.name}" onclick="handleDirectoryItemClick(event, '${dir.name}')">
                        <div class="directory-header">
                            <div class="directory-name" style="flex: 1; min-width: 0;">
                                <div style="font-size: 0.9em; color: var(--text-directory-name); opacity: 0.7; margin-bottom: 4px;">
                                    <i class="fas fa-folder" style="font-size: 0.9em;"></i>
                                    <span>${dir.name}</span>
                                    ${statusText}
                                </div>
                                <div class="task-description" 
                                     style="font-size: 0.9em; color: var(--text-task-description); line-height: 1.4; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; word-break: break-word; overflow-wrap: break-word; white-space: normal;" 
                                     ondblclick="handleTaskDescriptionDoubleClick(event, '${taskDescEscaped}')" 
                                     title="双击复制任务描述">
                                    ${taskDesc}
                                </div>
                            </div>
                            <div class="directory-actions">
                                <button class="action-btn" onclick="return toggleDirectory('${dir.name}', event)" title="${I18N.expand_collapse}">
                                    <i class="fas fa-chevron-${isExpanded ? 'up' : 'down'}"></i>
                                </button>
                                <button class="action-btn" onclick="event.stopPropagation(); quickUploadToDirectory('${dir.name}')" title="${I18N.upload_to_workspace}">
                                    <i class="fas fa-upload"></i>
                                </button>
                                <button class="action-btn" onclick="event.stopPropagation(); downloadDirectory('${dir.name}')" title="${I18N.download_as_zip}">
                                    <i class="fas fa-download"></i>
                                </button>
                                <button class="action-btn rename-btn" onclick="event.stopPropagation(); showRenameDialog('${dir.name}')" title="${I18N.rename_directory}">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button class="action-btn delete-btn" onclick="event.stopPropagation(); confirmDeleteDirectory('${dir.name}')" title="${I18N.delete_directory}">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                        <div class="file-tree ${isExpanded ? 'show' : ''}" id="tree-${dir.name}">
                            ${renderFileTree(dir.files, dir.name)}
                        </div>
                    </div>
                `;
            }).join('');
        }

        /**
         * 显示未连接时的工作目录占位提示
         */
        function renderDisconnectedWorkspaceMessage() {
            if (!directoryList) return;
            // 如果正在连接或已连接但目录正在加载，显示刷新目录消息
            if ((isConnecting || isConnected) && isDirectoryLoading) {
                const message = I18N.refreshing_directories || '正在刷新目录';
                directoryList.innerHTML = `
                    <div class="directory-placeholder">${message}</div>
                `;
            } else if (!isConnected && !isConnecting) {
                // 只有在未连接且未在连接中时才显示"请先连接"消息
                const message = I18N.please_connect || '请先连接服务器';
                directoryList.innerHTML = `
                    <div class="directory-placeholder">${message}</div>
                `;
            }
        }

        /**
         * 生成安全的HTML ID，确保中文和特殊字符不会导致DOM查找失败
         * 使用简单的编码方案：将字符串转换为base64，然后替换掉不安全的字符
         */
        function generateSafeId(str) {
            try {
                // 使用btoa进行base64编码，但需要先将UTF-8字符串转换为Latin1
                // 使用encodeURIComponent + btoa的组合来处理UTF-8
                const encoded = btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, 
                    function(match, p1) {
                        return String.fromCharCode('0x' + p1);
                    }));
                // 替换base64中可能有问题的字符（+, /, =）为安全字符
                return 'id_' + encoded.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
            } catch (e) {
                // 如果编码失败，使用简单的替换方案
                console.warn('Failed to encode ID, using fallback:', e);
                return 'id_' + str.replace(/[^a-zA-Z0-9]/g, '_');
            }
        }

        function renderFileTree(files, dirName, indent = 0) {
            return files.map(file => {
                const icon = file.type === 'directory' ? 'fas fa-folder' : getFileIcon(file.name);
                const className = file.type === 'directory' ? 'file-item directory' : 'file-item';
                const isPreviewable = file.type === 'file' && isFilePreviewable(file.name);
                const previewClass = isPreviewable ? ' previewable' : '';
                
                // 检查是否在特定目录下，如果是则添加灰色样式
                const isInSpecialDir = file.path && (
                    file.path.includes('/web_search_result/') || 
                    file.path.includes('/code_index/') ||
                    file.path.includes('\\web_search_result\\') || 
                    file.path.includes('\\code_index\\')
                );
                const grayedClass = (file.type === 'file' && isInSpecialDir) ? ' grayed' : '';
                
                // 构造文件路径 - 后端现在返回相对路径
                let relativePath = '';
                if (file.path) {
                    // 直接使用后端返回的相对路径
                    relativePath = file.path;
                } else {
                    // 如果没有路径，构造路径
                    relativePath = `${dirName}/${file.name}`;
                }
                
                // 为子文件夹生成唯一标识符：使用更简单可靠的方案
                // 使用递增计数器确保每个子目录都有唯一ID，避免编码问题
                if (typeof window.subDirIdCounter === 'undefined') {
                    window.subDirIdCounter = 0;
                }
                const uniqueSubDirId = `subdir_${window.subDirIdCounter++}`;
                const originalSubDirKey = `${dirName}-${file.name}`;
                const hasChildren = file.children && file.children.length > 0;
                // 子文件夹默认收起，只有在expandedSubDirectories中的才展开（使用uniqueSubDirId）
                const isSubDirExpanded = expandedSubDirectories && expandedSubDirectories.has(uniqueSubDirId);
                
                let html = '';
                
                if (file.type === 'directory' && hasChildren) {
                    // 检查是否是不应该自动展开的目录（但仍然可以手动展开）
                    const shouldNotAutoExpand = ['code_index', 'logs', 'web_search_result', 'web_search_results'].includes(file.name.toLowerCase());
                    
                    // 检查是否是workspace目录，如果是则自动展开
                    const isWorkspace = file.name.toLowerCase() === 'workspace';
                    const shouldAutoExpand = isWorkspace;
                    
                    if (shouldNotAutoExpand) {
                        // 对于不应该自动展开的目录，显示展开按钮和删除按钮，但默认收起
                        html = `
                            <div class="file-item directory" style="margin-left: ${indent * 12}px; display: flex; align-items: center; position: relative;">
                                <div style="display: flex; align-items: center; gap: 8px; flex: 1; cursor: pointer; padding-right: 0; overflow: hidden;" 
                                     data-subdir-id="${uniqueSubDirId}" onclick="toggleSubDirectoryById('${uniqueSubDirId}', event)">
                                    <i class="${icon}"></i>
                                    <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${file.name}</span>
                                </div>
                                <div class="file-item-buttons" style="display: flex; align-items: center; gap: 2px;">
                                    <button class="download-file-btn" onclick="downloadFile('${relativePath.replace(/'/g, "\\'")}', '${file.name.replace(/'/g, "\\'")}', true); event.stopPropagation();" title="下载文件夹 | Download folder">
                                        <i class="fas fa-download"></i>
                                    </button>
                                    <button class="delete-file-btn" onclick="showDeleteFolderModal('${relativePath.replace(/'/g, "\\'")}', '${file.name.replace(/'/g, "\\'")}'); event.stopPropagation();" title="删除文件夹 | Delete folder">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                    <button class="sub-folder-toggle" data-subdir-id="${uniqueSubDirId}" onclick="toggleSubDirectoryById('${uniqueSubDirId}', event)" 
                                            style="background: none; border: none; color: #9cdcfe; cursor: pointer; padding: 2px 4px; margin: 0; display: flex; align-items: center; justify-content: center;">
                                        <i class="fas fa-chevron-${isSubDirExpanded ? 'up' : 'down'}" style="font-size: 18px;"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="sub-file-tree ${isSubDirExpanded ? 'show' : ''}" id="subtree-${uniqueSubDirId}">
                                ${renderFileTree(file.children, dirName, indent + 1)}
                            </div>
                        `;
                    } else if (shouldAutoExpand) {
                        // workspace目录：自动展开显示内容，但不展开子文件夹
                        html = `
                            <div class="file-item directory" style="margin-left: ${indent * 12}px; display: flex; align-items: center; position: relative;">
                                <div style="display: flex; align-items: center; gap: 8px; flex: 1; padding-right: 0; overflow: hidden;">
                                    <i class="${icon}"></i>
                                    <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${file.name}</span>
                                </div>
                                <div class="file-item-buttons" style="display: flex; align-items: center; gap: 2px;">
                                    <button class="download-file-btn" onclick="downloadFile('${relativePath.replace(/'/g, "\\'")}', '${file.name.replace(/'/g, "\\'")}', true); event.stopPropagation();" title="下载文件夹 | Download folder">
                                        <i class="fas fa-download"></i>
                                    </button>
                                    <button class="delete-file-btn" onclick="showDeleteFolderModal('${relativePath.replace(/'/g, "\\'")}', '${file.name.replace(/'/g, "\\'")}'); event.stopPropagation();" title="删除文件夹 | Delete folder">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                    <button class="sub-folder-toggle" data-subdir-id="${uniqueSubDirId}" onclick="toggleSubDirectoryById('${uniqueSubDirId}', event)" 
                                            style="background: none; border: none; color: #9cdcfe; cursor: pointer; padding: 2px 4px; margin: 0; display: flex; align-items: center; justify-content: center;">
                                        <i class="fas fa-chevron-up" style="font-size: 18px;"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="sub-file-tree show" id="subtree-${uniqueSubDirId}">
                                ${renderFileTree(file.children, dirName, indent + 1)}
                            </div>
                        `;
                        // 将workspace目录标记为已展开（使用uniqueSubDirId）
                        if (!expandedSubDirectories) {
                            expandedSubDirectories = new Set();
                        }
                        expandedSubDirectories.add(uniqueSubDirId);
                    } else {
                        // 其他子文件夹：带展开/收起功能
                        html = `
                            <div class="file-item directory" style="margin-left: ${indent * 12}px; display: flex; align-items: center; position: relative;">
                                <div style="display: flex; align-items: center; gap: 8px; flex: 1; cursor: pointer; padding-right: 0; overflow: hidden;" 
                                     data-subdir-id="${uniqueSubDirId}" onclick="toggleSubDirectoryById('${uniqueSubDirId}', event)">
                                    <i class="${icon}"></i>
                                    <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${file.name}</span>
                                </div>
                                <div class="file-item-buttons" style="display: flex; align-items: center; gap: 2px;">
                                    <button class="download-file-btn" onclick="downloadFile('${relativePath.replace(/'/g, "\\'")}', '${file.name.replace(/'/g, "\\'")}', true); event.stopPropagation();" title="下载文件夹 | Download folder">
                                        <i class="fas fa-download"></i>
                                    </button>
                                    <button class="delete-file-btn" onclick="showDeleteFolderModal('${relativePath.replace(/'/g, "\\'")}', '${file.name.replace(/'/g, "\\'")}'); event.stopPropagation();" title="删除文件夹 | Delete folder">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                    <button class="sub-folder-toggle" data-subdir-id="${uniqueSubDirId}" onclick="toggleSubDirectoryById('${uniqueSubDirId}', event)" 
                                            style="background: none; border: none; color: #9cdcfe; cursor: pointer; padding: 2px 4px; margin: 0; display: flex; align-items: center; justify-content: center;">
                                        <i class="fas fa-chevron-${isSubDirExpanded ? 'up' : 'down'}" style="font-size: 18px;"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="sub-file-tree ${isSubDirExpanded ? 'show' : ''}" id="subtree-${uniqueSubDirId}">
                                ${renderFileTree(file.children, dirName, indent + 1)}
                            </div>
                        `;
                    }
                } else if (file.type === 'directory') {
                    // 空文件夹
                    html = `
                        <div class="${className}" style="margin-left: ${indent * 12}px; display: flex; align-items: center; position: relative;">
                            <div style="display: flex; align-items: center; gap: 8px; flex: 1; padding-right: 0; overflow: hidden;">
                                <i class="${icon}"></i>
                                <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${file.name}</span>
                            </div>
                            <div class="file-item-buttons" style="display: flex; align-items: center; gap: 2px;">
                                <button class="download-file-btn" onclick="downloadFile('${relativePath.replace(/'/g, "\\'")}', '${file.name.replace(/'/g, "\\'")}', true); event.stopPropagation();" title="下载文件夹 | Download folder">
                                    <i class="fas fa-download"></i>
                                </button>
                                <button class="delete-file-btn" onclick="showDeleteFolderModal('${relativePath.replace(/'/g, "\\'")}', '${file.name.replace(/'/g, "\\'")}'); event.stopPropagation();" title="删除文件夹 | Delete folder">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                    `;
                } else {
                    // 文件
                    // 检查是否是可执行文件（Python, Shell, CMD, Batch等）
                    const fileName = file.name.toLowerCase();
                    const executableExtensions = ['.py', '.sh', '.bash', '.zsh', '.fish', '.cmd', '.bat', '.ps1'];
                    const isExecutableFile = executableExtensions.some(ext => fileName.endsWith(ext));
                    
                    // 获取GUI虚拟终端配置（从模板变量传递）
                    const guiVirtualTerminalEnabled = {{ 'true' if gui_virtual_terminal else 'false' }};
                    
                    const runButtonHtml = (isExecutableFile && guiVirtualTerminalEnabled) ? `
                                <button class="run-file-btn" onclick="runExecutableFile('${relativePath.replace(/'/g, "\\'")}', '${file.name.replace(/'/g, "\\'")}'); event.stopPropagation();" title="运行文件 | Run file">
                                    <i class="fas fa-play"></i>
                                </button>
                            ` : '';
                    
                    html = `
                        <div class="${className}${previewClass}${grayedClass} file-item-container" style="margin-left: ${indent * 12}px; display: flex; align-items: center;"
                             draggable="true" 
                             ondragstart="handleFileDragStart(event, '${relativePath.replace(/'/g, "\\'")}', '${file.name.replace(/'/g, "\\'")}', '${dirName.replace(/'/g, "\\'")}')"
                             ondragend="handleFileDragEnd(event)">
                            <div class="file-content" style="flex: 1; display: flex; align-items: center; gap: 6px; cursor: default; padding-right: 0; overflow: hidden;" 
                                 ${isPreviewable ? `onclick="previewFile('${relativePath.replace(/'/g, "\\'")}', '${file.name.replace(/'/g, "\\'")}')"` : ''}>
                                <i class="${icon}"></i>
                                <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${file.name}</span>
                            </div>
                            <div class="file-item-buttons" style="display: flex; align-items: center; gap: 2px; background: transparent; border: none;">
                                ${runButtonHtml}
                                <button class="download-file-btn" onclick="downloadFile('${relativePath.replace(/'/g, "\\'")}', '${file.name.replace(/'/g, "\\'")}', false); event.stopPropagation();" title="下载文件 | Download file">
                                    <i class="fas fa-download"></i>
                                </button>
                                <button class="delete-file-btn" onclick="showDeleteFileModal('${relativePath.replace(/'/g, "\\'")}', '${file.name.replace(/'/g, "\\'")}'); event.stopPropagation();" title="删除文件 | Delete file">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                    `;
                }
                
                return html;
            }).join('');
        }

        function getFileIcon(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const iconMap = {
                'html': 'fab fa-html5',
                'htm': 'fab fa-html5',
                'css': 'fab fa-css3-alt',
                'js': 'fab fa-js-square',
                'py': 'fab fa-python',
                'md': 'fab fa-markdown',
                'json': 'fas fa-code',
                'txt': 'fas fa-file-alt',
                'log': 'fas fa-file-alt',
                'out': 'fas fa-file-alt',
                'yaml': 'fas fa-code',
                'yml': 'fas fa-code',
                'png': 'fas fa-image',
                'jpg': 'fas fa-image',
                'jpeg': 'fas fa-image',
                'gif': 'fas fa-image',
                'svg': 'fas fa-image',
                'bmp': 'fas fa-image',
                'webp': 'fas fa-image',
                'ico': 'fas fa-image',
                'tex': 'fas fa-file-code'
            };
            return iconMap[ext] || 'fas fa-file';
        }

        function isFilePreviewable(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            return ['html', 'htm', 'md', 'markdown', 'py', 'js', 'jsx', 'ts', 'tsx', 'css', 'json',
                    'txt', 'log', 'yaml', 'yml', 'pdf', 'c', 'cpp', 'cc', 'cxx', 'h', 'hpp',
                    'java', 'go', 'rs', 'php', 'rb', 'sh', 'bash', 'zsh', 'fish', 'ps1', 'bat',
                    'cmd', 'xml', 'sql', 'r', 'scala', 'kt', 'swift', 'dart', 'lua', 'perl', 'pl',
                    'vim', 'dockerfile', 'makefile', 'cmake', 'gradle', 'properties', 'ini', 'cfg',
                    'conf', 'toml', 'mmd', 'out', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'csv',
                    'png', 'jpg', 'jpeg', 'gif', 'svg', 'bmp', 'webp', 'ico', 'tex', 'v'].includes(ext);
        }

        function toggleDirectory(dirName, event) {
            // 阻止事件冒泡（仅当有event时）
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            
            console.log(`🔄 Toggle directory: ${dirName}`);
            console.log(`🔍 Event details:`, event);
            
            // 获取DOM元素
            const tree = document.getElementById(`tree-${dirName}`);
            const directoryItem = document.querySelector(`[data-dir="${dirName}"]`);
            const button = document.querySelector(`[data-dir="${dirName}"] .directory-actions button:first-child`);
            const icon = button ? button.querySelector('i') : null;
            
            console.log(`🔍 DOM elements:`, {
                tree: tree,
                treeId: `tree-${dirName}`,
                directoryItem: directoryItem,
                button: button,
                icon: icon,
                treeClasses: tree ? tree.className : 'null',
                treeStyle: tree ? tree.style.cssText : 'null'
            });
            
            if (!tree) {
                console.error(`❌ Tree element not found: tree-${dirName}`);
                // 尝试查找所有可能的tree元素
                const allTrees = document.querySelectorAll('[id^="tree-"]');
                console.log(`🔍 All tree elements found:`, Array.from(allTrees).map(t => t.id));
                return false;
            }
            
            // 检查当前状态
            const isCurrentlyExpanded = tree.classList.contains('show');
            console.log(`📊 Current state: ${dirName} expanded = ${isCurrentlyExpanded}`);
            console.log(`📊 Tree computed style:`, window.getComputedStyle(tree).display);
            
            if (isCurrentlyExpanded) {
                // 收起 - 不需要检查连接状态，因为这只是UI操作
                tree.classList.remove('show');
                expandedDirectories.delete(dirName);
                if (directoryItem) {
                    directoryItem.classList.remove('expanded');
                }
                if (icon) {
                    icon.className = 'fas fa-chevron-down';
                }
                console.log(`📥 Collapsed: ${dirName}`);
                console.log(`📥 After collapse - display:`, window.getComputedStyle(tree).display);
            } else {
                // 展开 - 需要检查连接状态（连接中不再提示“请先连接”）
                if (!isConnected && !isConnecting) {
                    addMessage(`⚠️ ${I18N.please_connect}`, 'warning');
                    return false;
                }
                
                tree.classList.add('show');
                expandedDirectories.add(dirName);
                if (directoryItem) {
                    directoryItem.classList.add('expanded');
                }
                if (icon) {
                    icon.className = 'fas fa-chevron-up';
                }
                console.log(`📤 Expanded: ${dirName}`);
                console.log(`📤 After expand - display:`, window.getComputedStyle(tree).display);
            }
            
            console.log(`✅ Toggle complete. Tree classes: ${tree.className}`);
            console.log(`✅ Expanded dirs: [${Array.from(expandedDirectories).join(', ')}]`);
            return false;
        }

        function toggleSubDirectoryById(uniqueSubDirId, event) {
            // 阻止事件冒泡
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            
            console.log(`🔄 Toggle sub-directory ID: ${uniqueSubDirId}`);
            
            // 直接使用ID查找DOM元素，无需编码
            const lookupId = `subtree-${uniqueSubDirId}`;
            const subTree = document.getElementById(lookupId);
            const button = event.target.closest('.sub-folder-toggle');
            const icon = button ? button.querySelector('i') : null;
            
            console.log(`🔍 Sub-directory DOM lookup:`, {
                uniqueSubDirId: uniqueSubDirId,
                lookupId: lookupId,
                subTreeFound: !!subTree,
                subTree: subTree,
                button: button,
                icon: icon,
                subTreeClasses: subTree ? subTree.className : 'null'
            });
            
            if (!subTree) {
                console.error(`❌ Sub-tree element not found: ${lookupId}`);
                return false;
            }
            
            // 检查当前状态
            const isCurrentlyExpanded = subTree.classList.contains('show');
            console.log(`📊 Sub-directory current state: expanded = ${isCurrentlyExpanded}`);
            
            if (isCurrentlyExpanded) {
                // 收起子文件夹 - 不需要检查连接状态，因为这只是UI操作
                subTree.classList.remove('show');
                expandedSubDirectories.delete(uniqueSubDirId);
                if (icon) {
                    icon.className = 'fas fa-chevron-down';
                }
                console.log(`📥 Collapsed sub-directory: ${uniqueSubDirId}`);
            } else {
                // 展开子文件夹 - 需要检查连接状态（连接中不再提示“请先连接”）
                if (!isConnected && !isConnecting) {
                    addMessage(`⚠️ ${I18N.please_connect}`, 'warning');
                    return false;
                }
                
                subTree.classList.add('show');
                expandedSubDirectories.add(uniqueSubDirId);
                if (icon) {
                    icon.className = 'fas fa-chevron-up';
                }
                console.log(`📤 Expanded sub-directory: ${uniqueSubDirId}`);
            }
            
            console.log(`✅ Sub-directory toggle complete. Classes: ${subTree.className}`);
            console.log(`✅ Expanded sub-dirs: [${Array.from(expandedSubDirectories).join(', ')}]`);
            return false;
        }

        function downloadDirectory(dirName) {
            // Build URL with API key parameter - use currentUser like other API calls
            let downloadUrl = `/api/download/${dirName}`;
            if (currentUser && currentUser !== 'default') {
                downloadUrl += `?api_key=${encodeURIComponent(currentUser)}`;
            }
            
            const link = document.createElement('a');
            link.href = downloadUrl;
            link.download = `${dirName}.zip`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // 获取GUI虚拟终端配置状态
        function getGuiVirtualTerminalEnabled() {
            // 从模板变量获取配置（在页面加载时设置）
            return typeof window.guiVirtualTerminalEnabled !== 'undefined' ? window.guiVirtualTerminalEnabled : false;
        }

        function runExecutableFile(relativePath, fileName) {
            // 检查配置是否启用
            if (!getGuiVirtualTerminalEnabled()) {
                const lang = typeof I18N !== 'undefined' && I18N.lang === 'zh' ? 'zh' : 'en';
                const message = lang === 'zh' 
                    ? '{{ i18n.get("virtual_terminal_disabled", "配置已禁用，请下载独立版本并在config.txt中配置GUI_virtual_terminal=True") }}'
                    : '{{ i18n.get("virtual_terminal_disabled", "Configuration disabled. Please download the standalone version and set GUI_virtual_terminal=True in config.txt") }}';
                alert(message);
                return;
            }
            
            // 构建要执行的命令
            // 使用相对路径（相对于工作目录），确保路径使用正确的分隔符
            // 将Windows路径分隔符转换为Unix风格（终端会处理）
            const normalizedPath = relativePath.replace(/\\/g, '/');
            const fileNameLower = fileName.toLowerCase();
            
            // 提取脚本所在目录和文件名
            const pathParts = normalizedPath.split('/');
            const scriptName = pathParts[pathParts.length - 1];
            
            // 检查路径中是否包含output_xxx和workspace
            // relativePath可能是完整路径：output_20260104_102756/workspace/subdir/file.py
            // 或者只是workspace之后的部分：subdir/file.py（如果终端已经在workspace）
            const outputDirIndex = pathParts.findIndex(part => part.startsWith('output_'));
            const workspaceIndex = pathParts.indexOf('workspace');
            
            let command;
            let scriptCommand;
            
            // 根据文件扩展名选择相应的命令
            if (fileNameLower.endsWith('.py')) {
                scriptCommand = `python "${scriptName}"`;
            } else if (fileNameLower.endsWith('.sh') || fileNameLower.endsWith('.bash') || fileNameLower.endsWith('.zsh') || fileNameLower.endsWith('.fish')) {
                // Unix/Linux shell脚本
                scriptCommand = `bash "${scriptName}"`;
            } else if (fileNameLower.endsWith('.cmd') || fileNameLower.endsWith('.bat')) {
                // Windows批处理文件
                scriptCommand = `"${scriptName}"`;
            } else if (fileNameLower.endsWith('.ps1')) {
                // PowerShell脚本
                scriptCommand = `powershell -ExecutionPolicy Bypass -File "${scriptName}"`;
            } else {
                // 默认尝试直接执行
                scriptCommand = `"${scriptName}"`;
            }
            
            // 构建cd命令链
            // 如果路径包含output_xxx/workspace，需要先cd到output_xxx/workspace
            // 然后再cd到子目录（如果有）
            if (outputDirIndex !== -1 && workspaceIndex !== -1 && workspaceIndex > outputDirIndex) {
                // 完整路径：output_xxx/workspace/subdir/file.py
                const outputDir = pathParts[outputDirIndex];
                const afterWorkspace = pathParts.slice(workspaceIndex + 1);
                
                if (afterWorkspace.length > 1) {
                    // 文件在workspace的子目录中：需要cd到output_xxx/workspace，然后cd到子目录
                    const subDir = afterWorkspace.slice(0, -1).join('/');
                    command = `cd "${outputDir}/workspace" && cd "${subDir}" && ${scriptCommand}`;
                } else {
                    // 文件直接在workspace目录中：只需要cd到output_xxx/workspace
                    command = `cd "${outputDir}/workspace" && ${scriptCommand}`;
                }
            } else if (workspaceIndex !== -1) {
                // 只有workspace，没有output_xxx（终端可能已经在用户目录）
                // 这种情况应该不会发生，但为了安全还是处理一下
                const afterWorkspace = pathParts.slice(workspaceIndex + 1);
                if (afterWorkspace.length > 1) {
                    const subDir = afterWorkspace.slice(0, -1).join('/');
                    command = `cd "workspace/${subDir}" && ${scriptCommand}`;
                } else {
                    command = `cd "workspace" && ${scriptCommand}`;
                }
            } else {
                // 没有workspace，可能是相对路径（终端已经在workspace）
                const scriptDir = pathParts.slice(0, -1).join('/');
                if (scriptDir && scriptDir !== '.' && scriptDir !== '') {
                    command = `cd "${scriptDir}" && ${scriptCommand}`;
                } else {
                    command = scriptCommand;
                }
            }
            
            // 将命令保存到localStorage，终端窗口会读取并执行
            localStorage.setItem('terminal_auto_command', command);
            localStorage.setItem('terminal_auto_command_timestamp', Date.now().toString());
            
            // 打开终端窗口（使用固定名称，如果已打开则聚焦）
            const terminalWindow = window.open('/terminal', 'agia_terminal', 'width=800,height=600');
            
            // 如果窗口已经存在，尝试发送命令
            if (terminalWindow) {
                // 窗口打开后，等待一下再发送命令
                setTimeout(() => {
                    // 通过postMessage发送命令（如果窗口支持）
                    try {
                        terminalWindow.postMessage({
                            type: 'execute_command',
                            command: command
                        }, '*');
                    } catch (e) {
                        // 如果postMessage失败，终端会从localStorage读取命令
                        console.log('使用localStorage传递命令');
                    }
                }, 500);
            }
        }
        
        // 保留runPythonFile函数以保持向后兼容
        function runPythonFile(relativePath, fileName) {
            runExecutableFile(relativePath, fileName);
        }

        function downloadFile(relativePath, fileName, isFolder) {
            // 构建下载URL
            let downloadUrl;
            if (isFolder) {
                // 对于文件夹，使用下载目录API（/api/download/<path:dir_name>）
                downloadUrl = `/api/download/${encodeURIComponent(relativePath)}`;
                // 添加API密钥参数
                if (currentUser && currentUser !== 'default') {
                    downloadUrl += `?api_key=${encodeURIComponent(currentUser)}`;
                }
            } else {
                // 对于文件，使用下载文件API
                downloadUrl = `/api/download-file/${encodeURIComponent(relativePath)}`;
                // 添加API密钥参数
                if (currentUser && currentUser !== 'default') {
                    downloadUrl += `?api_key=${encodeURIComponent(currentUser)}`;
                }
            }
            
            // 创建隐藏的链接并触发下载
            const link = document.createElement('a');
            link.href = downloadUrl;
            link.download = isFolder ? `${fileName}.zip` : fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }



        function confirmDeleteDirectory(dirName) {
            const isCurrentDir = document.querySelector(`[data-dir="${dirName}"]`).classList.contains('current');
            const isSelectedDir = document.querySelector(`[data-dir="${dirName}"]`).classList.contains('selected');
            
            let warningMessage = `${I18N.confirm_delete_directory} "${dirName}"?\n\n${I18N.delete_warning}`;
            
            if (isCurrentDir) {
                warningMessage += '\n\n' + I18N.delete_current_executing_warning;
            }
            if (isSelectedDir) {
                warningMessage += '\n\n' + I18N.delete_selected_warning;
            }
            
            if (confirm(warningMessage)) {
                deleteDirectory(dirName);
            }
        }

        function deleteDirectory(dirName) {
            // 检查guest用户权限
            if (isGuest) {
                alert(I18N.guest_cannot_delete);
                return;
            }
            
            console.log(`🗑️ Deleting directory: ${dirName}`);
            
            // 显示删除中状态
            const dirElement = document.querySelector(`[data-dir="${dirName}"]`);
            if (dirElement) {
                dirElement.style.opacity = '0.5';
                dirElement.style.pointerEvents = 'none';
                
                // 在目录名后添加删除中提示
                const nameElement = dirElement.querySelector('.directory-name');
                if (nameElement && !nameElement.querySelector('.deleting-indicator')) {
                    const indicator = document.createElement('span');
                    indicator.className = 'deleting-indicator';
                    indicator.style.cssText = 'color: #ff6b6b; font-size: 0.8em; margin-left: 8px;';
                    indicator.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${I18N.deleting}`;
                    nameElement.appendChild(indicator);
                }
            }
            
            const headers = {};
            if (currentUser && currentUser !== 'default') {
                headers['X-API-Key'] = currentUser;
            }
            
            fetch(`/api/delete-directory/${dirName}`, {
                method: 'DELETE',
                headers: headers
            })
            .then(response => response.json())
            .then(data => {
                console.log('🗑️ Delete response:', data);
                if (data.success) {
                    console.log(`✅ Directory deleted successfully: ${dirName}`);
                    // 从DOM中移除目录元素
                    if (dirElement) {
                        dirElement.remove();
                    }
                    // 清理相关状态
                    expandedDirectories.delete(dirName);
                    // 清理子目录状态
                    Array.from(collapsedSubDirectories).forEach(subDirId => {
                        if (subDirId.startsWith(dirName + '-')) {
                            collapsedSubDirectories.delete(subDirId);
                        }
                    });
                    // 清理展开的子目录状态
                    Array.from(expandedSubDirectories).forEach(subDirId => {
                        if (subDirId.startsWith(dirName + '-')) {
                            expandedSubDirectories.delete(subDirId);
                        }
                    });
                    // 如果删除的是当前选择的目录，清理状态
                    if (selectedDirectory === dirName) {
                        selectedDirectory = null;
                        taskMode = 'new';
                        // 停止文件监测
                        stopFileMonitoring();
                        // Update agent view button state
                        updateAgentViewButtonState();
                    }

                    // 删除成功，不显示任何消息
                } else {
                    console.error('❌ Delete failed:', data.error);
                    alert(`删除失败: ${data.error}`);
                    // 恢复目录元素状态
                    if (dirElement) {
                        dirElement.style.opacity = '1';
                        dirElement.style.pointerEvents = 'auto';
                        const indicator = dirElement.querySelector('.deleting-indicator');
                        if (indicator) {
                            indicator.remove();
                        }
                    }
                }
            })
            .catch(error => {
                console.error('❌ Delete error:', error);
                alert(`删除出错: ${error.message}`);
                // 恢复目录元素状态
                if (dirElement) {
                    dirElement.style.opacity = '1';
                    dirElement.style.pointerEvents = 'auto';
                    const indicator = dirElement.querySelector('.deleting-indicator');
                    if (indicator) {
                        indicator.remove();
                    }
                }
            });
        }

        // 文件预览功能
        function previewFile(filePath, fileName) {
            console.log('🔍 Preview file called with:', filePath, fileName);
            console.log('🔍 Preview modal elements:', {
                previewModal: previewModal,
                previewTitle: previewTitle,
                previewContent: previewContent
            });
            
            if (!previewModal || !previewTitle || !previewContent) {
                console.error('❌ Preview modal elements not found');
                return;
            }
            
            // 存储当前文件路径，用于Office预览返回功能
            currentFilePath = filePath;
            
            // 截断文件名到50字符以内
            const truncatedFileName = fileName.length > 50 ? fileName.substring(0, 50) + '...' : fileName;
            previewTitle.textContent = `${I18N.preview}: ${truncatedFileName}`;
            previewTitle.title = `${I18N.preview}: ${fileName}`; // 完整文件名作为tooltip
            previewContent.innerHTML = `<div style="text-align: center; padding: 20px;"><i class="fas fa-spinner fa-spin"></i> ${I18N.loading}</div>`;
            previewModal.style.display = 'block';
            
            console.log('🔍 Making API request to:', `/api/file/${filePath}`);

            const headers = {};
            if (currentUser && currentUser !== 'default') {
                headers['X-API-Key'] = currentUser;
            }

            // 检查文件扩展名来决定如何处理响应
            const fileExt = fileName.toLowerCase().split('.').pop();
            const imageExtensions = ['png', 'jpg', 'jpeg', 'gif', 'bmp', 'webp', 'svg'];
            const isImageFile = imageExtensions.includes(fileExt);

            fetch(`/api/file/${filePath}`, {
                headers: headers
            })
                .then(response => {
                    console.log('🔍 API response status:', response.status, response.statusText);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    // 对于图像文件，检查响应类型
                    if (isImageFile) {
                        const contentType = response.headers.get('content-type');
                        console.log('🔍 Content-Type:', contentType);
                        
                        if (contentType && contentType.startsWith('image/')) {
                            // 直接显示图像
                            return response.blob().then(blob => {
                                const imageUrl = URL.createObjectURL(blob);
                                displayImageContent(imageUrl, fileName, filePath);
                            });
                        } else {
                            // 如果返回的是JSON格式的图像数据，则解析JSON
                            return response.json().then(data => {
                                if (data.success && data.type === 'image') {
                                    displayFileContent(data, fileName);
                                } else {
                                    throw new Error('Invalid image data format');
                                }
                            });
                        }
                    }
                    
                    // 对于其他文件类型，尝试解析JSON
                    return response.json();
                })
                .then(data => {
                    if (isImageFile) {
                        // 图像已经处理完成
                        return;
                    }
                    
                    console.log('🔍 Preview response data:', data);
                    if (data.success) {
                        displayFileContent(data, fileName);
                    } else {
                        console.error('❌ Preview failed:', data.error);
                        previewContent.innerHTML = `<div style="color: red; text-align: center; padding: 20px;">
                            <i class="fas fa-exclamation-triangle"></i> 
                            预览失败: ${data.error}
                        </div>`;
                    }
                })
                .catch(error => {
                    console.error('❌ Preview error:', error);
                    previewContent.innerHTML = `<div style="color: red; text-align: center; padding: 20px;">
                        <i class="fas fa-exclamation-triangle"></i> 
                        ${I18N.network_error}: ${error.message}
                    </div>`;
                });
        }

        // 全局变量：存储当前文件夹的图像列表
        window.currentImageList = [];
        window.currentImageIndex = -1;
        
        // 获取同文件夹下的所有图像文件
        async function loadImagesInFolder(filePath) {
            try {
                // 从文件路径中提取目录路径
                const dirPath = filePath.substring(0, filePath.lastIndexOf('/'));
                const fileName = filePath.substring(filePath.lastIndexOf('/') + 1);
                
                // 图像文件扩展名
                const imageExtensions = ['.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp', '.svg', '.ico'];
                
                console.log('🖼️ Loading images from directory:', dirPath);
                
                // 调用API获取目录下的文件列表
                const apiKeyParam = (currentUser && currentUser !== 'default') ? `?api_key=${currentUser}` : '';
                const response = await fetch(`/api/list-directory${apiKeyParam}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        path: dirPath,
                        api_key: currentUser !== 'default' ? currentUser : undefined
                    })
                });
                
                const data = await response.json();
                
                if (data.success && data.files) {
                    // 过滤出图像文件并排序
                    const imagesInFolder = data.files
                        .filter(item => {
                            if (item.type !== 'file') return false;
                            const fileExt = item.name.toLowerCase().substring(item.name.lastIndexOf('.'));
                            return imageExtensions.includes(fileExt);
                        })
                        .map(item => dirPath ? `${dirPath}/${item.name}` : item.name)
                        .sort();
                    
                    window.currentImageList = imagesInFolder;
                    let foundIndex = imagesInFolder.indexOf(filePath);
                    // 如果找不到，尝试只匹配文件名
                    if (foundIndex === -1) {
                        const fileName = filePath.substring(filePath.lastIndexOf('/') + 1);
                        foundIndex = imagesInFolder.findIndex(img => img.endsWith(fileName));
                    }
                    // 如果还是找不到，默认设为0
                    window.currentImageIndex = foundIndex >= 0 ? foundIndex : 0;
                    
                    console.log('🖼️ Found images in folder:', imagesInFolder);
                    console.log('🖼️ Current image index:', window.currentImageIndex);
                    console.log('🖼️ Total images:', imagesInFolder.length);
                } else {
                    console.warn('⚠️ Failed to load directory:', data.error);
                    window.currentImageList = [filePath];
                    window.currentImageIndex = 0;
                }
                
            } catch (error) {
                console.error('❌ Error loading images in folder:', error);
                window.currentImageList = [filePath];
                window.currentImageIndex = 0;
            }
            
            // 加载完成后更新按钮状态
            setTimeout(() => {
                updateNavigationButtons();
            }, 50);
        }
        
        // 切换到上一张图片
        function navigateToPreviousImage() {
            if (window.currentImageList.length === 0 || window.currentImageIndex <= 0) {
                alert(I18N?.lang === 'zh' ? '已经是第一张图片了' : 'This is the first image');
                return;
            }
            
            window.currentImageIndex--;
            const nextFilePath = window.currentImageList[window.currentImageIndex];
            const nextFileName = nextFilePath.substring(nextFilePath.lastIndexOf('/') + 1);
            
            // 重新加载图片
            previewFile(nextFilePath, nextFileName);
        }
        
        // 切换到下一张图片
        function navigateToNextImage() {
            if (window.currentImageList.length === 0 || window.currentImageIndex >= window.currentImageList.length - 1) {
                alert(I18N?.lang === 'zh' ? '已经是最后一张图片了' : 'This is the last image');
                return;
            }
            
            window.currentImageIndex++;
            const nextFilePath = window.currentImageList[window.currentImageIndex];
            const nextFileName = nextFilePath.substring(nextFilePath.lastIndexOf('/') + 1);
            
            // 重新加载图片
            previewFile(nextFilePath, nextFileName);
        }
        
        function displayImageContent(imageUrl, fileName, filePath) {
            // 设置全局变量以便下载使用
            window.currentActualFilePath = filePath;
            window.currentOriginalFilePath = filePath;
            
            // 保存当前预览的文件路径，用于保存后刷新
            window.currentPreviewFilePath = filePath;
            window.currentPreviewFileName = fileName;
            
            // 加载同文件夹下的所有图像
            loadImagesInFolder(filePath);
            
            // 检查是否是SVG文件
            const fileExt = fileName.toLowerCase().split('.').pop();
            const isSvgFile = fileExt === 'svg';
            
            // 获取文件大小信息（如果需要的话）
            const fileSize = '未知大小';
            
            // 构建编辑按钮HTML（仅SVG文件显示）
            // 转义filePath中的单引号，避免JavaScript错误
            const escapedFilePath = filePath.replace(/'/g, "\\'");
            const editButtonHtml = isSvgFile ? `
                <button onclick="openSvgEditor('${escapedFilePath}')" style="padding: 8px 16px; background: #ff9800; color: white; border: none; border-radius: 4px; font-size: 18px; cursor: pointer;">
                    <i class="fas fa-edit"></i> ${I18N?.lang === 'zh' ? '编辑SVG' : 'Edit SVG'}
                </button>
            ` : '';
            
            previewContent.innerHTML = `
                <div style="background: #f8f8f8; padding: 10px; border-radius: 5px; margin-bottom: 10px; font-size: 18px; color: #666;">
                    ${I18N.file_size || 'File Size'}: ${fileSize} | ${I18N.type_label || 'Type'}: ${I18N.image || 'Image'}
                </div>
                <div style="text-align: center; padding: 20px;">
                    <div class="preview-button-group" style="margin-bottom: 15px; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                        <button onclick="navigateToPreviousImage()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; font-size: 18px; cursor: pointer;" id="prevImageBtn">
                            <i class="fas fa-chevron-left"></i> 上一张
                        </button>
                        <button onclick="navigateToNextImage()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; font-size: 18px; cursor: pointer;" id="nextImageBtn">
                            下一张 <i class="fas fa-chevron-right"></i>
                        </button>
                        ${editButtonHtml}
                        <a href="/api/download-file/${filePath}${(currentUser && currentUser !== 'default') ? '?api_key=' + currentUser : ''}" download style="padding: 8px 16px; background: #007acc; color: white; text-decoration: none; border-radius: 4px; font-size: 18px;">
                            <i class="fas fa-download"></i> 下载图片
                        </a>
                        <button onclick="window.open('${imageUrl}', '_blank')" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; font-size: 18px; cursor: pointer;">
                            <i class="fas fa-external-link-alt"></i> 新窗口打开
                        </button>
                    </div>
                    <img src="${imageUrl}" 
                         alt="${fileName}" 
                         style="max-width: 100%; max-height: calc(90vh - 200px); border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); background: white; padding: 10px; display: block; margin: 0 auto;"
                         onerror="this.style.display='none'; this.parentNode.innerHTML='<div style=&quot;color: red; padding: 40px;&quot;><i class=&quot;fas fa-exclamation-triangle&quot;></i><br/>图片加载失败</div>';" />
                </div>
            `;
            
            // 延迟更新按钮状态，确保DOM已渲染
            setTimeout(() => {
                updateNavigationButtons();
            }, 100);
        }
        
        // 更新导航按钮的状态
        function updateNavigationButtons() {
            const prevBtn = document.getElementById('prevImageBtn');
            const nextBtn = document.getElementById('nextImageBtn');
            
            if (prevBtn && nextBtn) {
                // 确保currentImageList和currentImageIndex有有效值
                const imageList = window.currentImageList || [];
                const currentIndex = window.currentImageIndex >= 0 ? window.currentImageIndex : 0;
                
                // 禁用/启用上一张按钮
                if (currentIndex <= 0 || imageList.length <= 1) {
                    prevBtn.disabled = true;
                    prevBtn.style.opacity = '0.5';
                    prevBtn.style.cursor = 'not-allowed';
                } else {
                    prevBtn.disabled = false;
                    prevBtn.style.opacity = '1';
                    prevBtn.style.cursor = 'pointer';
                }
                
                // 禁用/启用下一张按钮
                if (currentIndex >= imageList.length - 1 || imageList.length <= 1) {
                    nextBtn.disabled = true;
                    nextBtn.style.opacity = '0.5';
                    nextBtn.style.cursor = 'not-allowed';
                } else {
                    nextBtn.disabled = false;
                    nextBtn.style.opacity = '1';
                    nextBtn.style.cursor = 'pointer';
                }
            }
        }

        function displayFileContent(data, fileName) {
            const { content, type, language, size, file_path } = data;
            // 如果API没有返回file_path，则使用全局变量currentFilePath作为备用
            let actualFilePath = file_path || currentFilePath;
            
            // 新的用户认证系统：后端会自动处理用户目录，前端不需要添加前缀
            
            // 设置全局变量以便PDF下载使用
            window.currentActualFilePath = actualFilePath;
            // 同时保存原始路径用于预览
            window.currentOriginalFilePath = file_path || currentFilePath;
            
            console.log('🔍 displayFileContent调试信息:');
            console.log('  API返回的file_path:', file_path);
            console.log('  当前的currentFilePath:', currentFilePath);
            console.log('  当前用户:', currentUser);
            console.log('  用户认证系统:', '新系统 - 后端自动处理');
            console.log('  最终的actualFilePath（用于下载）:', actualFilePath);
            console.log('  原始文件路径（用于预览）:', window.currentOriginalFilePath);
            console.log('  文件类型:', type);
            console.log('  设置的全局变量window.currentActualFilePath:', window.currentActualFilePath);
            
            if (type === 'html') {
                // 处理转义字符
                let processedContent = processFileContent(content);
                
                // 处理HTML中的相对路径图片
                const originalFilePath = window.currentOriginalFilePath || file_path || currentFilePath;
                if (originalFilePath) {
                    // 获取HTML文件的目录路径
                    const currentDir = originalFilePath.substring(0, originalFilePath.lastIndexOf('/'));
                    
                    // 处理img标签中的src属性
                    processedContent = processedContent.replace(/<img([^>]+)src\s*=\s*["']([^"']+)["']([^>]*>)/gi, function(match, beforeSrc, src, afterSrc) {
                        // 只处理相对路径的图片
                        if (!src.startsWith('http') && !src.startsWith('data:') && !src.startsWith('/api/') && !src.startsWith('/')) {
                            let imagePath;
                            if (src.startsWith('./')) {
                                imagePath = `${currentDir}/${src.substring(2)}`;
                            } else if (src.startsWith('../')) {
                                const pathParts = currentDir.split('/');
                                let relativeParts = src.split('/');
                                for (let part of relativeParts) {
                                    if (part === '..') {
                                        pathParts.pop();
                                    } else if (part !== '.' && part !== '') {
                                        pathParts.push(part);
                                    }
                                }
                                imagePath = pathParts.join('/');
                            } else {
                                // 普通相对路径，直接拼接
                                imagePath = `${currentDir}/${src}`;
                            }
                            
                            // 添加API key参数
                            const apiKeyParam = (currentUser && currentUser !== 'default') ? `?api_key=${currentUser}` : '';
                            const newSrc = `/api/file/${imagePath}${apiKeyParam}`;
                            console.log('HTML image converted:', src, 'to:', newSrc);
                            return `<img${beforeSrc}src="${newSrc}"${afterSrc}`;
                        }
                        return match;
                    });
                }
                
                // 使用新的HTML预览方式，支持相对路径资源加载
                const apiKeyParam = (currentUser && currentUser !== 'default') ? `?api_key=${currentUser}` : '';
                const previewUrl = `/api/html-preview/${file_path}${apiKeyParam}`;
                
                previewContent.innerHTML = `
                    <div style="background: #f8f8f8; padding: 10px; border-radius: 5px; margin-bottom: 5px; font-size: 18px; color: #666;">
                        ${I18N.file_size || 'File Size'}: ${size} | ${I18N.type_label || 'Type'}: HTML

                    </div>
                    <iframe src="${previewUrl}" style="width: 100%; height: calc(90vh - 160px); border: none; border-radius: 4px; background: white;"></iframe>
                `;
            } else if (type === 'markdown') {
                // 处理转义字符
                const processedContent = processFileContent(content);
                
                // 配置marked.js以支持更好的渲染
                const renderer = new marked.Renderer();
                // 渲染前重置图片计数映射（用于精确替换第N次出现的链接）
                window._mdHrefOccurrenceMap = {};
                
                // 自定义图像渲染，处理相对路径
                renderer.image = function(href, title, text) {
                    let src = href;
                    
                    // 使用原始文件路径进行图片路径计算（不包含用户目录前缀）
                    const originalFilePath = window.currentOriginalFilePath || file_path || currentFilePath;
                    
                    // 只有在originalFilePath存在时才进行路径转换
                    if (originalFilePath && href && !href.startsWith('http') && !href.startsWith('data:') && !href.startsWith('/api/')) {
                        // 获取markdown文件的目录路径
                        const currentDir = originalFilePath.substring(0, originalFilePath.lastIndexOf('/'));
                        
                        let imagePath;
                        if (href.startsWith('./')) {
                            imagePath = `${currentDir}/${href.substring(2)}`;
                        } else if (href.startsWith('../')) {
                            const pathParts = currentDir.split('/');
                            let relativeParts = href.split('/');
                            for (let part of relativeParts) {
                                if (part === '..') {
                                    pathParts.pop();
                                } else if (part !== '.' && part !== '') {
                                    pathParts.push(part);
                                }
                            }
                            imagePath = pathParts.join('/');
                        } else {
                            // 普通相对路径，直接拼接
                            imagePath = `${currentDir}/${href}`;
                        }
                        
                        // Add API key parameter if available
                        const apiKeyParam = (currentUser && currentUser !== 'default') ? `?api_key=${currentUser}` : '';
                        src = `/api/file/${imagePath}${apiKeyParam}`;
                        console.log('Markdown image converted:', href, 'to:', src);
                    }
                    
                    const titleAttr = title ? ` title="${title}"` : '';
                    // 计算当前href在markdown文本中的出现序号，用于后续仅替换对应一次
                    let occIndex = 0;
                    if (href) {
                        occIndex = window._mdHrefOccurrenceMap[href] || 0;
                        window._mdHrefOccurrenceMap[href] = occIndex + 1;
                    }

                    // 检查是否为SVG文件或SVG相关图片
                    const isSvgFile = src && (
                        src.toLowerCase().endsWith('.svg') || 
                        src.includes('.svg') ||
                        src.toLowerCase().includes('svg_') ||
                        (text && text.toLowerCase().includes('svg'))
                    );
                    
                    // 检查是否为其他图片格式（PNG、JPG等）
                    const isOtherImage = src && (
                        src.toLowerCase().endsWith('.png') || 
                        src.toLowerCase().endsWith('.jpg') || 
                        src.toLowerCase().endsWith('.jpeg') || 
                        src.toLowerCase().endsWith('.gif') || 
                        src.toLowerCase().endsWith('.bmp') || 
                        src.toLowerCase().endsWith('.webp')
                    );
                    
                    // 检查是否为网上下载的图片或需要显示控制按钮的图片
                    const isWebSearchImage = href && href.startsWith('web_search_result/images');
                    const shouldShowControls = isWebSearchImage || isSvgFile || isOtherImage;
                    
                    if (shouldShowControls) {
                        const originalFilePath = window.currentOriginalFilePath || file_path || currentFilePath || '';
                        const currentDir = originalFilePath && originalFilePath.includes('/') ? originalFilePath.substring(0, originalFilePath.lastIndexOf('/')) : '';
                        const containerStyle = 'display: flex; align-items: flex-start; gap: 8px; position: relative; width: 100%;';
                        const imgStyle = 'width: 85%; height: auto; border-radius: 4px; margin: 10px 0; object-fit: contain;';
                        const btnStyle = 'background: #007acc; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px; white-space: nowrap; height: fit-content; transition: background-color 0.2s;';
                        const btnDangerStyle = 'background: #d32f2f; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px; white-space: nowrap; height: fit-content; transition: background-color 0.2s;';
                        const btnOptimizeStyle = 'background: #28a745; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px; white-space: nowrap; height: fit-content; transition: background-color 0.2s;';
                        
                        let buttonsHtml = '';
                        
                        if (isWebSearchImage) {
                            // 网上下载的图片：显示上一张、下一张、删除按钮
                            buttonsHtml = `<button class=\"md-prev-btn\" style=\"${btnStyle}\" title=\"上一张\" onclick=\"prevWebSearchImage(this)\" data-md-href=\"${href}\" data-md-occurrence=\"${occIndex}\" data-md-basedir=\"${currentDir}\" onmouseover=\"this.style.backgroundColor='#005a9e'\" onmouseout=\"this.style.backgroundColor='#007acc'\"><i class=\\\"fas fa-chevron-left\\\"></i> 上一张</button>`
                                        + `<button class=\"md-next-btn\" style=\"${btnStyle}\" title=\"下一张\" onclick=\"nextWebSearchImage(this)\" data-md-href=\"${href}\" data-md-occurrence=\"${occIndex}\" data-md-basedir=\"${currentDir}\" onmouseover=\"this.style.backgroundColor='#005a9e'\" onmouseout=\"this.style.backgroundColor='#007acc'\"><i class=\\\"fas fa-chevron-right\\\"></i> 下一张</button>`
                                        + `<button class=\"md-remove-btn\" style=\"${btnDangerStyle}\" title=\"删除此图\" onclick=\"removeWebSearchImage(this)\" data-md-href=\"${href}\" data-md-occurrence=\"${occIndex}\" onmouseover=\"this.style.backgroundColor='#b71c1c'\" onmouseout=\"this.style.backgroundColor='#d32f2f'\"><i class=\\\"fas fa-trash\\\"></i> ${I18N.delete_svg || '删除'}</button>`;
                        } else if (isSvgFile) {
                            // SVG文件：显示编辑、润色、恢复、删除按钮
                            const btnEditStyle = 'background: #6f42c1; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px; white-space: nowrap; height: fit-content; transition: background-color 0.2s;';
                            const btnAiOptimizeStyle = 'background: #7c4dff; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px; white-space: nowrap; height: fit-content; transition: background-color 0.2s;';
                            buttonsHtml = `<button class=\"md-edit-svg-btn\" style=\"${btnEditStyle}\" title=\"${I18N.edit_svg_tooltip || '编辑SVG图'}\" onclick=\"editSvgImage(this)\" data-md-href=\"${href}\" data-md-src=\"${src}\" data-md-occurrence=\"${occIndex}\" onmouseover=\"this.style.backgroundColor='#5a2d91'\" onmouseout=\"this.style.backgroundColor='#6f42c1'\"><i class=\\\"fas fa-edit\\\"></i> ${I18N.edit_svg || '编辑'}</button>`
                                        + `<button class=\"md-ai-optimize-svg-btn\" style=\"${btnAiOptimizeStyle}\" title=\"${I18N.ai_optimize_svg_tooltip || 'AI智能重新设计SVG图'}\" onclick=\"optimizeSvgImageWithLLM(this)\" data-md-href=\"${href}\" data-md-src=\"${src}\" data-md-occurrence=\"${occIndex}\" onmouseover=\"this.style.backgroundColor='#5e35b1'\" onmouseout=\"this.style.backgroundColor='#7c4dff'\"><i class=\\\"fas fa-robot\\\"></i> ${I18N.ai_optimize_svg || 'AI润色'}</button>`
                                        + `<button class=\"md-restore-svg-btn\" style=\"background: #ff9800; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px; white-space: nowrap; height: fit-content; transition: background-color 0.2s;\" title=\"${I18N.restore_svg_tooltip || '恢复原图'}\" onclick=\"restoreSvgImage(this)\" data-md-href=\"${href}\" data-md-src=\"${src}\" data-md-occurrence=\"${occIndex}\" onmouseover=\"this.style.backgroundColor='#f57c00'\" onmouseout=\"this.style.backgroundColor='#ff9800'\"><i class=\\\"fas fa-undo\\\"></i> ${I18N.restore_svg || '恢复'}</button>`
                                        + `<button class=\"md-remove-svg-btn\" style=\"${btnDangerStyle}\" title=\"${I18N.delete_svg_tooltip || '删除SVG图'}\" onclick=\"removeSvgImage(this)\" data-md-href=\"${href}\" data-md-src=\"${src}\" data-md-occurrence=\"${occIndex}\" onmouseover=\"this.style.backgroundColor='#b71c1c'\" onmouseout=\"this.style.backgroundColor='#d32f2f'\"><i class=\\\"fas fa-trash\\\"></i> ${I18N.delete_svg || '删除'}</button>`;
                        } else if (isOtherImage) {
                            // PNG、JPG等其他图片：只显示删除按钮
                            buttonsHtml = `<button class=\"md-remove-image-btn\" style=\"${btnDangerStyle}\" title=\"删除此图\" onclick=\"removeImageFromMarkdown(this)\" data-md-href=\"${href}\" data-md-src=\"${src}\" data-md-occurrence=\"${occIndex}\" onmouseover=\"this.style.backgroundColor='#b71c1c'\" onmouseout=\"this.style.backgroundColor='#d32f2f'\"><i class=\\\"fas fa-trash\\\"></i> ${I18N.delete_svg || '删除'}</button>`;
                        }
                        
                        return `<div class=\"md-img-switch\" style=\"${containerStyle}\">`
                             + `<img src=\"${src}\" alt=\"${text || ''}\"${titleAttr} style=\"${imgStyle}\" data-md-href=\"${href}\" data-md-src=\"${src}\" data-md-occurrence=\"${occIndex}\">`
                             + `<div class=\"md-img-actions\" style=\"display: flex; flex-direction: column; gap: 8px; margin: 10px 0; flex: 1; padding: 8px; max-width: 15%;\">`
                             + buttonsHtml
                             + `</div>`
                             + `</div>`;
                    }

                    return `<img src="${src}" alt="${text || ''}"${titleAttr} style="width: 85%; height: auto; border-radius: 4px; margin: 10px 0; object-fit: contain;">`;
                };
                
                // 自定义代码块渲染
                renderer.code = function(code, language) {
                    const validLanguage = language && typeof language === 'string' ? language : 'text';
                    const escapedCode = escapeHtml(code);
                    
                    // 检查是否为mermaid代码块，直接在预览中渲染
                    if (validLanguage.toLowerCase() === 'mermaid') {
                        // 为mermaid图表生成唯一ID
                        const mermaidId = 'mermaid-' + Math.random().toString(36).substr(2, 9);
                        return `<div class="mermaid-container" style="background: #ffffff; border: 1px solid #e0e0e0; border-radius: 6px; padding: 16px; margin: 16px 0; text-align: center;">
                            <div class="mermaid" id="${mermaidId}">${code}</div>
                        </div>`;
                    }
                    
                    return `<pre class="language-${validLanguage}" style="background: #1e1e1e; border: 1px solid #404040; border-radius: 6px; padding: 16px; overflow-x: auto; margin: 16px 0;"><code class="language-${validLanguage}" style="color: #ffffff !important; font-weight: normal !important; font-size: 14px !important; background: transparent !important;">${escapedCode}</code></pre>`;
                };
                
                // 自定义链接渲染，确保链接正确闭合
                renderer.link = function(href, title, text) {
                    const titleAttr = title ? ` title="${title}"` : '';
                    const target = href.startsWith('http') ? ' target="_blank" rel="noopener noreferrer"' : '';
                    return `<a href="${href}"${titleAttr}${target}>${text}</a>`;
                };
                
                // 配置marked选项
                marked.setOptions({
                    renderer: renderer,
                    highlight: function(code, lang) {
                        if (typeof Prism !== 'undefined' && lang && Prism.languages[lang]) {
                            try {
                                return Prism.highlight(code, Prism.languages[lang], lang);
                            } catch (e) {
                                console.warn('Prism highlighting failed:', e);
                                return escapeHtml(code);
                            }
                        }
                        return escapeHtml(code);
                    },
                    breaks: true,
                    gfm: true
                });
                
                let htmlContent = marked.parse(processedContent);
                
                // 处理HTML中的img标签路径（处理HTML格式的图像引用）
                const originalFilePath = window.currentOriginalFilePath || file_path || currentFilePath;
                if (originalFilePath) {
                    htmlContent = htmlContent.replace(/<img([^>]*)\ssrc=["']([^"']+)["']([^>]*)>/g, function(match, beforeSrc, src, afterSrc) {
                        let newSrc = src;
                        
                        console.log('Processing image src:', src, 'in file:', originalFilePath);
                        
                        // 如果是相对路径，直接基于markdown文件路径进行拼接
                        if (src && !src.startsWith('http') && !src.startsWith('data:') && !src.startsWith('/api/')) {
                            // 获取markdown文件的目录路径
                            const currentDir = originalFilePath.substring(0, originalFilePath.lastIndexOf('/'));
                            
                            let imagePath;
                            if (src.startsWith('./')) {
                                imagePath = `${currentDir}/${src.substring(2)}`;
                            } else if (src.startsWith('../')) {
                                const pathParts = currentDir.split('/');
                                let relativeParts = src.split('/');
                                for (let part of relativeParts) {
                                    if (part === '..') {
                                        pathParts.pop();
                                    } else if (part !== '.' && part !== '') {
                                        pathParts.push(part);
                                    }
                                }
                                imagePath = pathParts.join('/');
                            } else {
                                // 普通相对路径，直接拼接
                                imagePath = `${currentDir}/${src}`;
                            }
                            
                            // Add API key parameter if available
                            const apiKeyParam = (currentUser && currentUser !== 'default') ? `?api_key=${currentUser}` : '';
                            newSrc = `/api/file/${imagePath}${apiKeyParam}`;
                            console.log('Converted image path:', src, 'to:', newSrc);
                        }
                        
                        return `<img${beforeSrc} src="${newSrc}"${afterSrc} style="width: 100%; height: auto; object-fit: contain;">`;
                    });
                } else {
                    console.warn('originalFilePath is not available, image paths will not be converted');
                }
                
                const escapedContent = escapeHtml(processedContent);
                
                previewContent.innerHTML = `
                    <div class="markdown-toolbar-header" style="background: #f8f8f8; padding: 10px; border-radius: 5px; margin-bottom: 5px; font-size: 18px; color: #666; display: flex; justify-content: space-between; align-items: center;">
                        <span>${I18N.file_size || 'File Size'}: ${size} | ${I18N.type_label || 'Type'}: Markdown</span>
                        <div class="markdown-toolbar-buttons" style="display: flex; gap: 8px; align-items: center;">
                            <button id="reparseMarkdownBtn" onclick="reparseMarkdownDiagrams()" style="background: #9c27b0; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 16px; height: 36px; min-width: 120px; display: inline-flex; align-items: center; justify-content: center; vertical-align: middle;" title="${I18N.reparse_diagrams_title || '重新解析Markdown中的Mermaid图表和SVG代码块'}">
                                <i class="fas fa-project-diagram" style="margin-right: 5px;"></i> ${I18N.reparse_diagrams || '解析图表'}
                            </button>
                            <button id="reloadMarkdownBtn" onclick="reloadCurrentMarkdown()" style="background: #455a64; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 16px; height: 36px; min-width: 100px; display: inline-flex; align-items: center; justify-content: center; vertical-align: middle;" title="${I18N.reload || 'Reload'}">
                                <i class="fas fa-sync" style="margin-right: 5px;"></i> ${I18N.reload || 'Reload'}
                            </button>
                            <button id="saveMarkdownBtn" onclick="saveCurrentMarkdown()" style="background: #ff9800; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 16px; height: 36px; min-width: 80px; display: inline-flex; align-items: center; justify-content: center; vertical-align: middle;" title="${I18N.save_markdown_title || 'Save current Markdown text'}">
                                <i class="fas fa-save" style="margin-right: 5px;"></i> ${I18N.save || 'Save'}
                            </button>
                            <button id="convertWordBtn" onclick="convertMarkdownToWord()" style="background: #2e7d32; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 16px; height: 36px; min-width: 80px; display: inline-flex; align-items: center; justify-content: center; vertical-align: middle;" title="转换为Word文档">
                                <i class="fas fa-file-word" style="margin-right: 5px;"></i> Word
                            </button>
                            <button id="convertPdfBtn" onclick="convertMarkdownToPdf()" style="background: #d32f2f; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 16px; height: 36px; min-width: 70px; display: inline-flex; align-items: center; justify-content: center; vertical-align: middle;" title="转换为PDF文档">
                                <i class="fas fa-file-pdf" style="margin-right: 5px;"></i> PDF
                            </button>
                            <button id="convertLatexBtn" onclick="convertMarkdownToLatex()" style="background: #7b1fa2; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 16px; height: 36px; min-width: 80px; display: inline-flex; align-items: center; justify-content: center; vertical-align: middle;" title="生成LaTeX源文件">
                                <i class="fas fa-file-code" style="margin-right: 5px;"></i> LaTeX
                            </button>
                            <button id="markdownToggleBtn" onclick="toggleMarkdownMode()" style="background: #569cd6; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 16px; height: 36px; min-width: 110px; display: inline-flex; align-items: center; justify-content: center; vertical-align: middle;">
                                <i class="fas fa-eye" style="margin-right: 5px;"></i> ${I18N.source_mode || 'Source Mode'}
                            </button>
                        </div>
                    </div>
                    <div id="markdownPreview" class="tex2jax_process" style="background: #ffffff; color: #000000; padding: 10px; border-radius: 5px; line-height: 1.6; overflow: visible; border: 1px solid #dddddd;">
                        ${htmlContent}
                    </div>
                    <div id="markdownSource" style="background: #1e1e1e; color: #ffffff; padding: 20px; border-radius: 5px; overflow: visible; display: none; border: 1px solid #404040;">
                        <textarea id="markdownEditor" style="width: 100%; height: calc(90vh - 200px); background: #1e1e1e; color: #ffffff; border: none; font-size: 14px; line-height: 1.5; font-family: 'Consolas', 'Monaco', 'Courier New', monospace; resize: none; outline: none; padding: 0; margin: 0; white-space: pre-wrap;" placeholder="编辑Markdown内容...">${escapedContent}</textarea>
                    </div>
                `;
                
                // 存储原始内容以便切换
                window.currentMarkdownContent = {
                    processed: processedContent,
                    html: htmlContent,
                    escaped: escapedContent
                };
                
                // 应用用户保存的显示模式偏好
                setTimeout(() => {
                    applyMarkdownModePreference();
                    
                    // 触发Prism.js语法高亮
                    if (typeof Prism !== 'undefined') {
                        Prism.highlightAll();
                    }
                    
                    // 触发数学公式渲染（智能fallback）
                    renderMath(document.getElementById('markdownPreview'));
                    
                    // 触发Mermaid图表渲染
                    if (typeof mermaid !== 'undefined') {
                        try {
                            mermaid.initialize({ startOnLoad: false, theme: 'default' });
                            mermaid.run({ querySelector: '.mermaid' });
                            
                            // 检查是否为plan.md，如果是则不设置高度限制
                            const originalFilePath = window.currentOriginalFilePath || file_path || currentFilePath || '';
                            const isPlanMd = originalFilePath && (originalFilePath.endsWith('plan.md') || originalFilePath.endsWith('/plan.md'));
                            
                            if (isPlanMd) {
                                // 为markdownPreview添加plan-md类
                                const previewDiv = document.getElementById('markdownPreview');
                                if (previewDiv) {
                                    previewDiv.classList.add('plan-md');
                                }
                                
                                // 等待mermaid渲染完成后，移除高度限制
                                setTimeout(() => {
                                    const mermaidSvgs = previewDiv.querySelectorAll('.mermaid svg, svg');
                                    mermaidSvgs.forEach(svg => {
                                        svg.style.maxHeight = 'none';
                                        svg.style.width = 'auto';
                                        svg.style.height = 'auto';
                                    });
                                }, 200);
                            }
                        } catch (e) {
                            console.warn('Mermaid rendering failed:', e);
                        }
                    }
                }, 100);
            } else if (type === 'pdf') {
                previewContent.innerHTML = `
                    <div id="pdfInfoBar" style="background: var(--bg-secondary); padding: 10px; border-radius: 5px; margin-bottom: 5px; font-size: 18px; color: var(--text-primary); display: flex; align-items: center; flex-wrap: wrap; gap: 10px;">
                        <span>
                            ${I18N.file_size || 'File Size'}: ${size} | ${I18N.type_label || 'Type'}: PDF
                        </span>
                        <span id="pdfPagesInfo"></span>
                        <a id="pdfDownloadLink" href="#" download style="padding: 5px 10px; background: var(--bg-secondary); color: var(--text-primary); text-decoration: none; border-radius: 3px; font-size: 18px; border: 1px solid var(--border-primary); display: none; align-items: center; gap: 6px; margin-left: auto;">
                            <i class="fas fa-download"></i> ${I18N.download_pdf || 'Download PDF'}
                        </a>
                    </div>
                    <div id="pdfContainer" style="width: 100%; min-height: calc(90vh - 160px); border: 1px solid var(--border-primary); border-radius: 4px; overflow: visible; background: var(--bg-primary); margin-top: 0;">
                        <div style="text-align: center; padding: 20px; color: var(--text-primary);">
                            <i class="fas fa-spinner fa-spin"></i> 正在加载PDF...
                        </div>
                    </div>
                `;
                // PDF预览使用原始路径（不包含用户目录前缀）
                loadPDF(file_path || currentFilePath);
            } else if (type === 'office') {
                const { file_ext } = data;
                const filePath = file_path || currentFilePath;
                const fileUrl = `/api/office-file/${encodeURIComponent(filePath)}${(currentUser && currentUser !== 'default') ? '?api_key=' + encodeURIComponent(currentUser) : ''}`;
                
                previewContent.innerHTML = `
                    <div style="background: #f8f8f8; padding: 10px; border-radius: 5px; margin-bottom: 5px; font-size: 18px; color: #666; display: flex; justify-content: space-between; align-items: center;">
                        <span>
                            ${I18N.file_size || 'File Size'}: ${size} | ${I18N.type_label || 'Type'}: ${file_ext.toUpperCase()} ${I18N.office_preview_note || 'Office Document Preview'}
                        </span>
                        <a href="/api/download-file/${filePath}${(currentUser && currentUser !== 'default') ? '?api_key=' + currentUser : ''}" download 
                           style="padding: 8px 16px; background: #007acc; color: white; text-decoration: none; border-radius: 4px; font-size: 14px; display: inline-flex; align-items: center; gap: 6px;">
                            <i class="fas fa-download"></i> ${I18N.download_file || 'Download File'}
                        </a>
                    </div>
                    <div id="officeContainer" style="width: 100%; height: calc(90vh - 160px); border: 1px solid #ddd; border-radius: 4px; overflow: auto; background: #f5f5f5; position: relative;">
                        <div id="officeLoadingIndicator" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; z-index: 1000; background: rgba(255,255,255,0.9); padding: 20px; border-radius: 8px;">
                            <div style="border: 4px solid #f3f3f3; border-top: 4px solid #007acc; border-radius: 50%; width: 40px; height: 40px; animation: officeSpin 1s linear infinite; margin: 0 auto 15px;"></div>
                            <p style="color: #666; margin: 0;">${I18N.loading || 'Loading'}...</p>
                        </div>
                        <div id="officePreviewContent" style="display: none; padding: 20px; background: white; min-height: 100%;">
                        </div>
                    </div>
                `;
                
                // 添加样式
                setTimeout(function() {
                    if (!document.getElementById('officePreviewStyles')) {
                        const style = document.createElement('style');
                        style.id = 'officePreviewStyles';
                        style.textContent = `
                            @keyframes officeSpin {
                                0% { transform: rotate(0deg); }
                                100% { transform: rotate(360deg); }
                            }
                            #officePreviewContent {
                                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
                                line-height: 1.6;
                                color: #333;
                            }
                            #officePreviewContent h1, #officePreviewContent h2, #officePreviewContent h3 {
                                margin-top: 1.5em;
                                margin-bottom: 0.5em;
                            }
                            #officePreviewContent p {
                                margin: 1em 0;
                            }
                            #officePreviewContent table {
                                border-collapse: collapse;
                                width: 100%;
                                margin: 1em 0;
                            }
                            #officePreviewContent table td, #officePreviewContent table th {
                                border: 1px solid #ddd;
                                padding: 8px;
                            }
                            #officePreviewContent table th {
                                background-color: #f2f2f2;
                                font-weight: bold;
                            }
                        `;
                        document.head.appendChild(style);
                    }
                    
                    // 加载并预览Office文档
                    loadOfficePreview(fileUrl, file_ext);
                }, 100);
            } else if (type === 'csv') {
                // CSV文件表格预览
                const { headers, data: csvRows, total_rows, displayed_rows, truncated, encoding } = data;
                
                // 创建表格HTML
                let tableHtml = '<table id="csvTable" style="width: 100%; border-collapse: collapse; background: white; font-size: 18px; color: #333;">';
                
                // 表头
                if (headers && headers.length > 0) {
                    tableHtml += '<thead><tr style="background: #f8f9fa; position: sticky; top: 0; z-index: 10;">';
                    headers.forEach((header, index) => {
                        const escapedHeader = escapeHtml(header || `列${index + 1}`);
                        tableHtml += `<th onclick="sortCSVTable(${index})" style="border: 1px solid #dee2e6; padding: 12px 8px; text-align: left; font-weight: 600; cursor: pointer; user-select: none; position: relative; min-width: 120px; color: #333;" title="点击排序">${escapedHeader}<span style="margin-left: 5px; color: #6c757d;">⇅</span></th>`;
                    });
                    tableHtml += '</tr></thead>';
                }
                
                // 表格数据
                tableHtml += '<tbody id="csvTableBody">';
                if (csvRows && csvRows.length > 0) {
                    csvRows.forEach((row, rowIndex) => {
                        const rowStyle = rowIndex % 2 === 0 ? 'background: #ffffff;' : 'background: #f8f9fa;';
                        tableHtml += `<tr style="${rowStyle}">`;
                        
                        // 确保每行都有足够的列
                        const maxCols = Math.max(headers.length, row.length);
                        for (let i = 0; i < maxCols; i++) {
                            const cellValue = row[i] || '';
                            const escapedValue = escapeHtml(cellValue);
                            tableHtml += `<td style="border: 1px solid #dee2e6; padding: 8px; vertical-align: top; word-break: break-word; max-width: 300px; color: #333;" title="${escapedValue}">${escapedValue}</td>`;
                        }
                        tableHtml += '</tr>';
                    });
                } else {
                    tableHtml += `<tr><td colspan="${headers.length}" style="text-align: center; padding: 40px; color: #6c757d; font-style: italic;">暂无数据</td></tr>`;
                }
                tableHtml += '</tbody></table>';
                
                // 创建搜索和工具栏
                const searchHtml = `
                    <div style="background: #f8f9fa; padding: 10px; border-radius: 5px 5px 0 0; border-bottom: 1px solid #dee2e6; display: flex; align-items: center; flex-wrap: wrap; gap: 10px;">
                        <div style="flex: 1; min-width: 200px;">
                            <input type="text" id="csvSearchInput" placeholder="搜索表格内容..." 
                                style="width: 100%; padding: 8px 12px; border: 1px solid #ced4da; border-radius: 4px; font-size: 21px;"
                                oninput="filterCSVTable()">
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                            <button onclick="exportCSVTable()" style="padding: 8px 12px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 18px; display: flex; align-items: center; gap: 5px;">
                                <i class="fas fa-download"></i> 导出
                            </button>
                            <span style="font-size: 18px; color: #6c757d;">
                                显示 ${displayed_rows}/${total_rows} 行
                                ${truncated ? '(已截断)' : ''}
                                ${encoding ? `| 编码: ${encoding.toUpperCase()}` : ''}
                            </span>
                        </div>
                    </div>
                `;
                
                previewContent.innerHTML = `
                    <div style="background: #f8f8f8; padding: 10px; border-radius: 5px; margin-bottom: 5px; font-size: 18px; color: #666;">
                        ${I18N.file_size || 'File Size'}: ${size} | ${I18N.type_label || 'Type'}: CSV | ${I18N.total_rows || 'Total Rows'}: ${total_rows} | ${I18N.columns || 'Columns'}: ${headers.length}                                                                             
                        ${truncated ? ' | ⚠️ 大文件已截断显示' : ''}
                    </div>
                    <div style="border: 1px solid #dee2e6; border-radius: 5px; overflow: hidden; max-height: calc(90vh - 160px); display: flex; flex-direction: column;">
                        ${searchHtml}
                        <div style="flex: 1; overflow: auto;">
                            ${tableHtml}
                        </div>
                    </div>
                `;
                
                // 存储原始数据用于搜索和排序
                window.csvData = {
                    headers: headers,
                    originalData: csvRows,
                    currentData: csvRows,
                    sortColumn: -1,
                    sortDirection: 'asc'
                };
                
            } else if (type === 'code') {
                // 特殊处理txt和log文件，提供更好的阅读体验
                if (language === 'text' || language === 'log') {
                    // 先处理转义字符，再进行HTML转义
                    const processedContent = escapeHtml(processFileContent(content));
                    previewContent.innerHTML = `
                        <div style="background: #f8f8f8; padding: 10px; border-radius: 5px; margin-bottom: 10px; font-size: 18px; color: #666;">
                            ${I18N.file_size || 'File Size'}: ${size} | ${I18N.type_label || 'Type'}: ${language.toUpperCase()}
                        </div>
                        <div style="background: #1e1e1e; color: #ffffff; padding: 20px; border-radius: 5px; overflow: auto; font-size: 14px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-height: calc(90vh - 160px); border: 1px solid #404040; font-weight: normal;">${processedContent}</div>
                    `;
                } else {
                    // 使用Prism.js进行语法高亮
                    // 代码文件保持\n等转义字符原样显示，不进行转换（因为代码中的print等语句可能包含\n字符串）
                    // 直接进行HTML转义即可
                    const processedContent = escapeHtml(content);
                    
                    // 为mermaid文件提供特殊的样式处理
                    if (language === 'mermaid') {
                        previewContent.innerHTML = `
                            <div style="background: #f8f8f8; padding: 10px; border-radius: 5px; margin-bottom: 5px; font-size: 18px; color: #666; display: flex; justify-content: space-between; align-items: center;">
                                <span>${I18N.file_size || 'File Size'}: ${size} | ${I18N.language || 'Language'}: ${language}</span>
                                <div style="display: flex; gap: 10px;">
                                    <button onclick="saveMermaidFile()" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 18px;" title="${I18N.save_mermaid_title || 'Save current Mermaid file'}">                                                       
                                        <i class="fas fa-save"></i> ${I18N.save || 'Save'}
                                    </button>
                                    <button onclick="toggleMermaidView()" style="padding: 6px 12px; background: #007acc; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 18px;">                                                                                 
                                        <i class="fas fa-eye"></i> <span id="mermaid-view-btn-text">${I18N.preview || 'Preview'}</span>                                                                           
                                    </button>
                                    <button onclick="convertMermaidToImages()" style="padding: 6px 12px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 18px;" title="${I18N.convert_to_images || 'Convert Mermaid to PNG and SVG images'}">                                        
                                        <i class="fas fa-image"></i> ${I18N.convert_to_images_short || 'Convert to Images'}
                                    </button>
                                </div>
                            </div>
                            <div id="mermaid-source-view" style="max-height: calc(90vh - 160px); overflow: auto; border-radius: 5px; margin-top: 5px;">
                                <textarea id="mermaid-editor" style="width: 100%; height: calc(90vh - 200px); background: #1e1e1e; color: #ffffff; border: 1px solid #404040; font-size: 14px; line-height: 1.4; font-family: 'Consolas', 'Monaco', 'Courier New', monospace; resize: none; outline: none; padding: 15px; border-radius: 5px;" placeholder="${I18N.edit_mermaid_placeholder || 'Edit Mermaid content...'}">${content}</textarea>                                                                                      
                            </div>
                            <div id="mermaid-chart-view" style="display: none; max-height: calc(90vh - 160px); overflow: auto; border-radius: 5px; background: white; border: 1px solid #ddd; padding: 20px; text-align: center; margin-top: 5px;">
                                <div id="mermaid-chart-container">正在渲染图表...</div>
                            </div>
                        `;
                        
                        // Store the mermaid content and file path for later use
                        window.currentMermaidContent = content;
                        window.currentFilePath = actualFilePath;
                        
                        // 默认聚焦到编辑器并添加键盘事件监听
                        setTimeout(() => {
                            const editor = document.getElementById('mermaid-editor');
                            if (editor) {
                                editor.focus();
                                // 添加Ctrl+S保存快捷键
                                editor.addEventListener('keydown', function(e) {
                                    if (e.ctrlKey && e.key === 's') {
                                        e.preventDefault();
                                        saveMermaidFile();
                                    }
                                });
                            }
                        }, 100);
                    } else {
                        previewContent.innerHTML = `
                            <div style="background: #f8f8f8; padding: 10px; border-radius: 5px; margin-bottom: 5px; font-size: 18px; color: #666;">
                                ${I18N.file_size || 'File Size'}: ${size} | ${I18N.language || 'Language'}: ${language}
                            </div>
                            <div style="max-height: calc(90vh - 160px); overflow: auto; border-radius: 5px;">
                                <pre class="language-${language}" style="margin: 0; font-size: 14px; line-height: 1.4; background: #1e1e1e !important; border: 1px solid #404040;"><code class="language-${language}" style="color: #ffffff !important; font-weight: normal !important; background: transparent !important;">${processedContent}</code></pre>
                            </div>
                        `;
                    }
                    
                    // 触发Prism.js语法高亮
                    setTimeout(() => {
                        if (typeof Prism !== 'undefined') {
                            Prism.highlightAll();
                        }
                    }, 100);
                }
            } else if (type === 'image') {
                // Image file preview
                const { data: imageData, image_info } = data;
                const { width, height, format } = image_info;
                
                // 加载同文件夹下的所有图像
                loadImagesInFolder(actualFilePath);
                
                previewContent.innerHTML = `
                    <div style="background: #f8f8f8; padding: 10px; border-radius: 5px; margin-bottom: 5px; font-size: 18px; color: #666;">
                        ${I18N.file_size || 'File Size'}: ${size} | ${I18N.type_label || 'Type'}: ${I18N.image || 'Image'} (${format}) | ${I18N.dimensions || 'Dimensions'}: ${width} × ${height}                                                                                          
                    </div>
                    <div style="text-align: center; padding: 20px;">
                        <div class="preview-button-group" style="margin-bottom: 15px; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                            <button onclick="navigateToPreviousImage()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; font-size: 18px; cursor: pointer;" id="prevImageBtn">
                                <i class="fas fa-chevron-left"></i> 上一张
                            </button>
                            <button onclick="navigateToNextImage()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; font-size: 18px; cursor: pointer;" id="nextImageBtn">
                                下一张 <i class="fas fa-chevron-right"></i>
                            </button>
                            <a href="/api/download-file/${file_path || currentFilePath}${(currentUser && currentUser !== 'default') ? '?api_key=' + currentUser : ''}" download style="padding: 8px 16px; background: #007acc; color: white; text-decoration: none; border-radius: 4px; font-size: 18px; display: flex; align-items: center; gap: 5px;">
                                <i class="fas fa-download"></i> 下载图片
                            </a>
                            <button onclick="zoomImage()" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 18px; display: flex; align-items: center; gap: 5px;">
                                <i class="fas fa-search-plus"></i> 放大查看
                            </button>
                        </div>
                        <img src="${imageData}" 
                             alt="${fileName}" 
                             style="max-width: 100%; max-height: calc(90vh - 200px); border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); background: white; padding: 10px; display: block; margin: 0 auto;"
                             onerror="this.style.display='none'; this.parentNode.innerHTML='<div style=&quot;color: red; padding: 40px;&quot;><i class=&quot;fas fa-exclamation-triangle&quot;></i><br/>图片加载失败</div>';" />
                    </div>
                `;
                
                // 延迟更新按钮状态，确保DOM已渲染
                setTimeout(() => {
                    updateNavigationButtons();
                }, 100);
            }
        }
        
        function zoomImage() {
            const img = previewContent.querySelector('img');
            if (!img) return;
            
            // 关闭函数
            let overlay = null;
            const closeOverlay = () => {
                if (overlay && overlay.parentNode) {
                    document.body.removeChild(overlay);
                }
                overlay = null;
                document.removeEventListener('keydown', escKeyHandler);
            };
            
            // ESC键关闭处理器
            const escKeyHandler = (e) => {
                if (e.key === 'Escape') {
                    closeOverlay();
                }
            };
            
            // 创建全屏遮罩层
            overlay = document.createElement('div');
            overlay.tabIndex = 0;
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: #ffffff; z-index: 999999; 
                display: flex; flex-direction: column; align-items: center; 
                justify-content: center; outline: none;
            `;
            
            const fullImg = document.createElement('img');
            fullImg.src = img.src;
            fullImg.style.cssText = `
                max-width: 98vw; max-height: 90vh; width: auto; height: auto;
                object-fit: contain;
            `;
            
            // 底部提示文字
            const hintText = document.createElement('div');
            hintText.textContent = '按 ESC 键返回';
            hintText.style.cssText = `
                position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
                background: rgba(255, 255, 255, 0.9); color: #333; 
                padding: 12px 24px; border-radius: 8px; font-size: 18px;
                font-weight: 500; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            `;
            
            // ESC键关闭
            document.addEventListener('keydown', escKeyHandler);
            
            overlay.appendChild(fullImg);
            overlay.appendChild(hintText);
            document.body.appendChild(overlay);
            
            // 强制聚焦
            setTimeout(() => {
                if (overlay) {
                    overlay.focus();
                }
            }, 10);
        }

        // 加载Office文档预览（使用mammoth.js for Word, 其他格式显示提示）
        async function loadOfficePreview(fileUrl, fileExt) {
            const container = document.getElementById('officeContainer');
            const loadingIndicator = document.getElementById('officeLoadingIndicator');
            const previewContent = document.getElementById('officePreviewContent');
            
            if (!container || !loadingIndicator || !previewContent) {
                console.error('Office preview elements not found');
                return;
            }
            
            try {
                // 只支持.docx格式的预览（使用mammoth.js）
                if (fileExt === '.docx') {
                    // 动态加载mammoth.js
                    if (typeof mammoth === 'undefined') {
                        const script = document.createElement('script');
                        script.src = 'https://cdn.jsdelivr.net/npm/mammoth@1.6.0/mammoth.browser.min.js';
                        script.onload = function() {
                            loadDocxPreview(fileUrl, loadingIndicator, previewContent);
                        };
                        script.onerror = function() {
                            showOfficeError(loadingIndicator, previewContent, '无法加载文档预览库，请检查网络连接');
                        };
                        document.head.appendChild(script);
                    } else {
                        loadDocxPreview(fileUrl, loadingIndicator, previewContent);
                    }
                } else {
                    // 其他格式显示提示信息
                    loadingIndicator.style.display = 'none';
                    previewContent.style.display = 'block';
                    previewContent.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #666;">
                            <i class="fas fa-file-alt" style="font-size: 48px; margin-bottom: 20px; color: #007acc;"></i>
                            <h3 style="margin-bottom: 20px;">${I18N.office_preview_title || 'Office Document Preview'}</h3>
                            <p style="margin-bottom: 20px;">${I18N.office_download_instruction || '此格式暂不支持在线预览，请下载文件到本地查看：'}</p>
                            <p style="margin-bottom: 20px; color: #999; font-size: 14px;">支持预览的格式：.docx (Word 2007+)</p>
                            <a href="${fileUrl.replace('/api/office-file/', '/api/download-file/')}" download 
                               style="padding: 12px 24px; background: #007acc; color: white; text-decoration: none; border-radius: 5px; font-size: 16px; display: inline-block;">
                                <i class="fas fa-download"></i> ${I18N.download_file || 'Download File'}
                            </a>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error loading office preview:', error);
                showOfficeError(loadingIndicator, previewContent, error.message);
            }
        }
        
        async function loadDocxPreview(fileUrl, loadingIndicator, previewContent) {
            try {
                // 获取文件内容
                const response = await fetch(fileUrl);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const arrayBuffer = await response.arrayBuffer();
                
                // 使用mammoth.js转换
                const result = await mammoth.convertToHtml({arrayBuffer: arrayBuffer});
                
                // 显示预览内容
                loadingIndicator.style.display = 'none';
                previewContent.style.display = 'block';
                previewContent.innerHTML = result.value;
                
            } catch (error) {
                console.error('Error converting docx:', error);
                const errorMsg = (I18N.docx_load_failed || 'Document load failed: {error}').replace('{error}', error.message);
                showOfficeError(loadingIndicator, previewContent, errorMsg);
            }
        }
        
        function showOfficeError(loadingIndicator, previewContent, errorMessage) {
            loadingIndicator.style.display = 'none';
            previewContent.style.display = 'block';
            const previewFailedText = I18N.preview_failed || 'Preview Failed';
            const reloadText = I18N.reload || 'Reload';
            previewContent.innerHTML = `
                <div style="text-align: center; padding: 40px; color: #d73a49;">
                    <i class="fas fa-exclamation-triangle" style="font-size: 48px; margin-bottom: 20px;"></i>
                    <h3 style="margin-bottom: 20px;">${previewFailedText}</h3>
                    <p style="margin-bottom: 20px;">${errorMessage}</p>
                    <a href="javascript:location.reload()" 
                       style="padding: 8px 16px; background: #007acc; color: white; text-decoration: none; border-radius: 4px; display: inline-block;">
                        ${reloadText}
                    </a>
                </div>
            `;
        }

        function loadPDF(filePath) {
            if (typeof pdfjsLib === 'undefined') {
                const pdfjsNotLoadedText = I18N.pdfjs_not_loaded || 'PDF.js not loaded, unable to preview PDF files';
                document.getElementById('pdfContainer').innerHTML = `
                    <div style="text-align: center; padding: 20px; color: red;">
                        <i class="fas fa-exclamation-triangle"></i> ${pdfjsNotLoadedText}
                    </div>
                `;
                return;
            }

            // 添加API密钥参数
            const apiKeyParam = (currentUser && currentUser !== 'default') ? `?api_key=${currentUser}` : '';
            const pdfUrl = `/api/pdf/${filePath}${apiKeyParam}`;
            
            // PDF下载使用原始路径（后端会自动添加用户目录前缀）
            const downloadFilePath = window.currentOriginalFilePath || filePath;
        
            
            // 配置PDF.js加载选项
            const loadingTask = pdfjsLib.getDocument({
                url: pdfUrl,
                disableWorker: false,
                verbosity: 1,  // 启用详细日志以便调试
                cMapUrl: 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/cmaps/',
                cMapPacked: true,
                standardFontDataUrl: 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/standard_fonts/'
            });
            
            loadingTask.promise.then(function(pdf) {
                const container = document.getElementById('pdfContainer');
                // 移除顶部圆角和边框，确保导航栏完全贴到顶部
                container.style.borderTopLeftRadius = '0';
                container.style.borderTopRightRadius = '0';
                container.style.borderTop = 'none';
                container.style.marginTop = '0';
                container.innerHTML = '';
                
                // 更新第一个横条，添加总页数和下载链接
                const apiKeyParam = (currentUser && currentUser !== 'default') ? `?api_key=${currentUser}` : '';
                const downloadUrl = `/api/download-file/${downloadFilePath}${apiKeyParam}`;
                const pagesInfo = document.getElementById('pdfPagesInfo');
                const downloadLink = document.getElementById('pdfDownloadLink');
                if (pagesInfo) {
                    pagesInfo.textContent = I18N.pdf_pages.replace('{pages}', pdf.numPages);
                }
                if (downloadLink) {
                    downloadLink.href = downloadUrl;
                    downloadLink.style.display = 'inline-flex';
                    downloadLink.style.alignItems = 'center';
                    downloadLink.style.gap = '6px';
                    downloadLink.style.marginLeft = 'auto';
                }
                
                // 创建页面容器
                const pagesContainer = document.createElement('div');
                pagesContainer.id = 'pdfPages';
                pagesContainer.style.cssText = 'padding: 20px; text-align: center; width: 100%; max-width: none;';
                container.appendChild(pagesContainer);
                
                // 存储PDF对象
                window.currentPDF = pdf;
                
                // 渲染所有页面
                renderAllPDFPages();
                
            }).catch(function(error) {
                console.error('PDF加载失败:', error);
                console.error('PDF URL:', pdfUrl);
                console.error('Error details:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });
                
                // 如果是InvalidPDFException，尝试使用简化配置重新加载
                if (error.name === 'InvalidPDFException') {
                    console.log('尝试使用简化配置重新加载PDF...');
                    const simpleLoadingTask = pdfjsLib.getDocument({
                        url: pdfUrl,
                        disableWorker: true,  // 禁用worker
                        verbosity: 0
                    });
                    
                    simpleLoadingTask.promise.then(function(pdf) {
                        const container = document.getElementById('pdfContainer');
                        // 移除顶部圆角和边框，确保导航栏完全贴到顶部
                        container.style.borderTopLeftRadius = '0';
                        container.style.borderTopRightRadius = '0';
                        container.style.borderTop = 'none';
                        container.style.marginTop = '0';
                        container.innerHTML = '';
                        
                        // 更新第一个横条，添加总页数和下载链接
                        const apiKeyParam = (currentUser && currentUser !== 'default') ? `?api_key=${currentUser}` : '';
                        const downloadUrl = `/api/download-file/${downloadFilePath}${apiKeyParam}`;
                        const pagesInfo = document.getElementById('pdfPagesInfo');
                        const downloadLink = document.getElementById('pdfDownloadLink');
                        if (pagesInfo) {
                            pagesInfo.textContent = I18N.pdf_pages_simple.replace('{pages}', pdf.numPages);
                        }
                        if (downloadLink) {
                            downloadLink.href = downloadUrl;
                            downloadLink.style.display = 'inline-flex';
                            downloadLink.style.alignItems = 'center';
                            downloadLink.style.gap = '6px';
                            downloadLink.style.marginLeft = 'auto';
                        }
                        
                        // 创建页面容器
                        const pagesContainer = document.createElement('div');
                        pagesContainer.id = 'pdfPages';
                        pagesContainer.style.cssText = 'padding: 20px; text-align: center; width: 100%; max-width: none;';
                        container.appendChild(pagesContainer);
                        
                        // 存储PDF对象
                        window.currentPDF = pdf;
                        
                        // 渲染所有页面
                        renderAllPDFPages();
                    }).catch(function(simpleError) {
                        console.error('简化配置也失败:', simpleError);
                        showPDFError('PDF文件格式无效或已损坏', error);
                    });
                } else {
                    let errorMessage = error.message;
                    if (error.name === 'MissingPDFException') {
                        errorMessage = 'PDF文件未找到';
                    } else if (error.name === 'UnexpectedResponseException') {
                        errorMessage = '服务器响应异常，请检查文件路径和权限';
                    }
                    showPDFError(errorMessage, error);
                }
            });
            
            function showPDFError(errorMessage, error) {
                document.getElementById('pdfContainer').innerHTML = `
                    <div style="text-align: center; padding: 20px; color: red;">
                        <i class="fas fa-exclamation-triangle"></i> PDF加载失败: ${errorMessage}
                        <br><small style="color: #666; margin-top: 10px; display: block;">
                            技术详情: ${error.name || 'Unknown'} - ${error.message}
                        </small>
                        <br><button onclick="retryPDFLoad('${filePath}')" style="margin-top: 10px; padding: 5px 15px; background: #007acc; color: white; border: none; border-radius: 3px; cursor: pointer;">
                            重试加载
                        </button>
                    </div>
                `;
            }
        }

        // 仅用于 Markdown 中 web_search_result/images 的图片导航逻辑
        function _extractPrevImagePathInFolder(originalHref, baseDir) {
            try {
                // originalHref 例如: web_search_result/images/xxx_YYYYMMDD_001.png
                if (!originalHref || !originalHref.includes('/')) return null;
                const lastSlash = originalHref.lastIndexOf('/');
                const folder = originalHref.substring(0, lastSlash); // web_search_result/images
                const filename = originalHref.substring(lastSlash + 1); // xxx_YYYYMMDD_001.png

                // 提取前缀：去掉文件名最后9个字符（含扩展名前的分隔符计入9个计数约束由约定负责）
                // 例如: name_part + '_' + 9位编号（如 _000000123 或 _202501001）
                const dotIdx = filename.lastIndexOf('.');
                if (dotIdx <= 0) return null;
                const nameNoExt = filename.substring(0, dotIdx);
                const ext = filename.substring(dotIdx); // .png/.jpg
                if (nameNoExt.length <= 9) return null;
                const prefix = nameNoExt.substring(0, nameNoExt.length - 9);
                const tailNine = nameNoExt.substring(nameNoExt.length - 9); // 编号字段

                // 调用后端列出目录
                let folderPath = folder;
                if (baseDir && !folder.startsWith('/')) {
                    folderPath = baseDir + '/' + folder;
                }

                // 移除可能重复的 //
                folderPath = folderPath.replace(/\/+/, '/');

                const headers = { 'Content-Type': 'application/json' };
                const body = { path: folderPath };
                if (currentUser && currentUser !== 'default') {
                    headers['X-API-Key'] = currentUser;
                    body.api_key = currentUser;
                }

                return fetch('/api/list-directory', {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(body)
                }).then(r => r.json()).then(data => {
                    if (!data.success) throw new Error(data.error || 'list failed');
                    // 过滤同前缀 + 同扩展名的文件
                    const files = (data.files || []).filter(f => {
                        if (!f || !f.name) return false;
                        const fname = f.name;
                        const dIdx = fname.lastIndexOf('.');
                        if (dIdx <= 0) return false;
                        const nNoExt = fname.substring(0, dIdx);
                        if (nNoExt.length <= 9) return false;
                        const pfx = nNoExt.substring(0, nNoExt.length - 9);
                        const tn = nNoExt.substring(nNoExt.length - 9);
                        return pfx === prefix && /^[-_0-9A-Za-z]{9}$/.test(tn);
                    }).map(f => f.name);

                    // 排序依据：文件名后9位的字典序
                    files.sort((a, b) => {
                        const aNoExt = a.substring(0, a.lastIndexOf('.'));
                        const bNoExt = b.substring(0, b.lastIndexOf('.'));
                        const aTail = aNoExt.substring(aNoExt.length - 9);
                        const bTail = bNoExt.substring(bNoExt.length - 9);
                        return aTail.localeCompare(bTail);
                    });

                    if (!files.length) return null;

                    // 优先精确匹配当前文件名，否则按尾9位匹配；都匹配不到则从最后一张开始
                    let idx = files.findIndex(n => n === filename);
                    if (idx < 0) {
                        const idx2 = files.findIndex(n => {
                            const nNoExt = n.substring(0, n.lastIndexOf('.'));
                            return nNoExt.endsWith(tailNine);
                        });
                        idx = idx2; // 可能仍为 -1
                    }

                    const prevIndex = idx <= 0 ? files.length - 1 : idx - 1;
                    const prevName = files[prevIndex];
                    return folder + '/' + prevName;
                }).catch(e => {
                    console.warn('list prev image failed:', e);
                    return null;
                });
            } catch (e) {
                console.warn('parse prev image failed:', e);
                return Promise.resolve(null);
            }
        }

        function _extractNextImagePathInFolder(originalHref, baseDir) {
            try {
                // originalHref 例如: web_search_result/images/xxx_YYYYMMDD_001.png
                if (!originalHref || !originalHref.includes('/')) return null;
                const lastSlash = originalHref.lastIndexOf('/');
                const folder = originalHref.substring(0, lastSlash); // web_search_result/images
                const filename = originalHref.substring(lastSlash + 1); // xxx_YYYYMMDD_001.png

                // 提取前缀：去掉文件名最后9个字符（含扩展名前的分隔符计入9个计数约束由约定负责）
                // 例如: name_part + '_' + 9位编号（如 _000000123 或 _202501001）
                const dotIdx = filename.lastIndexOf('.');
                if (dotIdx <= 0) return null;
                const nameNoExt = filename.substring(0, dotIdx);
                const ext = filename.substring(dotIdx); // .png/.jpg
                if (nameNoExt.length <= 9) return null;
                const prefix = nameNoExt.substring(0, nameNoExt.length - 9);
                const tailNine = nameNoExt.substring(nameNoExt.length - 9); // 编号字段

                // 调用后端列出目录
                // 注意：后端 /api/list-directory 会在用户目录下解析路径
                // 这里传入 baseDir + '/' + folder 作为 markdown 所在目录的相对路径
                // 实际 originalHref 是相对 markdown 文件的相对路径，因此拼接 baseDir 后再规范化
                let folderPath = folder;
                // 如果 originalHref 非绝对且不以 /api/ 开头，则使用 markdown 所在目录为基准
                if (baseDir && !folder.startsWith('/')) {
                    folderPath = baseDir + '/' + folder;
                }

                // 移除可能重复的 //
                folderPath = folderPath.replace(/\/+/, '/');

                const headers = { 'Content-Type': 'application/json' };
                const body = { path: folderPath };
                if (currentUser && currentUser !== 'default') {
                    headers['X-API-Key'] = currentUser;
                    body.api_key = currentUser;
                }

                return fetch('/api/list-directory', {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(body)
                }).then(r => r.json()).then(data => {
                    if (!data.success) throw new Error(data.error || 'list failed');
                    // 过滤同前缀 + 同扩展名的文件
                    const files = (data.files || []).filter(f => {
                        if (!f || !f.name) return false;
                        const fname = f.name;
                        const dIdx = fname.lastIndexOf('.');
                        if (dIdx <= 0) return false;
                        const nNoExt = fname.substring(0, dIdx);
                        if (nNoExt.length <= 9) return false;
                        const pfx = nNoExt.substring(0, nNoExt.length - 9);
                        const tn = nNoExt.substring(nNoExt.length - 9);
                        return pfx === prefix && /^[-_0-9A-Za-z]{9}$/.test(tn);
                    }).map(f => f.name);

                    // 排序依据：文件名后9位的字典序
                    files.sort((a, b) => {
                        const aNoExt = a.substring(0, a.lastIndexOf('.'));
                        const bNoExt = b.substring(0, b.lastIndexOf('.'));
                        const aTail = aNoExt.substring(aNoExt.length - 9);
                        const bTail = bNoExt.substring(bNoExt.length - 9);
                        return aTail.localeCompare(bTail);
                    });

                    if (!files.length) return null;

                    // 优先精确匹配当前文件名，否则按尾9位匹配；都匹配不到则从第一张开始
                    let idx = files.findIndex(n => n === filename);
                    if (idx < 0) {
                        const idx2 = files.findIndex(n => {
                            const nNoExt = n.substring(0, n.lastIndexOf('.'));
                            return nNoExt.endsWith(tailNine);
                        });
                        idx = idx2; // 可能仍为 -1
                    }

                    const nextIndex = ((idx >= 0 ? idx + 1 : 0) % files.length);
                    const nextName = files[nextIndex];
                    return folder + '/' + nextName;
                }).catch(e => {
                    console.warn('list next image failed:', e);
                    return null;
                });
            } catch (e) {
                console.warn('parse next image failed:', e);
                return Promise.resolve(null);
            }
        }

        function nextWebSearchImage(btnEl) {
            try {
                if (!window.currentMarkdownContent || !window.currentMarkdownContent.processed) return;
                const mdText = window.currentMarkdownContent.processed;
                const href = btnEl?.getAttribute('data-md-href');
                const occStr = btnEl?.getAttribute('data-md-occurrence') || '0';
                const occIndex = parseInt(occStr, 10) || 0;
                const baseDir = btnEl?.getAttribute('data-md-basedir') || '';

                if (!href || !href.startsWith('web_search_result/images')) return;

                _extractNextImagePathInFolder(href, baseDir).then(nextHref => {
                    if (!nextHref) return; // 无下一张

                    // 在 Markdown 原文中仅替换第 occIndex 次出现的该 href
                    let count = 0;
                    const replaced = mdText.replace(new RegExp(escapeRegExp(href), 'g'), (m) => {
                        const cur = count;
                        count += 1;
                        return (cur === occIndex) ? nextHref : m;
                    });

                    window.currentMarkdownContent.processed = replaced;
                    // 重新渲染：复用 displayFileContent 的 markdown 流程
                    // 这里通过构造 data 对象调用一次渲染路径
                    const fake = { content: replaced, type: 'markdown', size: 'N/A', file_path: window.currentOriginalFilePath || currentFilePath };
                    displayFileContent(fake, '');
                    
                    // 图片切换成功后自动保存文件
                    autoSaveMarkdown().then(saved => {
                        if (saved) {
                            console.log(I18N.image_switched_auto_save);
                        }
                    }).catch(e => {
                        console.warn(I18N.auto_save_error + ':', e);
                    });
                });
            } catch (e) {
                console.warn('next image failed:', e);
            }
        }

        function prevWebSearchImage(btnEl) {
            try {
                if (!window.currentMarkdownContent || !window.currentMarkdownContent.processed) return;
                const mdText = window.currentMarkdownContent.processed;
                const href = btnEl?.getAttribute('data-md-href');
                const occStr = btnEl?.getAttribute('data-md-occurrence') || '0';
                const occIndex = parseInt(occStr, 10) || 0;
                const baseDir = btnEl?.getAttribute('data-md-basedir') || '';

                if (!href || !href.startsWith('web_search_result/images')) return;

                _extractPrevImagePathInFolder(href, baseDir).then(prevHref => {
                    if (!prevHref) return; // 无上一张

                    // 在 Markdown 原文中仅替换第 occIndex 次出现的该 href
                    let count = 0;
                    const replaced = mdText.replace(new RegExp(escapeRegExp(href), 'g'), (m) => {
                        const cur = count;
                        count += 1;
                        return (cur === occIndex) ? prevHref : m;
                    });

                    window.currentMarkdownContent.processed = replaced;
                    // 重新渲染：复用 displayFileContent 的 markdown 流程
                    // 这里通过构造 data 对象调用一次渲染路径
                    const fake = { content: replaced, type: 'markdown', size: 'N/A', file_path: window.currentOriginalFilePath || currentFilePath };
                    displayFileContent(fake, '');
                    
                    // 图片切换成功后自动保存文件
                    autoSaveMarkdown().then(saved => {
                        if (saved) {
                            console.log(I18N.image_switched_auto_save);
                        }
                    }).catch(e => {
                        console.warn(I18N.auto_save_error + ':', e);
                    });
                });
            } catch (e) {
                console.warn('prev image failed:', e);
            }
        }

        function removeWebSearchImage(btnEl) {
            try {
                if (!window.currentMarkdownContent || !window.currentMarkdownContent.processed) return;
                const mdText = window.currentMarkdownContent.processed;
                const href = btnEl?.getAttribute('data-md-href');
                const occStr = btnEl?.getAttribute('data-md-occurrence') || '0';
                const occIndex = parseInt(occStr, 10) || 0;
                if (!href) return;

                // 精确删除第 occIndex 次出现的该图片语法：
                // 兼容两种写法：
                // 1) Markdown: ![alt](href "title") 或 ![alt](href)
                // 2) HTML: <img ... src="href" ...>

                // 优先处理 Markdown 语法
                let count = 0;
                // 匹配 ![...](...) 中 href 的位置（简化处理：匹配括号内整体再决定是否替换）
                const mdPattern = /!\[[^\]]*\]\(([^)]+)\)/g;
                let replaced = mdText.replace(mdPattern, (full, inner) => {
                    // inner 可能包含 href 与 title，如: href "title"
                    // 我们提取第一个空白前的部分作为 url
                    const url = inner.split(/\s+/)[0].trim();
                    const cur = count;
                    if (url === href) {
                        count += 1;
                        if (cur === occIndex) {
                            return '';
                        }
                    }
                    return full;
                });

                if (count === 0 || (count <= occIndex)) {
                    // 可能是 HTML <img> 写法，执行第二轮替换
                    let htmlCount = 0;
                    const imgPattern = /<img([^>]*)\ssrc=["']([^"']+)["']([^>]*)>/g;
                    replaced = replaced.replace(imgPattern, (full, beforeSrc, src, afterSrc) => {
                        const cur = htmlCount;
                        if (src === href) {
                            htmlCount += 1;
                            if (cur === occIndex) {
                                return '';
                            }
                        }
                        return full;
                    });
                }

                window.currentMarkdownContent.processed = replaced;
                const fake = { content: replaced, type: 'markdown', size: 'N/A', file_path: window.currentOriginalFilePath || currentFilePath };
                displayFileContent(fake, '');
                
                // 图片删除成功后自动保存文件
                autoSaveMarkdown().then(saved => {
                    if (saved) {
                        console.log(I18N.image_deleted_auto_save);
                    }
                }).catch(e => {
                    console.warn(I18N.auto_save_error + ':', e);
                });
            } catch (e) {
                console.warn('remove image failed:', e);
            }
        }

        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        // SVG编辑函数
        function editSvgImage(btnEl) {
            try {
                // 获取I18N对象用于国际化
                const I18N = window.I18N || JSON.parse(document.getElementById('i18nData')?.textContent || '{}');

                const src = btnEl?.getAttribute('data-md-src');
                const href = btnEl?.getAttribute('data-md-href');

                if (!src && !href) {
                    const noPathMsg = I18N?.lang === 'zh' ? '无法获取SVG文件路径' : 'Unable to get SVG file path';
                    alert(noPathMsg);
                    return;
                }
                
                let filePath = href || src;
                
                // 处理相对路径，确保从当前文件所在目录解析
                if (filePath && !filePath.startsWith('/') && !filePath.startsWith('http')) {
                    const currentFilePath = window.currentOriginalFilePath || window.currentFilePath || '';
                    if (currentFilePath && currentFilePath.includes('/')) {
                        const currentDir = currentFilePath.substring(0, currentFilePath.lastIndexOf('/'));
                        filePath = currentDir + '/' + filePath;
                    }
                    // 清理重复的斜杠
                    filePath = filePath.replace(/\/+/g, '/');
                }
                
                // 新的用户认证系统不需要user_前缀，直接使用相对路径
                
                console.log(I18N.edit_svg_file + ':', filePath);
                
                // 打开SVG编辑器模态框
                openSvgEditor(filePath);
                
            } catch (e) {
                console.warn('打开SVG编辑器失败:', e);
                const errorMsg = I18N?.lang === 'zh'
                    ? `打开SVG编辑器失败: ${e.message}`
                    : `Failed to open SVG editor: ${e.message}`;
                alert(errorMsg);
            }
        }

        // 打开SVG编辑器
        function openSvgEditor(filePath) {
            // 获取I18N对象用于国际化
            const I18N = window.I18N || JSON.parse(document.getElementById('i18nData')?.textContent || '{}');

            const modal = document.getElementById('svgEditorModal');
            const titleElement = document.getElementById('svgEditorTitle');
            const canvas = document.getElementById('svgCanvas');
            const saveBtn = document.getElementById('svgSaveBtn');
            const deleteBtn = document.getElementById('svgDeleteBtn');
            const resetBtn = document.getElementById('svgResetBtn');
            const closeBtn = document.getElementById('svgEditorClose');
            const maximizeBtn = document.getElementById('svgEditorMaximize');
            const zoomInBtn = document.getElementById('svgZoomInBtn');
            const zoomOutBtn = document.getElementById('svgZoomOutBtn');
            const zoomLevel = document.getElementById('svgZoomLevel');

            // 更新标题显示文件名
            const fileName = filePath.split('/').pop();
            const editorTitle = I18N?.lang === 'zh' ? 'SVG编辑器' : 'SVG Editor';
            titleElement.textContent = `${editorTitle} - ${fileName}`;
            
            // 保存文件路径用于后续保存
            window.currentSvgPath = filePath;

            // 初始化修改跟踪
            window.svgModified = false;
            window.originalSvgContent = null;
            
            // 初始化缩放比例
            window.svgZoomLevel = 1.0; // 100%
            if (zoomLevel) {
                zoomLevel.textContent = '100%';
            }
            
            // 构建加载URL，包含API key
            // 优先使用 currentUser（已连接的会话），如果没有则从输入框获取
            let apiKey = '';
            if (typeof currentUser !== 'undefined' && currentUser && currentUser !== 'default') {
                apiKey = currentUser;
            } else {
                const apiKeyInput = document.getElementById('apiKeyInput');
                apiKey = apiKeyInput ? apiKeyInput.value.trim() : '';
            }
            
            const loadUrl = apiKey ? `/api/file/${filePath}?api_key=${encodeURIComponent(apiKey)}` : `/api/file/${filePath}`;
            
            console.log('🔍 SVG加载调试信息:');
            console.log('  文件路径:', filePath);
            console.log('  API Key:', apiKey ? '***存在***' : '空');
            console.log('  currentUser:', typeof currentUser !== 'undefined' ? currentUser : '未定义');
            console.log('  加载URL:', loadUrl);
            
            // 加载SVG内容
            const headers = {};
            if (apiKey) {
                headers['X-API-Key'] = apiKey;
            }
            
            fetch(loadUrl, {
                headers: headers
            })
                .then(response => {
                    // 检查响应状态
                    if (!response.ok) {
                        return response.text().then(text => {
                            try {
                                const jsonData = JSON.parse(text);
                                throw new Error(jsonData.error || '加载SVG文件失败');
                            } catch (e) {
                                if (e instanceof Error && e.message !== '加载SVG文件失败') {
                                    throw e;
                                }
                                throw new Error('加载SVG文件失败: ' + response.statusText);
                            }
                        });
                    }
                    return response.text();
                })
                .then(rawContent => {
                    let svgContent;
                    try {
                        // 尝试解析为JSON（API返回的格式）
                        const jsonData = JSON.parse(rawContent);
                        if (jsonData.success && jsonData.data) {
                            // 如果是base64编码的SVG数据，解码它
                            if (jsonData.data.startsWith('data:image/svg+xml;base64,')) {
                                const base64Data = jsonData.data.replace('data:image/svg+xml;base64,', '');
                                svgContent = decodeBase64UTF8(base64Data);
                            } else {
                                // 如果直接是SVG内容
                                svgContent = jsonData.data;
                            }
                        } else if (!jsonData.success) {
                            // API返回了错误响应
                            const errorMsg = jsonData.error || '无效的API响应';
                            throw new Error(errorMsg);
                        } else {
                            throw new Error('无效的API响应');
                        }
                    } catch (e) {
                        // 如果错误已经是我们抛出的，直接抛出
                        if (e instanceof Error && (e.message.includes('无效的API响应') || e.message.includes('加载SVG文件失败') || e.message.includes('Authentication failed'))) {
                            throw e;
                        }
                        // 如果不是JSON，假设是直接的SVG内容
                        svgContent = rawContent;
                    }

                    // 保存原始SVG内容用于修改检测
                    window.originalSvgContent = svgContent;
                    window.svgModified = false;
                    loadSvgIntoEditor(svgContent, canvas);
                    modal.style.display = 'block';
                    
                    // 确保SVG编辑器可以交互（当预览窗口打开时body的pointer-events可能被设置为none）
                    modal.style.pointerEvents = 'auto';
                })
                .catch(error => {
                    console.error('加载SVG文件失败:', error);
                    const I18N = window.I18N || JSON.parse(document.getElementById('i18nData')?.textContent || '{}');
                    const errorMsg = I18N?.lang === 'zh' 
                        ? `加载SVG文件失败: ${error.message}` 
                        : `Failed to load SVG file: ${error.message}`;
                    alert(errorMsg);
                });
            
            // 绑定事件处理程序
            saveBtn.onclick = saveSvg;
            deleteBtn.onclick = deleteSelectedElements;
            resetBtn.onclick = resetSvg;
            closeBtn.onclick = () => closeSvgEditor(modal);
            
            // 初始化最大化状态
            let isSvgEditorMaximized = false;
            let svgEditorOriginalState = null;
            
            // 绑定最大化按钮事件
            if (maximizeBtn) {
                maximizeBtn.onclick = function() {
                    const modalContent = modal.querySelector('.modal-content');
                    
                    if (!isSvgEditorMaximized) {
                        // 最大化
                        console.log('最大化SVG编辑器窗口');
                        
                        // 保存当前状态
                        svgEditorOriginalState = {
                            width: modalContent.style.width,
                            height: modalContent.style.height,
                            margin: modalContent.style.margin
                        };
                        
                        // 添加最大化类
                        modal.classList.add('maximized');
                        
                        // 更改图标
                        maximizeBtn.innerHTML = '<i class="fas fa-compress"></i>';
                        maximizeBtn.title = I18N?.lang === 'zh' ? '还原' : 'Restore';
                        
                        isSvgEditorMaximized = true;
                    } else {
                        // 还原
                        console.log('还原SVG编辑器窗口');
                        
                        // 移除最大化类
                        modal.classList.remove('maximized');
                        
                        // 恢复原来的尺寸
                        if (svgEditorOriginalState) {
                            modalContent.style.width = svgEditorOriginalState.width;
                            modalContent.style.height = svgEditorOriginalState.height;
                            modalContent.style.margin = svgEditorOriginalState.margin;
                        } else {
                            // 如果没有保存的状态，使用默认值
                            modalContent.style.width = '95%';
                            modalContent.style.height = '95vh';
                            modalContent.style.margin = '2.5vh auto';
                        }
                        
                        // 更改图标
                        maximizeBtn.innerHTML = '<i class="fas fa-expand"></i>';
                        maximizeBtn.title = I18N?.lang === 'zh' ? '最大化' : 'Maximize';
                        
                        isSvgEditorMaximized = false;
                    }
                };
            }
            
            // 绑定缩放按钮事件
            if (zoomInBtn) {
                zoomInBtn.onclick = () => zoomSvg(1.2, canvas, zoomLevel);
            }
            if (zoomOutBtn) {
                zoomOutBtn.onclick = () => zoomSvg(0.8, canvas, zoomLevel);
            }
            
            // 点击模态框外部关闭
            window.onclick = function(event) {
                if (event.target === modal) {
                    closeSvgEditor(modal);
                }
            };
        }

        // 关闭SVG编辑器，检查修改状态
        function closeSvgEditor(modal) {
            const actualClose = () => {
                // 重置最大化状态
                const maximizeBtn = document.getElementById('svgEditorMaximize');
                if (modal.classList.contains('maximized') && maximizeBtn) {
                    modal.classList.remove('maximized');
                    maximizeBtn.innerHTML = '<i class="fas fa-expand"></i>';
                    const I18N = window.I18N || JSON.parse(document.getElementById('i18nData')?.textContent || '{}');
                    maximizeBtn.title = I18N?.lang === 'zh' ? '最大化' : 'Maximize';
                    // 恢复默认尺寸
                    const modalContent = modal.querySelector('.modal-content');
                    if (modalContent) {
                        modalContent.style.width = '95%';
                        modalContent.style.height = '95vh';
                        modalContent.style.margin = '2.5vh auto';
                    }
                }
                modal.style.display = 'none';
                modal.style.pointerEvents = '';
            };
            
            if (window.svgModified) {
                // 获取I18N对象用于国际化
                const I18N = window.I18N || JSON.parse(document.getElementById('i18nData')?.textContent || '{}');

                const confirmSaveMsg = I18N?.lang === 'zh'
                    ? 'SVG文件已被修改，是否保存更改？'
                    : 'SVG file has been modified. Save changes?';

                const saveMsg = I18N?.lang === 'zh' ? '保存' : 'Save';
                const discardMsg = I18N?.lang === 'zh' ? '不保存' : 'Discard';
                const cancelMsg = I18N?.lang === 'zh' ? '取消' : 'Cancel';

                if (confirm(confirmSaveMsg)) {
                    // 用户选择保存
                    saveSvg(() => {
                        actualClose();
                    });
                } else {
                    // 用户选择不保存，直接关闭
                    actualClose();
                }
                // 如果用户选择取消（取消按钮），不执行任何操作
            } else {
                // 没有修改，直接关闭
                actualClose();
            }
        }

        // 将SVG加载到编辑器中
        function loadSvgIntoEditor(svgContent, canvas) {
            // 移除命名空间前缀，避免解析问题
            svgContent = svgContent.replace(/xmlns:ns\d+="[^"]*"/g, '');
            svgContent = svgContent.replace(/ns\d+:/g, '');
            canvas.innerHTML = svgContent;
            
            // 获取SVG元素
            const svgElement = canvas.querySelector('svg');
            if (!svgElement) {
                const I18N = window.I18N || JSON.parse(document.getElementById('i18nData')?.textContent || '{}');
                const invalidSvgMsg = I18N?.lang === 'zh' ? '无效的SVG文件' : 'Invalid SVG file';
                alert(invalidSvgMsg);
                return;
            }
            
            // 设置SVG样式使其可编辑，防止文字选择
            // 保持SVG的原始宽高比，设置最大宽度并居中显示
            const viewBox = svgElement.getAttribute('viewBox');
            const originalWidth = svgElement.getAttribute('width');
            const originalHeight = svgElement.getAttribute('height');
            
            // 如果SVG没有viewBox但有宽高，添加viewBox以保持比例
            if (!viewBox && originalWidth && originalHeight) {
                svgElement.setAttribute('viewBox', `0 0 ${originalWidth} ${originalHeight}`);
            }
            
            // 设置SVG样式：保留原始尺寸，但通过max-width限制最大显示尺寸
            // 这样SVG会根据原始尺寸显示，但不会超过画布的90%
            svgElement.style.maxWidth = '90%';
            svgElement.style.maxHeight = '90%';
            // 不强制设置width和height，让SVG使用其原始属性或viewBox
            svgElement.style.cursor = 'default';
            svgElement.style.userSelect = 'none';
            svgElement.style.webkitUserSelect = 'none';
            svgElement.style.mozUserSelect = 'none';
            svgElement.style.msUserSelect = 'none';
            svgElement.style.display = 'block'; // 确保可以居中
            
            // 为所有矩形框添加交互功能
            const rectangles = svgElement.querySelectorAll('rect');
            rectangles.forEach(rect => makeRectangleEditable(rect, svgElement));
            
            // 为所有文本元素添加交互功能
            const texts = svgElement.querySelectorAll('text');
            texts.forEach(text => makeTextEditable(text, svgElement));
            
            // 为其他元素类型添加交互功能
            const otherElements = svgElement.querySelectorAll('path, line, polygon, polyline, circle, ellipse');
            otherElements.forEach(element => makeOtherElementEditable(element, svgElement));
            
            // 添加全局拖拽功能
            setupSvgDragAndDrop(svgElement);
            
            // 重置缩放比例到100%
            window.svgZoomLevel = 1.0;
            svgElement.style.transform = '';
            svgElement.style.transformOrigin = '';
            
            // 更新缩放比例显示
            const zoomLevelElement = document.getElementById('svgZoomLevel');
            if (zoomLevelElement) {
                zoomLevelElement.textContent = '100%';
            }
        }

        // SVG缩放功能
        function zoomSvg(factor, canvas, zoomLevelElement) {
            const svgElement = canvas.querySelector('svg');
            if (!svgElement) return;
            
            // 更新缩放比例
            window.svgZoomLevel = window.svgZoomLevel * factor;
            
            // 限制缩放范围在10%到500%之间
            const minZoom = 0.1;
            const maxZoom = 5.0;
            if (window.svgZoomLevel < minZoom) {
                window.svgZoomLevel = minZoom;
            } else if (window.svgZoomLevel > maxZoom) {
                window.svgZoomLevel = maxZoom;
            }
            
            // 应用缩放变换
            // 使用transform scale来缩放SVG，保持原始尺寸以便编辑
            const currentTransform = svgElement.style.transform || '';
            const transformMatch = currentTransform.match(/scale\(([\d.]+)\)/);
            const baseScale = transformMatch ? parseFloat(transformMatch[1]) : 1.0;
            const newScale = window.svgZoomLevel;
            
            svgElement.style.transform = `scale(${newScale})`;
            svgElement.style.transformOrigin = 'center top'; // 从中心顶部开始缩放
            
            // 更新缩放比例显示
            if (zoomLevelElement) {
                zoomLevelElement.textContent = Math.round(window.svgZoomLevel * 100) + '%';
            }
        }

        // 使矩形框可编辑（可选中、拖拽）
        function makeRectangleEditable(rect, svgElement) {
            // 存储原始样式
            const originalStroke = rect.getAttribute('stroke') || 'black';
            const originalStrokeWidth = rect.getAttribute('stroke-width') || '1';

            // 保存到数据属性
            rect.setAttribute('data-original-stroke', originalStroke);
            rect.setAttribute('data-original-stroke-width', originalStrokeWidth);
            rect.setAttribute('data-selected', 'false');

            // 设置初始样式
            rect.style.cursor = 'pointer';
        }

        // 使其他元素可编辑（路径、线条、多边形等）
        function makeOtherElementEditable(element, svgElement) {
            // 存储原始样式
            const originalFill = element.getAttribute('fill') || 'none';
            const originalStroke = element.getAttribute('stroke') || 'black';
            const originalStrokeWidth = element.getAttribute('stroke-width') || '1';
            
            // 保存到数据属性
            element.setAttribute('data-original-fill', originalFill);
            element.setAttribute('data-original-stroke', originalStroke);
            element.setAttribute('data-original-stroke-width', originalStrokeWidth);
            element.setAttribute('data-selected', 'false');
            
            // 设置初始样式
            element.style.cursor = 'pointer';
        }

        // 设置SVG拖拽功能
        function setupSvgDragAndDrop(svgElement) {
            let isDragging = false;
            let draggedElement = null;
            let draggedElements = []; // 支持多选拖拽
            let startX, startY, elementStartX, elementStartY
            let lastMouseX, lastMouseY; // 记录上一次鼠标位置，用于计算相对位移
            let isSelecting = false; // 圈选模式
            let selectionBox = null; // 圈选框
            let selectionStartX, selectionStartY;
            const DRAG_THRESHOLD = 5; // 拖拽阈值，鼠标移动超过5px才开始拖拽
            let hasStartedDrag = false; // 标记是否已经开始拖拽
            let clickedElement = null; // 记录点击的元素，用于区分点击和拖拽

            // 添加鼠标按下事件监听器
            svgElement.addEventListener('mousedown', function(e) {
                const target = e.target;

                // 如果当前正在拖拽状态，点击鼠标左键停止拖拽
                if (isDragging && draggedElements.length > 0) {
                    // 结束拖拽
                    isDragging = false;
                    hasStartedDrag = false;
                    draggedElements.forEach(element => {
                        element.style.cursor = 'pointer';
                    });
                    draggedElement = null;
                    draggedElements = [];
                    e.preventDefault();
                    return;
                }

                // 如果点击的是空白区域，先检查附近是否有line元素（导线）
                if (target === svgElement || target.tagName === 'svg') {
                    // 检查附近是否有line元素（在2像素范围内）
                    const nearbyLine = findNearbyLineElement(svgElement, e.clientX, e.clientY, 2);
                    
                    if (nearbyLine) {
                        // 如果找到附近的line元素，选中它
                        clearAllSelections(svgElement);
                        clickedElement = nearbyLine;
                        startX = e.clientX;
                        startY = e.clientY;
                        hasStartedDrag = false;
                        
                        // 记录line元素的初始位置
                        elementStartX = parseFloat(nearbyLine.getAttribute('x1') || 0);
                        elementStartY = parseFloat(nearbyLine.getAttribute('y1') || 0);
                        
                        e.preventDefault();
                        return;
                    }
                    
                    // 如果没有找到附近的line元素，先清除所有选中状态，然后开始圈选
                    clearAllSelections(svgElement);

                    // 然后开始圈选
                    isSelecting = true;
                    selectionStartX = e.clientX;
                    selectionStartY = e.clientY;

                    // 创建圈选框
                    selectionBox = createSelectionBox(svgElement, e.clientX, e.clientY);
                    e.preventDefault();
                    return;
                }

                // 检查是否是可编辑元素，记录点击但不立即开始拖拽
                if (target.tagName === 'rect' || target.tagName === 'text' || target.tagName === 'path' || target.tagName === 'line' || target.tagName === 'polygon' || target.tagName === 'circle' || target.tagName === 'ellipse') {
                    // 检查是否是背景矩形（覆盖整个图的矩形），如果是就当作点击空白区域
                    if (target.tagName === 'rect' && isBackgroundRect(target, svgElement)) {
                        // 检查附近是否有line元素（在2像素范围内）
                        const nearbyLine = findNearbyLineElement(svgElement, e.clientX, e.clientY, 2);
                        
                        if (nearbyLine) {
                            // 如果找到附近的line元素，选中它
                            clearAllSelections(svgElement);
                            clickedElement = nearbyLine;
                            startX = e.clientX;
                            startY = e.clientY;
                            hasStartedDrag = false;
                            
                            // 记录line元素的初始位置
                            elementStartX = parseFloat(nearbyLine.getAttribute('x1') || 0);
                            elementStartY = parseFloat(nearbyLine.getAttribute('y1') || 0);
                            
                            e.preventDefault();
                            return;
                        }
                        
                        // 如果没有找到附近的line元素，先清除所有选中状态，然后开始圈选
                        clearAllSelections(svgElement);

                        // 然后开始圈选
                        isSelecting = true;
                        selectionStartX = e.clientX;
                        selectionStartY = e.clientY;

                        // 创建圈选框
                        selectionBox = createSelectionBox(svgElement, e.clientX, e.clientY);
                        e.preventDefault();
                        return;
                    }

                    // 获取点击位置下最小的元素（处理嵌套元素的情况）
                    const smallestElement = getSmallestElementAtPoint(svgElement, e.clientX, e.clientY);
                    const elementToSelect = smallestElement || target;

                    // 记录点击的元素和位置，用于后续判断是点击还是拖拽
                    clickedElement = elementToSelect;
                    startX = e.clientX;
                    startY = e.clientY;
                    hasStartedDrag = false;

                    // 记录元素初始位置（使用实际选中的元素）
                    if (elementToSelect.tagName === 'rect') {
                        elementStartX = parseFloat(elementToSelect.getAttribute('x') || 0);
                        elementStartY = parseFloat(elementToSelect.getAttribute('y') || 0);
                    } else if (elementToSelect.tagName === 'text') {
                        elementStartX = parseFloat(elementToSelect.getAttribute('x') || 0);
                        elementStartY = parseFloat(elementToSelect.getAttribute('y') || 0);
                    } else if (elementToSelect.tagName === 'path') {
                        // 对于路径元素，获取变换矩阵
                        const transform = elementToSelect.getAttribute('transform');
                        if (transform) {
                            const matrix = parseTransform(transform);
                            elementStartX = matrix.translateX || 0;
                            elementStartY = matrix.translateY || 0;
                        } else {
                            elementStartX = 0;
                            elementStartY = 0;
                        }
                    } else if (elementToSelect.tagName === 'line') {
                        elementStartX = parseFloat(elementToSelect.getAttribute('x1') || 0);
                        elementStartY = parseFloat(elementToSelect.getAttribute('y1') || 0);
                    } else if (elementToSelect.tagName === 'polygon' || elementToSelect.tagName === 'polyline') {
                        const points = elementToSelect.getAttribute('points');
                        if (points) {
                            const coords = points.split(/[\s,]+/).map(Number);
                            elementStartX = Math.min(...coords.filter((_, i) => i % 2 === 0));
                            elementStartY = Math.min(...coords.filter((_, i) => i % 2 === 1));
                        } else {
                            elementStartX = 0;
                            elementStartY = 0;
                        }
                    } else if (elementToSelect.tagName === 'circle' || elementToSelect.tagName === 'ellipse') {
                        elementStartX = parseFloat(elementToSelect.getAttribute('cx') || 0);
                        elementStartY = parseFloat(elementToSelect.getAttribute('cy') || 0);
                    }

                    e.preventDefault();
                }
            });
            
            // 添加鼠标移动事件监听器
            svgElement.addEventListener('mousemove', function(e) {
                if (isSelecting && selectionBox) {
                    // 更新圈选框
                    updateSelectionBox(selectionBox, selectionStartX, selectionStartY, e.clientX, e.clientY);
                    // 检查圈选范围内的元素
                    selectElementsInRange(svgElement, selectionStartX, selectionStartY, e.clientX, e.clientY);
                } else if (clickedElement && !isDragging) {
                    // 检查是否应该开始拖拽
                    const deltaX = Math.abs(e.clientX - startX);
                    const deltaY = Math.abs(e.clientY - startY);
                    if (deltaX > DRAG_THRESHOLD || deltaY > DRAG_THRESHOLD) {
                        // 开始拖拽
                        draggedElement = clickedElement;
                        isDragging = true;
                        hasStartedDrag = true;

                        // 检查是否已经有多个元素被选中
                        const currentlySelected = getSelectedElements(svgElement);

                        if (currentlySelected.length > 1 && currentlySelected.includes(clickedElement)) {
                            // 如果已经有多个元素被选中，且点击的元素也是其中之一，直接拖拽所有选中的元素
                            draggedElements = currentlySelected;
                        } else {
                            // 正常情况：选中当前元素并开始拖拽
                            if (e.ctrlKey || e.metaKey) {
                                toggleElementSelection(draggedElement, svgElement);
                            } else {
                                clearAllSelections(svgElement);
                                selectElement(draggedElement, svgElement);
                            }
                            draggedElements = getSelectedElements(svgElement);
                        }

                        draggedElement.style.cursor = 'grabbing';
                        lastMouseX = e.clientX;
                        lastMouseY = e.clientY;
                    }
                } else if (isDragging && draggedElements.length > 0) {
                    // 获取SVG容器的位置信息
                    const svgRect = svgElement.getBoundingClientRect();
                    const svgViewBox = svgElement.viewBox.baseVal;
                    
                    // 计算缩放比例
                    const scaleX = svgViewBox.width > 0 ? svgViewBox.width / svgRect.width : 1;
                    const scaleY = svgViewBox.height > 0 ? svgViewBox.height / svgRect.height : 1;
                    
                    // 将鼠标坐标转换为SVG坐标系
                    const currentMouseX = (e.clientX - svgRect.left) * scaleX;
                    const currentMouseY = (e.clientY - svgRect.top) * scaleY;
                    const lastMouseX_svg = (lastMouseX - svgRect.left) * scaleX;
                    const lastMouseY_svg = (lastMouseY - svgRect.top) * scaleY;

                    // 计算相对位移
                    const deltaX = currentMouseX - lastMouseX_svg;
                    const deltaY = currentMouseY - lastMouseY_svg;

                    // 更新上一次鼠标位置
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    
                    // 拖拽所有选中的元素
                    draggedElements.forEach((element, index) => {
                        const result = moveElement(element, deltaX, deltaY, svgElement);
                        // 如果moveElement返回了新的元素（克隆的），更新数组中的引用
                        if (result && result !== element) {
                            draggedElements[index] = result;
                        }
                    });
                }
            });
            
            // 添加鼠标释放事件监听器
            svgElement.addEventListener('mouseup', function(e) {
                if (isSelecting && selectionBox) {
                    // 结束圈选
                    isSelecting = false;
                    selectionBox.remove();
                    selectionBox = null;
                } else if (isDragging && draggedElements.length > 0) {
                    // 结束拖拽，元素保持选中状态（高亮）
                    isDragging = false;
                    hasStartedDrag = false;
                    draggedElements.forEach(element => {
                        element.style.cursor = 'pointer';
                    });
                    // 不清除draggedElement和draggedElements，保持选中状态
                } else if (clickedElement && !hasStartedDrag) {
                    // 处理点击选中操作
                    if (e.ctrlKey || e.metaKey) {
                        toggleElementSelection(clickedElement, svgElement);
                    } else {
                        clearAllSelections(svgElement);
                        selectElement(clickedElement, svgElement);
                    }
                }

                // 重置点击状态
                clickedElement = null;
                hasStartedDrag = false;
            });
            
            // 添加鼠标离开事件监听器，确保在鼠标离开SVG区域时停止拖拽
            svgElement.addEventListener('mouseleave', function() {
                if (isSelecting && selectionBox) {
                    isSelecting = false;
                    selectionBox.remove();
                    selectionBox = null;
                } else if (isDragging && draggedElements.length > 0) {
                    // 结束拖拽，元素保持选中状态（高亮）
                    isDragging = false;
                    hasStartedDrag = false;
                    draggedElements.forEach(element => {
                        element.style.cursor = 'pointer';
                    });
                    // 不清除draggedElement和draggedElements，保持选中状态
                }

                // 重置点击状态
                clickedElement = null;
                hasStartedDrag = false;
            });

            // 添加点击事件监听器，点击空白区域清除选中状态
            svgElement.addEventListener('click', function(e) {
                const target = e.target;
                // 如果点击的是SVG元素本身或背景矩形，清除所有选中状态
                if (target === svgElement || target.tagName === 'svg' ||
                    (target.tagName === 'rect' && isBackgroundRect(target, svgElement))) {
                    clearAllSelections(svgElement);
                    e.preventDefault();
                }
            });

            // 添加键盘事件监听器，处理Delete键删除选中的元素
            const handleKeyDown = function(e) {
                // 检查是否按下了Delete键或Backspace键
                if ((e.key === 'Delete' || e.key === 'Backspace') && !e.ctrlKey && !e.metaKey && !e.altKey) {
                    // 检查焦点是否在输入框中，如果是则不处理
                    const activeElement = document.activeElement;
                    if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                        return;
                    }
                    
                    // 检查是否有选中的元素
                    const selectedElements = getSelectedElements(svgElement);
                    if (selectedElements.length > 0) {
                        e.preventDefault();
                        e.stopPropagation();
                        // 通过键盘删除时跳过确认对话框
                        deleteSelectedElements(true);
                    }
                }
            };

            // 在SVG元素上添加键盘事件监听器
            svgElement.setAttribute('tabindex', '0'); // 使SVG元素可以获得焦点
            svgElement.addEventListener('keydown', handleKeyDown);
            
            // 当SVG元素获得焦点时，确保可以接收键盘事件
            svgElement.addEventListener('mousedown', function() {
                svgElement.focus();
            });
        }

        // 获取点击位置下最小的可编辑元素（用于处理嵌套元素）
        function getSmallestElementAtPoint(svgElement, clientX, clientY) {
            // 获取点击位置下的所有元素
            const elementsAtPoint = document.elementsFromPoint(clientX, clientY);
            
            // 过滤出可编辑的SVG元素
            const editableTags = ['rect', 'text', 'path', 'line', 'polygon', 'polyline', 'circle', 'ellipse'];
            const editableElements = elementsAtPoint.filter(el => {
                // 确保元素在SVG内部
                if (!svgElement.contains(el)) return false;
                // 确保是可编辑的元素类型
                return editableTags.includes(el.tagName.toLowerCase());
            });
            
            if (editableElements.length === 0) {
                return null;
            }
            
            // 如果只有一个元素，直接返回
            if (editableElements.length === 1) {
                return editableElements[0];
            }
            
            // 计算每个元素的面积，选择最小的
            let smallestElement = null;
            let smallestArea = Infinity;
            
            editableElements.forEach(element => {
                try {
                    const bbox = element.getBBox();
                    const area = bbox.width * bbox.height;
                    
                    if (area < smallestArea) {
                        smallestArea = area;
                        smallestElement = element;
                    }
                } catch (e) {
                    // 如果getBBox失败（例如元素不可见），跳过该元素
                    console.warn('无法获取元素边界框:', e);
                }
            });
            
            return smallestElement;
        }

        // 检测是否是背景矩形（覆盖整个图的矩形）
        function isBackgroundRect(rect, svgElement) {
            const svgRect = svgElement.getBoundingClientRect();
            const rectRect = rect.getBoundingClientRect();

            // 计算覆盖比例
            const coverageWidth = rectRect.width / svgRect.width;
            const coverageHeight = rectRect.height / svgRect.height;

            // 如果矩形覆盖了大部分SVG区域（比如超过80%），认为是背景矩形
            const coverageThreshold = 0.8;
            if (coverageWidth > coverageThreshold && coverageHeight > coverageThreshold) {
                // 进一步检查是否是透明或无填充的背景
                const fill = rect.getAttribute('fill');
                const stroke = rect.getAttribute('stroke');
                const opacity = rect.getAttribute('opacity') || rect.style.opacity;

                // 如果是透明、无填充或白色填充，可能是背景
                if (fill === 'none' || fill === 'transparent' || fill === '#ffffff' || fill === 'white' ||
                    opacity === '0' || opacity === '0.0' ||
                    (stroke === 'none' && (fill === 'none' || fill === 'transparent'))) {
                    return true;
                }
            }

            return false;
        }

        // 计算点到线段的距离
        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;

            if (lenSq !== 0) {
                param = dot / lenSq;
            }

            let xx, yy;

            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // 将屏幕坐标转换为SVG坐标
        function screenToSvgCoordinates(svgElement, clientX, clientY) {
            const svgRect = svgElement.getBoundingClientRect();
            const svgViewBox = svgElement.viewBox.baseVal;
            
            // 计算缩放比例
            const scaleX = svgViewBox.width > 0 ? svgViewBox.width / svgRect.width : 1;
            const scaleY = svgViewBox.height > 0 ? svgViewBox.height / svgRect.height : 1;
            
            // 转换为SVG坐标系
            const svgX = (clientX - svgRect.left) * scaleX;
            const svgY = (clientY - svgRect.top) * scaleY;
            
            return { x: svgX, y: svgY, scaleX: scaleX, scaleY: scaleY };
        }

        // 获取line元素的实际坐标（考虑transform）
        function getLineTransformedCoordinates(line) {
            let x1 = parseFloat(line.getAttribute('x1') || 0);
            let y1 = parseFloat(line.getAttribute('y1') || 0);
            let x2 = parseFloat(line.getAttribute('x2') || 0);
            let y2 = parseFloat(line.getAttribute('y2') || 0);
            
            // 检查是否有transform属性
            const transform = line.getAttribute('transform');
            if (transform) {
                // 处理translate变换
                const translateMatch = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                if (translateMatch) {
                    const tx = parseFloat(translateMatch[1]);
                    const ty = parseFloat(translateMatch[2]);
                    x1 += tx;
                    y1 += ty;
                    x2 += tx;
                    y2 += ty;
                }
            }
            
            return { x1, y1, x2, y2 };
        }

        // 查找鼠标位置附近的line元素（导线）
        function findNearbyLineElement(svgElement, clientX, clientY, tolerancePixels = 2) {
            const svgPoint = screenToSvgCoordinates(svgElement, clientX, clientY);
            const allLines = svgElement.querySelectorAll('line');
            
            // 将像素容差转换为SVG坐标系的容差
            const tolerance = tolerancePixels * Math.max(svgPoint.scaleX, svgPoint.scaleY);
            
            let closestLine = null;
            let minDistance = tolerance;
            
            allLines.forEach(line => {
                const coords = getLineTransformedCoordinates(line);
                
                // 计算点到线段的距离
                const distance = pointToLineDistance(
                    svgPoint.x, svgPoint.y, 
                    coords.x1, coords.y1, 
                    coords.x2, coords.y2
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestLine = line;
                }
            });
            
            return closestLine;
        }

        // 清除所有选中状态
        function clearAllSelections(svgElement) {
            const allElements = svgElement.querySelectorAll('rect, text, path, line, polygon, polyline, circle, ellipse');
            allElements.forEach(element => {
                element.setAttribute('data-selected', 'false');
                // 恢复原始样式
                if (element.tagName === 'rect') {
                    element.setAttribute('stroke', element.getAttribute('data-original-stroke') || 'black');
                    element.setAttribute('stroke-width', element.getAttribute('data-original-stroke-width') || '1');
                    removeResizeHandle(element, svgElement);
                } else if (element.tagName === 'text') {
                    element.setAttribute('fill', element.getAttribute('data-original-fill') || 'black');
                    element.setAttribute('stroke', element.getAttribute('data-original-stroke') || 'none');
                    element.setAttribute('stroke-width', element.getAttribute('data-original-stroke-width') || '0');
                } else {
                    // 其他元素类型的高亮处理
                    element.style.filter = '';
                    element.style.opacity = '';
                }
            });
        }

        // 选中元素
        function selectElement(element, svgElement) {
            element.setAttribute('data-selected', 'true');
            
            if (element.tagName === 'rect') {
                element.setAttribute('stroke', '#007acc');
                element.setAttribute('stroke-width', '3');
                addResizeHandle(element, svgElement);
            } else if (element.tagName === 'text') {
                element.setAttribute('fill', '#007acc');
                element.setAttribute('stroke', '#ffffff');
                element.setAttribute('stroke-width', '1');
            } else {
                // 其他元素类型的高亮
                element.style.filter = 'drop-shadow(0 0 3px #007acc)';
                element.style.opacity = '0.8';
            }
        }

        // 切换元素选中状态
        function toggleElementSelection(element, svgElement) {
            const isSelected = element.getAttribute('data-selected') === 'true';
            if (isSelected) {
                element.setAttribute('data-selected', 'false');
                // 恢复原始样式
                if (element.tagName === 'rect') {
                    element.setAttribute('stroke', element.getAttribute('data-original-stroke') || 'black');
                    element.setAttribute('stroke-width', element.getAttribute('data-original-stroke-width') || '1');
                    removeResizeHandle(element, svgElement);
                } else if (element.tagName === 'text') {
                    element.setAttribute('fill', element.getAttribute('data-original-fill') || 'black');
                    element.setAttribute('stroke', element.getAttribute('data-original-stroke') || 'none');
                    element.setAttribute('stroke-width', element.getAttribute('data-original-stroke-width') || '0');
                } else {
                    element.style.filter = '';
                    element.style.opacity = '';
                }
            } else {
                selectElement(element, svgElement);
            }
        }

        // 获取所有选中的元素
        function getSelectedElements(svgElement) {
            const selectedElements = [];
            const allElements = svgElement.querySelectorAll('rect, text, path, line, polygon, polyline, circle, ellipse');
            allElements.forEach(element => {
                if (element.getAttribute('data-selected') === 'true') {
                    selectedElements.push(element);
                }
            });
            return selectedElements;
        }

        // 移动元素
        function moveElement(element, deltaX, deltaY, svgElement) {
            // 标记SVG已被修改
            window.svgModified = true;

            const svgViewBox = svgElement.viewBox.baseVal;
            const svgWidth = parseFloat(svgElement.getAttribute('width') || svgViewBox.width || 400);
            const svgHeight = parseFloat(svgElement.getAttribute('height') || svgViewBox.height || 300);

            // 辅助函数：计算父元素的transform偏移
            function getParentTransformOffset(element) {
                let parentTransformX = 0;
                let parentTransformY = 0;
                let parent = element.parentElement;

                // 累积父元素的transform
                while (parent && parent !== svgElement) {
                    const transform = parent.getAttribute('transform');
                    if (transform) {
                        const translateMatch = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                        if (translateMatch) {
                            parentTransformX += parseFloat(translateMatch[1]) || 0;
                            parentTransformY += parseFloat(translateMatch[2]) || 0;
                        }
                    }
                    parent = parent.parentElement;
                }

                return { parentTransformX, parentTransformY };
            }

            // 辅助函数：处理元素从父组中移出到根层级
            function moveElementToRoot(element, targetGlobalX, targetGlobalY) {
                const originalParent = element.parentElement;
                if (originalParent !== svgElement) {
                    // 克隆所有样式和属性
                    const clonedElement = element.cloneNode(true);

                    // 设置新的全局坐标
                    clonedElement.setAttribute('x', targetGlobalX);
                    clonedElement.setAttribute('y', targetGlobalY);
                    clonedElement.setAttribute('cx', targetGlobalX);
                    clonedElement.setAttribute('cy', targetGlobalY);
                    clonedElement.setAttribute('x1', targetGlobalX);
                    clonedElement.setAttribute('y1', targetGlobalY);
                    clonedElement.setAttribute('x2', targetGlobalX);
                    clonedElement.setAttribute('y2', targetGlobalY);

                    // 处理points属性（polygon, polyline）
                    if (clonedElement.hasAttribute('points')) {
                        const points = clonedElement.getAttribute('points');
                        const coords = points.split(/[\s,]+/).map(Number);
                        const newCoords = coords.map((coord, index) => {
                            if (index % 2 === 0) { // x坐标
                                return coord + targetGlobalX - parseFloat(element.getAttribute('x') || 0);
                            } else { // y坐标
                                return coord + targetGlobalY - parseFloat(element.getAttribute('y') || 0);
                            }
                        });
                        clonedElement.setAttribute('points', newCoords.join(','));
                    }

                    // 将克隆的元素添加到SVG根层级
                    svgElement.appendChild(clonedElement);

                    // 移除原来的元素
                    originalParent.removeChild(element);

                    // 返回克隆元素
                    return clonedElement;
                }
                return element;
            }
            
            if (element.tagName === 'rect') {
                const { parentTransformX, parentTransformY } = getParentTransformOffset(element);
                const currentX = parseFloat(element.getAttribute('x') || 0);
                const currentY = parseFloat(element.getAttribute('y') || 0);
                const width = parseFloat(element.getAttribute('width') || 0);
                const height = parseFloat(element.getAttribute('height') || 0);

                // 如果有父transform，为了实现自由移动，需要将元素移出父组
                if (parentTransformX !== 0 || parentTransformY !== 0) {
                    // 计算元素在SVG全局坐标系中的实际位置
                    const globalX = currentX + parentTransformX;
                    const globalY = currentY + parentTransformY;

                    // 计算移动后的全局位置
                    let targetGlobalX = globalX + deltaX;
                    let targetGlobalY = globalY + deltaY;

                    // 边界检查
                    targetGlobalX = Math.max(0, Math.min(targetGlobalX, svgWidth - width));
                    targetGlobalY = Math.max(0, Math.min(targetGlobalY, svgHeight - height));

                    // 将元素移出父组，放到SVG根层级
                    const resultElement = moveElementToRoot(element, targetGlobalX, targetGlobalY);
                    updateResizeHandle(resultElement, svgElement);
                    return resultElement;
                } else {
                    // 没有父transform，正常处理
                    let newX = currentX + deltaX;
                    let newY = currentY + deltaY;

                    // 边界检查
                    newX = Math.max(0, Math.min(newX, svgWidth - width));
                    newY = Math.max(0, Math.min(newY, svgHeight - height));

                    element.setAttribute('x', newX);
                    element.setAttribute('y', newY);
                    updateResizeHandle(element, svgElement);
                }

            } else if (element.tagName === 'text') {
                const { parentTransformX, parentTransformY } = getParentTransformOffset(element);
                const currentX = parseFloat(element.getAttribute('x') || 0);
                const currentY = parseFloat(element.getAttribute('y') || 0);

                // 如果有父transform，为了实现自由移动，需要将元素移出父组
                if (parentTransformX !== 0 || parentTransformY !== 0) {
                    // 计算文本在SVG全局坐标系中的实际位置
                    const globalX = currentX + parentTransformX;
                    const globalY = currentY + parentTransformY;

                    // 计算移动后的全局位置
                    let targetGlobalX = globalX + deltaX;
                    let targetGlobalY = globalY + deltaY;

                    // 边界检查（文本没有固定尺寸，简单检查）
                    targetGlobalX = Math.max(0, Math.min(targetGlobalX, svgWidth));
                    targetGlobalY = Math.max(0, Math.min(targetGlobalY, svgHeight));

                    // 将元素移出父组，放到SVG根层级
                    const resultElement = moveElementToRoot(element, targetGlobalX, targetGlobalY);
                    return resultElement;
                } else {
                    // 没有父transform，正常处理
                    let newX = currentX + deltaX;
                    let newY = currentY + deltaY;

                    // 边界检查（文本没有固定尺寸，简单检查）
                    newX = Math.max(0, Math.min(newX, svgWidth));
                    newY = Math.max(0, Math.min(newY, svgHeight));

                    element.setAttribute('x', newX);
                    element.setAttribute('y', newY);
                }

            } else if (element.tagName === 'path') {
                const { parentTransformX, parentTransformY } = getParentTransformOffset(element);

                // 如果有父transform，为了实现自由移动，需要将元素移出父组
                if (parentTransformX !== 0 || parentTransformY !== 0) {
                    // 计算移动后的全局位置
                    let targetGlobalX = parentTransformX + deltaX;
                    let targetGlobalY = parentTransformY + deltaY;

                    // 边界检查（path没有固定尺寸，简单检查）
                    targetGlobalX = Math.max(0, Math.min(targetGlobalX, svgWidth));
                    targetGlobalY = Math.max(0, Math.min(targetGlobalY, svgHeight));

                    // 将元素移出父组，放到SVG根层级
                    const resultElement = moveElementToRoot(element, targetGlobalX, targetGlobalY);
                    // 为path元素设置transform
                    resultElement.setAttribute('transform', `translate(${targetGlobalX},${targetGlobalY})`);
                    return resultElement;
                } else {
                    // 对于路径，使用变换矩阵
                    const transform = element.getAttribute('transform') || '';
                    const matrix = parseTransform(transform);
                    const newTranslateX = (matrix.translateX || 0) + deltaX;
                    const newTranslateY = (matrix.translateY || 0) + deltaY;

                    element.setAttribute('transform', `translate(${newTranslateX},${newTranslateY})`);
                }

            } else if (element.tagName === 'line') {
                const { parentTransformX, parentTransformY } = getParentTransformOffset(element);
                const x1 = parseFloat(element.getAttribute('x1') || 0);
                const y1 = parseFloat(element.getAttribute('y1') || 0);
                const x2 = parseFloat(element.getAttribute('x2') || 0);
                const y2 = parseFloat(element.getAttribute('y2') || 0);

                // 如果有父transform，为了实现自由移动，需要将元素移出父组
                if (parentTransformX !== 0 || parentTransformY !== 0) {
                    // 计算元素在SVG全局坐标系中的实际位置
                    const globalX1 = x1 + parentTransformX;
                    const globalY1 = y1 + parentTransformY;
                    const globalX2 = x2 + parentTransformX;
                    const globalY2 = y2 + parentTransformY;

                    // 计算移动后的全局位置
                    let targetGlobalX1 = globalX1 + deltaX;
                    let targetGlobalY1 = globalY1 + deltaY;
                    let targetGlobalX2 = globalX2 + deltaX;
                    let targetGlobalY2 = globalY2 + deltaY;

                    // 边界检查
                    targetGlobalX1 = Math.max(0, Math.min(targetGlobalX1, svgWidth));
                    targetGlobalY1 = Math.max(0, Math.min(targetGlobalY1, svgHeight));
                    targetGlobalX2 = Math.max(0, Math.min(targetGlobalX2, svgWidth));
                    targetGlobalY2 = Math.max(0, Math.min(targetGlobalY2, svgHeight));

                    // 将元素移出父组，放到SVG根层级
                    const resultElement = moveElementToRoot(element, targetGlobalX1, targetGlobalY1);
                    resultElement.setAttribute('x1', targetGlobalX1);
                    resultElement.setAttribute('y1', targetGlobalY1);
                    resultElement.setAttribute('x2', targetGlobalX2);
                    resultElement.setAttribute('y2', targetGlobalY2);
                    return resultElement;
                } else {
                    // 没有父transform，正常处理
                    let newX1 = x1 + deltaX;
                    let newY1 = y1 + deltaY;
                    let newX2 = x2 + deltaX;
                    let newY2 = y2 + deltaY;

                    // 边界检查
                    newX1 = Math.max(0, Math.min(newX1, svgWidth));
                    newY1 = Math.max(0, Math.min(newY1, svgHeight));
                    newX2 = Math.max(0, Math.min(newX2, svgWidth));
                    newY2 = Math.max(0, Math.min(newY2, svgHeight));

                    element.setAttribute('x1', newX1);
                    element.setAttribute('y1', newY1);
                    element.setAttribute('x2', newX2);
                    element.setAttribute('y2', newY2);
                }

            } else if (element.tagName === 'polygon' || element.tagName === 'polyline') {
                const { parentTransformX, parentTransformY } = getParentTransformOffset(element);
                const points = element.getAttribute('points');

                if (points) {
                    // 如果有父transform，为了实现自由移动，需要将元素移出父组
                    if (parentTransformX !== 0 || parentTransformY !== 0) {
                        const coords = points.split(/[\s,]+/).map(Number);
                        // 计算第一个点的全局坐标作为基准点
                        const baseX = coords[0] + parentTransformX;
                        const baseY = coords[1] + parentTransformY;

                        // 计算移动后的基准点位置
                        let targetBaseX = baseX + deltaX;
                        let targetBaseY = baseY + deltaY;

                        // 边界检查（简单检查基准点）
                        targetBaseX = Math.max(0, Math.min(targetBaseX, svgWidth));
                        targetBaseY = Math.max(0, Math.min(targetBaseY, svgHeight));

                        // 将元素移出父组，放到SVG根层级
                        const resultElement = moveElementToRoot(element, targetBaseX, targetBaseY);

                        // 重新计算所有点的坐标
                        const offsetX = targetBaseX - baseX;
                        const offsetY = targetBaseY - baseY;
                        const newCoords = coords.map((coord, index) => {
                            if (index % 2 === 0) { // x坐标
                                return coord + offsetX;
                            } else { // y坐标
                                return coord + offsetY;
                            }
                        });
                        resultElement.setAttribute('points', newCoords.join(','));
                        return resultElement;
                    } else {
                        // 没有父transform，正常处理
                        const coords = points.split(/[\s,]+/).map(Number);
                        const newCoords = coords.map((coord, index) => {
                            if (index % 2 === 0) { // x坐标
                                return Math.max(0, Math.min(coord + deltaX, svgWidth));
                            } else { // y坐标
                                return Math.max(0, Math.min(coord + deltaY, svgHeight));
                            }
                        });
                        element.setAttribute('points', newCoords.join(','));
                    }
                }

            } else if (element.tagName === 'circle' || element.tagName === 'ellipse') {
                const { parentTransformX, parentTransformY } = getParentTransformOffset(element);
                const cx = parseFloat(element.getAttribute('cx') || 0);
                const cy = parseFloat(element.getAttribute('cy') || 0);
                const r = parseFloat(element.getAttribute('r') || 0);
                const rx = parseFloat(element.getAttribute('rx') || 0);
                const ry = parseFloat(element.getAttribute('ry') || 0);

                // 如果有父transform，为了实现自由移动，需要将元素移出父组
                if (parentTransformX !== 0 || parentTransformY !== 0) {
                    // 计算元素在SVG全局坐标系中的实际位置
                    const globalCx = cx + parentTransformX;
                    const globalCy = cy + parentTransformY;

                    // 计算移动后的全局位置
                    let targetGlobalCx = globalCx + deltaX;
                    let targetGlobalCy = globalCy + deltaY;

                    // 边界检查
                    const radius = r || Math.max(rx, ry);
                    targetGlobalCx = Math.max(radius, Math.min(targetGlobalCx, svgWidth - radius));
                    targetGlobalCy = Math.max(radius, Math.min(targetGlobalCy, svgHeight - radius));

                    // 将元素移出父组，放到SVG根层级
                    const resultElement = moveElementToRoot(element, targetGlobalCx, targetGlobalCy);
                    resultElement.setAttribute('cx', targetGlobalCx);
                    resultElement.setAttribute('cy', targetGlobalCy);
                    return resultElement;
                } else {
                    // 没有父transform，正常处理
                    let newCx = cx + deltaX;
                    let newCy = cy + deltaY;

                    // 边界检查
                    const radius = r || Math.max(rx, ry);
                    newCx = Math.max(radius, Math.min(newCx, svgWidth - radius));
                    newCy = Math.max(radius, Math.min(newCy, svgHeight - radius));

                    element.setAttribute('cx', newCx);
                    element.setAttribute('cy', newCy);
                }
            }
        }

        // 解析变换矩阵
        function parseTransform(transform) {
            const matrix = { translateX: 0, translateY: 0, scaleX: 1, scaleY: 1, rotate: 0 };
            if (!transform) return matrix;
            
            const translateMatch = transform.match(/translate\(([^,)]+),([^)]+)\)/);
            if (translateMatch) {
                matrix.translateX = parseFloat(translateMatch[1]) || 0;
                matrix.translateY = parseFloat(translateMatch[2]) || 0;
            }
            
            const scaleMatch = transform.match(/scale\(([^,)]+)(?:,([^)]+))?\)/);
            if (scaleMatch) {
                matrix.scaleX = parseFloat(scaleMatch[1]) || 1;
                matrix.scaleY = parseFloat(scaleMatch[2]) || matrix.scaleX;
            }
            
            const rotateMatch = transform.match(/rotate\(([^)]+)\)/);
            if (rotateMatch) {
                matrix.rotate = parseFloat(rotateMatch[1]) || 0;
            }
            
            return matrix;
        }

        // 创建圈选框
        function createSelectionBox(svgElement, clientX, clientY) {
            // 将屏幕坐标转换为SVG坐标
            const svgRect = svgElement.getBoundingClientRect();
            const svgViewBox = svgElement.viewBox.baseVal;

            const scaleX = svgViewBox.width > 0 ? svgViewBox.width / svgRect.width : 1;
            const scaleY = svgViewBox.height > 0 ? svgViewBox.height / svgRect.height : 1;

            const svgX = (clientX - svgRect.left) * scaleX;
            const svgY = (clientY - svgRect.top) * scaleY;

            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', svgX);
            rect.setAttribute('y', svgY);
            rect.setAttribute('width', '0');
            rect.setAttribute('height', '0');
            rect.setAttribute('fill', 'rgba(0, 122, 204, 0.1)');
            rect.setAttribute('stroke', '#007acc');
            rect.setAttribute('stroke-width', '1');
            rect.setAttribute('stroke-dasharray', '5,5');
            rect.setAttribute('class', 'selection-box');
            rect.style.pointerEvents = 'none';

            svgElement.appendChild(rect);
            return rect;
        }

        // 更新圈选框
        function updateSelectionBox(selectionBox, startClientX, startClientY, currentClientX, currentClientY) {
            const svgElement = selectionBox.parentNode;
            const svgRect = svgElement.getBoundingClientRect();
            const svgViewBox = svgElement.viewBox.baseVal;

            const scaleX = svgViewBox.width > 0 ? svgViewBox.width / svgRect.width : 1;
            const scaleY = svgViewBox.height > 0 ? svgViewBox.height / svgRect.height : 1;

            const svgStartX = (startClientX - svgRect.left) * scaleX;
            const svgStartY = (startClientY - svgRect.top) * scaleY;
            const svgCurrentX = (currentClientX - svgRect.left) * scaleX;
            const svgCurrentY = (currentClientY - svgRect.top) * scaleY;

            const x = Math.min(svgStartX, svgCurrentX);
            const y = Math.min(svgStartY, svgCurrentY);
            const width = Math.abs(svgCurrentX - svgStartX);
            const height = Math.abs(svgCurrentY - svgStartY);

            selectionBox.setAttribute('x', x);
            selectionBox.setAttribute('y', y);
            selectionBox.setAttribute('width', width);
            selectionBox.setAttribute('height', height);
        }

        // 选择圈选范围内的元素
        function selectElementsInRange(svgElement, startX, startY, endX, endY) {
            const allElements = svgElement.querySelectorAll('rect, text, path, line, polygon, polyline, circle, ellipse');
            
            // 将屏幕坐标转换为SVG坐标
            const svgRect = svgElement.getBoundingClientRect();
            const svgViewBox = svgElement.viewBox.baseVal;
            const scaleX = svgViewBox.width > 0 ? svgViewBox.width / svgRect.width : 1;
            const scaleY = svgViewBox.height > 0 ? svgViewBox.height / svgRect.height : 1;
            
            const svgStartX = (startX - svgRect.left) * scaleX;
            const svgStartY = (startY - svgRect.top) * scaleY;
            const svgEndX = (endX - svgRect.left) * scaleX;
            const svgEndY = (endY - svgRect.top) * scaleY;
            
            const selectionRect = {
                x: Math.min(svgStartX, svgEndX),
                y: Math.min(svgStartY, svgEndY),
                width: Math.abs(svgEndX - svgStartX),
                height: Math.abs(svgEndY - svgStartY)
            };
            
            allElements.forEach(element => {
                if (isElementInRange(element, selectionRect, svgElement)) {
                    selectElement(element, svgElement);
                }
            });
        }

        // 检查元素是否在圈选范围内（必须完全包含在圈选框内）
        function isElementInRange(element, selectionRect, svgElement) {
            const svgRect = svgElement.getBoundingClientRect();
            const elementRect = element.getBoundingClientRect();

            // 转换为SVG坐标系
            const elementX = elementRect.left - svgRect.left;
            const elementY = elementRect.top - svgRect.top;
            const elementWidth = elementRect.width;
            const elementHeight = elementRect.height;

            // 检查元素是否完全包含在选择框内
            return elementX >= selectionRect.x &&
                   elementY >= selectionRect.y &&
                   elementX + elementWidth <= selectionRect.x + selectionRect.width &&
                   elementY + elementHeight <= selectionRect.y + selectionRect.height;
        }

        // 获取元素的实际坐标（考虑transform）
        function getElementTransformedPosition(element) {
            let x = parseFloat(element.getAttribute('x') || 0);
            let y = parseFloat(element.getAttribute('y') || 0);

            // 遍历父元素，累积transform
            let parent = element.parentElement;
            while (parent && parent !== element.ownerSVGElement) {
                const transform = parent.getAttribute('transform');
                if (transform) {
                    // 处理translate变换
                    const translateMatch = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                    if (translateMatch) {
                        const tx = parseFloat(translateMatch[1]);
                        const ty = parseFloat(translateMatch[2]);
                        x += tx;
                        y += ty;
                    }
                }
                parent = parent.parentElement;
            }

            return { x, y };
        }

        // 添加缩放控制点
        function addResizeHandle(rect, svgElement) {
            // 移除已存在的控制点
            removeResizeHandle(rect, svgElement);

            const { x, y } = getElementTransformedPosition(rect);
            const width = parseFloat(rect.getAttribute('width') || 0);
            const height = parseFloat(rect.getAttribute('height') || 0);

            // 创建右下角缩放控制点
            const handle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            handle.setAttribute('cx', x + width);
            handle.setAttribute('cy', y + height);
            handle.setAttribute('r', '4');
            handle.setAttribute('fill', '#007acc');
            handle.setAttribute('stroke', '#ffffff');
            handle.setAttribute('stroke-width', '1');
            handle.setAttribute('class', 'resize-handle');

            // 为矩形设置ID（如果没有的话）
            if (!rect.getAttribute('id')) {
                rect.setAttribute('id', 'rect-' + Date.now());
            }
            handle.setAttribute('data-parent-rect', rect.getAttribute('id'));

            // 插入到SVG中
            svgElement.appendChild(handle);
            
            // 添加缩放拖拽事件
            let isResizing = false;
            let startMouseX, startMouseY, startRectX, startRectY, startRectWidth, startRectHeight;
            
            handle.addEventListener('mousedown', function(e) {
                e.stopPropagation();
                isResizing = true;
                startMouseX = e.clientX;
                startMouseY = e.clientY;
                const { x: transformedX, y: transformedY } = getElementTransformedPosition(rect);
                startRectX = transformedX;
                startRectY = transformedY;
                startRectWidth = parseFloat(rect.getAttribute('width') || 0);
                startRectHeight = parseFloat(rect.getAttribute('height') || 0);
                
                const onMouseMove = function(e) {
                    if (!isResizing) return;
                    
                    // 获取SVG容器的位置信息
                    const svgRect = svgElement.getBoundingClientRect();
                    const svgViewBox = svgElement.viewBox.baseVal;
                    
                    // 计算缩放比例
                    const scaleX = svgViewBox.width > 0 ? svgViewBox.width / svgRect.width : 1;
                    const scaleY = svgViewBox.height > 0 ? svgViewBox.height / svgRect.height : 1;
                    
                    // 计算鼠标位移
                    const deltaX = (e.clientX - startMouseX) * scaleX;
                    const deltaY = (e.clientY - startMouseY) * scaleY;
                    
                    // 计算新的宽度和高度
                    let newWidth = startRectWidth + deltaX;
                    let newHeight = startRectHeight + deltaY;
                    
                    // 限制最小尺寸
                    newWidth = Math.max(10, newWidth);
                    newHeight = Math.max(10, newHeight);
                    
                    // 确保不超出SVG边界
                    const svgWidth = parseFloat(svgElement.getAttribute('width') || svgViewBox.width || 400);
                    const svgHeight = parseFloat(svgElement.getAttribute('height') || svgViewBox.height || 300);
                    
                    newWidth = Math.min(newWidth, svgWidth - startRectX);
                    newHeight = Math.min(newHeight, svgHeight - startRectY);
                    
                    // 更新矩形
                    rect.setAttribute('width', newWidth);
                    rect.setAttribute('height', newHeight);

                    // 标记SVG已被修改
                    window.svgModified = true;

                    // 更新控制点位置
                    handle.setAttribute('cx', startRectX + newWidth);
                    handle.setAttribute('cy', startRectY + newHeight);
                };
                
                const onMouseUp = function() {
                    isResizing = false;
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        // 移除缩放控制点
        function removeResizeHandle(rect, svgElement) {
            const rectId = rect.getAttribute('id');
            if (rectId) {
                const handles = svgElement.querySelectorAll(`[data-parent-rect="${rectId}"]`);
                handles.forEach(handle => handle.remove());
            }
        }

        // 更新缩放控制点位置
        function updateResizeHandle(rect, svgElement) {
            const rectId = rect.getAttribute('id');
            if (rectId) {
                const handle = svgElement.querySelector(`[data-parent-rect="${rectId}"]`);
                if (handle) {
                    const { x, y } = getElementTransformedPosition(rect);
                    const width = parseFloat(rect.getAttribute('width') || 0);
                    const height = parseFloat(rect.getAttribute('height') || 0);

                    handle.setAttribute('cx', x + width);
                    handle.setAttribute('cy', y + height);
                }
            }
        }

        // 使文本可编辑
        function makeTextEditable(textElement, svgElement) {
            // 存储原始样式
            const originalFill = textElement.getAttribute('fill') || 'black';
            const originalStroke = textElement.getAttribute('stroke') || 'none';
            const originalStrokeWidth = textElement.getAttribute('stroke-width') || '0';
            
            // 保存到数据属性
            textElement.setAttribute('data-original-fill', originalFill);
            textElement.setAttribute('data-original-stroke', originalStroke);
            textElement.setAttribute('data-original-stroke-width', originalStrokeWidth);
            textElement.setAttribute('data-selected', 'false');
            
            // 双击编辑文本
            textElement.addEventListener('dblclick', function(e) {
                e.stopPropagation();
                
                const currentText = textElement.textContent;
                const newText = prompt('编辑文本:', currentText);
                
                if (newText !== null && newText !== currentText) {
                    textElement.textContent = newText;
                    // 标记SVG已被修改
                    window.svgModified = true;
                }
            });
            
            // 设置初始样式
            textElement.style.cursor = 'pointer';
        }

        // 清理SVG用于保存（移除编辑器临时状态）
        function cleanupSvgForSave(svgElement) {
            // 获取所有SVG元素
            const allElements = svgElement.querySelectorAll('*');

            allElements.forEach(element => {
                // 恢复原始样式属性（如果存在）
                if (element.hasAttribute('data-original-stroke')) {
                    element.setAttribute('stroke', element.getAttribute('data-original-stroke'));
                }
                if (element.hasAttribute('data-original-stroke-width')) {
                    element.setAttribute('stroke-width', element.getAttribute('data-original-stroke-width'));
                }
                if (element.hasAttribute('data-original-fill')) {
                    element.setAttribute('fill', element.getAttribute('data-original-fill'));
                }

                // 移除编辑器相关的临时属性
                element.removeAttribute('data-selected');
                element.removeAttribute('data-original-stroke');
                element.removeAttribute('data-original-stroke-width');
                element.removeAttribute('data-original-fill');
                element.removeAttribute('data-parent-rect');

                // 清除可能的临时样式（只清除cursor样式）
                if (element.style.cursor && element.style.cursor !== '') {
                    element.style.cursor = '';
                }
            });

            // 移除所有缩放控制点
            const resizeHandles = svgElement.querySelectorAll('.resize-handle');
            resizeHandles.forEach(handle => handle.remove());

            // 移除所有圈选框
            const selectionBoxes = svgElement.querySelectorAll('.selection-box');
            selectionBoxes.forEach(box => box.remove());
            
            // 移除SVG根元素的所有编辑器相关样式
            // 这些只是用于编辑器显示的视觉样式，不应该保存到文件中
            const editorStyles = [
                'transform',           // 缩放变换
                'transformOrigin',     // 变换原点
                'maxWidth',            // 最大宽度限制
                'maxHeight',           // 最大高度限制
                'cursor',              // 鼠标样式
                'userSelect',          // 用户选择
                'webkitUserSelect',    // WebKit用户选择
                'mozUserSelect',       // Mozilla用户选择
                'msUserSelect',        // MS用户选择
                'display'              // 显示方式（block等）
            ];
            
            editorStyles.forEach(styleProp => {
                // 使用 removeProperty 方法确保完全移除样式
                if (svgElement.style[styleProp] || svgElement.style.getPropertyValue(styleProp)) {
                    svgElement.style.removeProperty(styleProp);
                }
            });
            
            // 如果 style 属性为空，完全移除它
            if (svgElement.style && svgElement.style.cssText.trim() === '') {
                svgElement.removeAttribute('style');
            }
        }

        // 删除选中的元素
        function deleteSelectedElements(skipConfirm = false) {
            // 标记SVG已被修改
            window.svgModified = true;

            // 获取I18N对象用于国际化
            const I18N = window.I18N || JSON.parse(document.getElementById('i18nData')?.textContent || '{}');

            const canvas = document.getElementById('svgCanvas');
            const svgElement = canvas.querySelector('svg');

            if (!svgElement) {
                const noContentMsg = I18N?.lang === 'zh' ? '没有可编辑的SVG内容' : 'No editable SVG content';
                alert(noContentMsg);
                return;
            }

            // 获取所有选中的元素
            const selectedElements = getSelectedElements(svgElement);

            if (selectedElements.length === 0) {
                // 如果通过键盘调用且没有选中元素，静默返回（不显示警告）
                if (skipConfirm) {
                    return;
                }
                const selectFirstMsg = I18N?.lang === 'zh'
                    ? '请先选择要删除的元素（点击或圈选元素使其高亮显示）'
                    : 'Please select elements to delete first (click or drag-select to highlight elements)';
                alert(selectFirstMsg);
                return;
            }

            // 确认删除（如果skipConfirm为true则跳过）
            if (!skipConfirm) {
                const confirmMsg = CURRENT_LANG === 'zh'
                    ? I18N.confirm_delete_elements.replace('{count}', selectedElements.length)
                    : I18N.confirm_delete_elements.replace('{count}', selectedElements.length);
                if (!confirm(confirmMsg)) {
                    return;
                }
            }

            // 先清理SVG中所有残留的缩放控制点，避免删除元素后残留
            const allResizeHandles = svgElement.querySelectorAll('.resize-handle');
            allResizeHandles.forEach(handle => handle.remove());

            // 删除选中的元素
            selectedElements.forEach(element => {
                // 删除元素
                element.remove();
            });

            console.log(`已删除 ${selectedElements.length} 个元素`);
        }

        // 保存SVG
        function saveSvg(callback) {
            // 获取I18N对象用于国际化
            const I18N = window.I18N || JSON.parse(document.getElementById('i18nData')?.textContent || '{}');

            const canvas = document.getElementById('svgCanvas');
            const svgElement = canvas.querySelector('svg');

            if (!svgElement) {
                const noContentMsg = I18N?.lang === 'zh' ? '没有可保存的SVG内容' : 'No SVG content to save';
                alert(noContentMsg);
                return;
            }

            // 创建SVG副本用于保存，避免破坏编辑器状态
            const svgClone = svgElement.cloneNode(true);

            // 在副本上清理所有编辑器临时状态
            cleanupSvgForSave(svgClone);

            // 获取清理后的SVG内容
            const svgContent = svgClone.outerHTML;
            
            // 构建请求URL，包含API key
            // 优先使用 currentUser（已连接的会话），如果没有则从输入框获取
            let apiKey = '';
            if (typeof currentUser !== 'undefined' && currentUser && currentUser !== 'default') {
                apiKey = currentUser;
            } else {
                const apiKeyInput = document.getElementById('apiKeyInput');
                apiKey = apiKeyInput ? apiKeyInput.value.trim() : '';
            }
            
            const url = apiKey ? `/api/save-file?api_key=${encodeURIComponent(apiKey)}` : '/api/save-file';
            
            // 发送保存请求
            const headers = {
                'Content-Type': 'application/json'
            };
            if (apiKey) {
                headers['X-API-Key'] = apiKey;
            }
            
            fetch(url, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify({
                    file_path: window.currentSvgPath,
                    content: svgContent
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // 保存成功后重置修改状态
                    window.svgModified = false;

                    const successMsg = I18N?.lang === 'zh' ? 'SVG文件保存成功' : 'SVG file saved successfully';
                    alert(successMsg);

                    // 执行回调函数（如果提供）
                    if (callback && typeof callback === 'function') {
                        callback();
                    }

                    // 刷新markdown预览
                    if (window.currentMarkdownContent && window.currentMarkdownContent.processed) {
                        // 检查是否在markdown预览模式下（previewModal可见且包含markdownPreview）
                        const previewModal = document.getElementById('previewModal');
                        const markdownPreview = document.getElementById('markdownPreview');
                        const markdownSource = document.getElementById('markdownSource');

                        // 检查用户当前是否在查看预览模式（而不是源码模式）
                        const isPreviewMode = markdownPreview && markdownPreview.style.display !== 'none';

                        if (previewModal && previewModal.style.display !== 'none' && isPreviewMode) {
                            updateMarkdownPreview(window.currentMarkdownContent.processed).catch(error => {
                                console.error('刷新markdown预览失败:', error);
                            });
                        }
                    }
                    
                    // 刷新SVG预览窗口（如果当前正在预览SVG文件）
                    if (window.currentPreviewFilePath && window.currentPreviewFilePath === window.currentSvgPath) {
                        const previewModal = document.getElementById('previewModal');
                        if (previewModal && previewModal.style.display !== 'none') {
                            // 重新预览文件以刷新显示
                            const previewFileName = window.currentPreviewFileName || window.currentSvgPath.split('/').pop();
                            previewFile(window.currentPreviewFilePath, previewFileName);
                        }
                    }
                } else {
                    const saveErrorMsg = I18N?.lang === 'zh'
                        ? `保存失败: ${data.error}`
                        : `Save failed: ${data.error}`;
                    alert(saveErrorMsg);
                }
            })
            .catch(error => {
                console.error('保存SVG文件失败:', error);
                const saveFailedMsg = I18N?.lang === 'zh' ? '保存SVG文件失败' : 'Failed to save SVG file';
                alert(saveFailedMsg);
            });
        }

        // 重置SVG
        function resetSvg() {
            // 获取I18N对象用于国际化
            const I18N = window.I18N || JSON.parse(document.getElementById('i18nData')?.textContent || '{}');

            const confirmMsg = I18N?.lang === 'zh'
                ? '确定要重置所有修改吗？'
                : 'Are you sure you want to reset all changes?';
            if (confirm(confirmMsg)) {
                const canvas = document.getElementById('svgCanvas');
                loadSvgIntoEditor(window.originalSvgContent, canvas);
                // 重置后SVG回到原始状态，清除修改标记
                window.svgModified = false;
            }
        }

        // SVG优化函数
        function optimizeSvgImage(btnEl) {
            try {
                const src = btnEl?.getAttribute('data-md-src');
                const href = btnEl?.getAttribute('data-md-href');
                
                if (!src && !href) {
                    alert(I18N.cannot_get_svg_path);
                    return;
                }
                
                // 从src或href中提取文件路径
                let filePath = href || src;
                
                // 如果是API路径，提取实际文件路径
                if (filePath.startsWith('/api/file/')) {
                    filePath = filePath.replace('/api/file/', '');
                    // 移除API key参数
                    if (filePath.includes('?api_key=')) {
                        filePath = filePath.split('?api_key=')[0];
                    }
                } else if (filePath && !filePath.startsWith('http') && !filePath.startsWith('data:')) {
                    // 处理相对路径：基于当前markdown文件的目录计算绝对路径
                    const originalFilePath = window.currentOriginalFilePath || window.currentActualFilePath || currentFilePath;
                    if (originalFilePath && originalFilePath.includes('/')) {
                        const currentDir = originalFilePath.substring(0, originalFilePath.lastIndexOf('/'));
                        
                        if (filePath.startsWith('./')) {
                            // 相对于当前目录
                            filePath = currentDir + '/' + filePath.substring(2);
                        } else if (filePath.startsWith('../')) {
                            // 相对于上级目录
                            const pathParts = currentDir.split('/');
                            const relativeParts = filePath.split('/');
                            for (const part of relativeParts) {
                                if (part === '..') {
                                    pathParts.pop();
                                } else if (part && part !== '.') {
                                    pathParts.push(part);
                                }
                            }
                            filePath = pathParts.join('/');
                        } else if (!filePath.startsWith('/')) {
                            // 相对路径，直接拼接
                            filePath = currentDir + '/' + filePath;
                        }
                    }
                }
                
                console.log('SVG优化调试信息:');
                console.log('  原始href:', href);
                console.log('  原始src:', src);
                console.log('  处理后filePath:', filePath);
                console.log('  当前originalFilePath:', window.currentOriginalFilePath);
                console.log('  当前actualFilePath:', window.currentActualFilePath);
                console.log('  当前currentFilePath:', currentFilePath);
                
                // 显示优化进行中的状态
                const originalText = btnEl.innerHTML;
                btnEl.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 优化中...';
                btnEl.disabled = true;
                
                // 调用SVG优化API
                fetch('/api/optimize-svg', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': currentUser && currentUser !== 'default' ? currentUser : ''
                    },
                    body: JSON.stringify({
                        file_path: filePath,
                        api_key: currentUser && currentUser !== 'default' ? currentUser : ''
                    })
                })
                .then(response => response.json())
                .then(data => {
                    btnEl.innerHTML = originalText;
                    btnEl.disabled = false;
                    
                    if (data.success) {
                        // 优化成功，显示结果
                        const report = data.optimization_report;
                        let message = data.message;
                        
                        if (report) {
                            message += `\n\n优化详情:`;
                            message += `\n• 检测到问题: ${report.original_issues_count}`;
                            message += `\n• 已修复问题: ${report.fixed_issues_count}`;
                            message += `\n• 剩余问题: ${report.remaining_issues_count}`;
                            
                            if (report.fixed_issues && report.fixed_issues.length > 0) {
                                message += `\n\n修复的问题:`;
                                report.fixed_issues.slice(0, 5).forEach(issue => {
                                    message += `\n• ${issue}`;
                                });
                                if (report.fixed_issues.length > 5) {
                                    message += `\n• 还有 ${report.fixed_issues.length - 5} 个问题...`;
                                }
                            }
                        }
                        
                        alert(message);
                        
                        // 刷新markdown预览以显示优化后的SVG
                        if (window.currentMarkdownContent && window.currentMarkdownContent.processed) {
                            // 触发重新渲染
                            const fake = { 
                                content: window.currentMarkdownContent.processed, 
                                type: 'markdown', 
                                size: 'N/A', 
                                file_path: window.currentOriginalFilePath || currentFilePath 
                            };
                            displayFileContent(fake, '');
                        }
                    } else {
                        alert(`SVG优化失败: ${data.error}`);
                    }
                })
                .catch(error => {
                    btnEl.innerHTML = originalText;
                    btnEl.disabled = false;
                    console.error('SVG优化错误:', error);
                    alert(`SVG优化出错: ${error.message}`);
                });
                
            } catch (e) {
                console.warn('SVG优化失败:', e);
                alert(`SVG优化失败: ${e.message}`);
            }
        }

        // AI SVG优化函数
        function optimizeSvgImageWithLLM(btnEl) {
            try {
                const src = btnEl?.getAttribute('data-md-src');
                const href = btnEl?.getAttribute('data-md-href');
                
                if (!src && !href) {
                    alert(I18N.cannot_get_svg_path);
                    return;
                }
                
                // 从src或href中提取文件路径（使用相同的逻辑）
                let filePath = href || src;
                
                // 如果是API路径，提取实际文件路径
                if (filePath.startsWith('/api/file/')) {
                    filePath = filePath.replace('/api/file/', '');
                    // 移除API key参数
                    if (filePath.includes('?api_key=')) {
                        filePath = filePath.split('?api_key=')[0];
                    }
                } else if (filePath && !filePath.startsWith('http') && !filePath.startsWith('data:')) {
                    // 处理相对路径：基于当前markdown文件的目录计算绝对路径
                    const originalFilePath = window.currentOriginalFilePath || window.currentActualFilePath || currentFilePath;
                    if (originalFilePath && originalFilePath.includes('/')) {
                        const currentDir = originalFilePath.substring(0, originalFilePath.lastIndexOf('/'));
                        
                        if (filePath.startsWith('./')) {
                            // 相对于当前目录
                            filePath = currentDir + '/' + filePath.substring(2);
                        } else if (filePath.startsWith('../')) {
                            // 相对于上级目录
                            const pathParts = currentDir.split('/');
                            const relativeParts = filePath.split('/');
                            for (const part of relativeParts) {
                                if (part === '..') {
                                    pathParts.pop();
                                } else if (part && part !== '.') {
                                    pathParts.push(part);
                                }
                            }
                            filePath = pathParts.join('/');
                        } else if (!filePath.startsWith('/')) {
                            // 相对路径，直接拼接
                            filePath = currentDir + '/' + filePath;
                        }
                    }
                }
                
                console.log('AI SVG优化调试信息:');
                console.log('  原始href:', href);
                console.log('  原始src:', src);
                console.log('  处理后filePath:', filePath);
                
                // 显示AI优化进行中的状态
                const originalText = btnEl.innerHTML;
                btnEl.innerHTML = '<i class="fas fa-robot fa-spin"></i> AI优化中...';
                btnEl.disabled = true;
                
                // 调用SVG优化API（带LLM标志）
                fetch('/api/optimize-svg', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': currentUser && currentUser !== 'default' ? currentUser : ''
                    },
                    body: JSON.stringify({
                        file_path: filePath,
                        use_llm: true,  // 关键：使用大模型
                        api_key: currentUser && currentUser !== 'default' ? currentUser : ''
                    })
                })
                .then(response => response.json())
                .then(data => {
                    btnEl.innerHTML = originalText;
                    btnEl.disabled = false;
                    
                    if (data.success) {
                        // AI优化成功，显示结果
                        const report = data.optimization_report;
                        let message = data.message;
                        
                        if (report) {
                            if (data.used_llm && report.method === 'LLM') {
                                message += `\\n\\n🤖 AI优化详情:`;
                                message += `\\n• 使用模型: ${report.llm_provider} - ${report.llm_model}`;
                                message += `\\n• 检测到问题: ${report.original_issues_count}`;
                                
                                if (report.changes_made && report.changes_made.length > 0) {
                                    message += `\\n\\n🔧 主要改进:`;
                                    report.changes_made.slice(0, 5).forEach(change => {
                                        message += `\\n• ${change}`;
                                    });
                                    if (report.changes_made.length > 5) {
                                        message += `\\n• 还有 ${report.changes_made.length - 5} 项改进...`;
                                    }
                                }
                                
                                if (report.issues_fixed && report.issues_fixed.length > 0) {
                                    message += `\\n\\n✅ 修复的问题:`;
                                    report.issues_fixed.slice(0, 3).forEach(fix => {
                                        message += `\\n• ${fix}`;
                                    });
                                    if (report.issues_fixed.length > 3) {
                                        message += `\\n• 还有 ${report.issues_fixed.length - 3} 个修复...`;
                                    }
                                }
                            } else {
                                // 回退到传统优化的报告
                                message += `\\n\\n传统优化详情:`;
                                message += `\\n• 检测到问题: ${report.original_issues_count}`;
                                message += `\\n• 已修复问题: ${report.fixed_issues_count}`;
                                message += `\\n• 剩余问题: ${report.remaining_issues_count}`;
                            }
                        }
                        
                        alert(message);
                        
                        // 刷新markdown预览以显示优化后的SVG
                        if (window.currentMarkdownContent && window.currentMarkdownContent.processed) {
                            // 触发重新渲染
                            const fake = { 
                                content: window.currentMarkdownContent.processed, 
                                type: 'markdown', 
                                size: 'N/A', 
                                file_path: window.currentOriginalFilePath || currentFilePath 
                            };
                            displayFileContent(fake, '');
                        }
                    } else {
                        alert(`AI SVG优化失败: ${data.error}`);
                    }
                })
                .catch(error => {
                    btnEl.innerHTML = originalText;
                    btnEl.disabled = false;
                    console.error('AI SVG优化错误:', error);
                    alert(`AI SVG优化出错: ${error.message}`);
                });
                
            } catch (e) {
                console.warn('AI SVG优化失败:', e);
                alert(`AI SVG优化失败: ${e.message}`);
            }
        }

        // AI优化Markdown内容函数
        function aiOptimizeMarkdown() {
            try {
                if (!window.currentMarkdownContent || !window.currentMarkdownContent.processed) {
                    alert('没有找到可优化的Markdown内容');
                    return;
                }

                const btnEl = document.getElementById('aiOptimizeMarkdownBtn');
                if (!btnEl) {
                    alert('AI优化按钮未找到');
                    return;
                }

                const originalText = btnEl.innerHTML;
                btnEl.innerHTML = '<i class="fas fa-robot fa-spin"></i> AI优化中...';
                btnEl.disabled = true;

                // 获取当前markdown内容
                const markdownContent = window.currentMarkdownContent.processed;
                const filePath = window.currentOriginalFilePath || window.currentFilePath || '';

                // 调用AI优化API（默认启用大模型模式）
                fetch('/api/optimize-markdown', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': currentUser && currentUser !== 'default' ? currentUser : ''
                    },
                    body: JSON.stringify({
                        content: markdownContent,
                        file_path: filePath,
                        use_llm: true,  // 默认启用大模型模式
                        api_key: currentUser && currentUser !== 'default' ? currentUser : ''
                    })
                })
                .then(response => response.json())
                .then(data => {
                    btnEl.innerHTML = originalText;
                    btnEl.disabled = false;

                    if (data.success) {
                        // AI优化成功，更新内容
                        const optimizedContent = data.optimized_content;
                        const report = data.optimization_report;

                        let message = data.message || 'Markdown内容已成功优化！';

                        if (report) {
                            if (data.used_llm && report.method === 'LLM') {
                                message += `\n\n🤖 AI优化详情:`;
                                message += `\n• 使用模型: ${report.llm_provider} - ${report.llm_model}`;
                                message += `\n• 优化类型: ${report.optimization_type || '内容优化'}`;

                                if (report.changes_made && report.changes_made.length > 0) {
                                    message += `\n\n🔧 主要改进:`;
                                    report.changes_made.slice(0, 5).forEach(change => {
                                        message += `\n• ${change}`;
                                    });
                                    if (report.changes_made.length > 5) {
                                        message += `\n• 还有 ${report.changes_made.length - 5} 项改进...`;
                                    }
                                }
                            } else {
                                message += `\n\n传统优化详情:`;
                                message += `\n• 优化类型: ${report.optimization_type || '基础优化'}`;
                            }
                        }

                        alert(message);

                        // 更新当前markdown内容
                        window.currentMarkdownContent.processed = optimizedContent;

                        // 重新渲染markdown预览
                        const fake = {
                            content: optimizedContent,
                            type: 'markdown',
                            size: 'N/A',
                            file_path: filePath
                        };
                        displayFileContent(fake, '');
                    } else {
                        alert(`AI优化失败: ${data.error}`);
                    }
                })
                .catch(error => {
                    btnEl.innerHTML = originalText;
                    btnEl.disabled = false;
                    console.error('AI Markdown优化错误:', error);
                    alert(`AI优化出错: ${error.message}`);
                });

            } catch (e) {
                console.warn('AI Markdown优化失败:', e);
                alert(`AI优化失败: ${e.message}`);
            }
        }

        // SVG删除函数
        function removeSvgImage(btnEl) {
            try {
                const src = btnEl?.getAttribute('data-md-src');
                const href = btnEl?.getAttribute('data-md-href');
                const occStr = btnEl?.getAttribute('data-md-occurrence') || '0';
                const occIndex = parseInt(occStr, 10) || 0;
                
                if (!window.currentMarkdownContent || !window.currentMarkdownContent.processed) return;
                
                const mdText = window.currentMarkdownContent.processed;
                const targetUrl = href || src;
                
                if (!targetUrl) {
                    alert(I18N.cannot_get_svg_path);
                    return;
                }
                
                if (!confirm(I18N.confirm_delete_svg)) {
                    return;
                }
                
                console.log('Delete SVG:', targetUrl, 'Occurrence index:', occIndex);
                
                // 精确删除第 occIndex 次出现的该图片语法
                let count = 0;
                
                // 匹配 Markdown 语法 ![...](...) 
                const mdPattern = /!\[[^\]]*\]\(([^)]+)\)/g;
                let replaced = mdText.replace(mdPattern, (full, inner) => {
                    const url = inner.split(/\s+/)[0].trim();
                    const cur = count;
                    if (url === targetUrl || url === href || url === src) {
                        count += 1;
                        if (cur === occIndex) {
                            return ''; // 删除这个匹配
                        }
                    }
                    return full;
                });

                // 如果Markdown语法没找到，尝试HTML <img>语法
                if (count === 0 || count <= occIndex) {
                    let htmlCount = 0;
                    const imgPattern = /<img([^>]*)\ssrc=["']([^"']+)["']([^>]*)>/g;
                    replaced = replaced.replace(imgPattern, (full, beforeSrc, srcAttr, afterSrc) => {
                        const cur = htmlCount;
                        if (srcAttr === targetUrl || srcAttr === href || srcAttr === src) {
                            htmlCount += 1;
                            if (cur === occIndex) {
                                return ''; // 删除这个匹配
                            }
                        }
                        return full;
                    });
                }

                // 更新内容并重新渲染
                window.currentMarkdownContent.processed = replaced;
                const fake = { 
                    content: replaced, 
                    type: 'markdown', 
                    size: 'N/A', 
                    file_path: window.currentOriginalFilePath || currentFilePath 
                };
                displayFileContent(fake, '');
                
                // 自动保存
                autoSaveMarkdown().then(saved => {
                    if (saved) {
                        console.log(I18N.svg_deleted_auto_save);
                    }
                }).catch(e => {
                    console.warn(I18N.auto_save_error + ':', e);
                });
                
            } catch (e) {
                console.warn(I18N.delete_svg_failed + ':', e);
                alert(`${I18N.delete_svg_failed}: ${e.message}`);
            }
        }

        // 恢复SVG原图函数
        function restoreSvgImage(btnEl) {
            try {
                const src = btnEl?.getAttribute('data-md-src');
                const href = btnEl?.getAttribute('data-md-href');
                
                if (!src && !href) {
                    alert(I18N.cannot_get_svg_path);
                    return;
                }
                
                // 从src或href中提取文件路径
                let filePath = href || src;
                
                // 如果是API路径，提取实际文件路径
                if (filePath.startsWith('/api/file/')) {
                    filePath = filePath.replace('/api/file/', '');
                    // 移除API key参数
                    if (filePath.includes('?api_key=')) {
                        filePath = filePath.split('?api_key=')[0];
                    }
                } else if (filePath && !filePath.startsWith('http') && !filePath.startsWith('data:')) {
                    // 处理相对路径：基于当前markdown文件的目录计算绝对路径
                    const originalFilePath = window.currentOriginalFilePath || window.currentActualFilePath || currentFilePath;
                    if (originalFilePath && originalFilePath.includes('/')) {
                        const currentDir = originalFilePath.substring(0, originalFilePath.lastIndexOf('/'));
                        
                        if (filePath.startsWith('./')) {
                            // 相对于当前目录
                            filePath = currentDir + '/' + filePath.substring(2);
                        } else if (filePath.startsWith('../')) {
                            // 相对于上级目录
                            const pathParts = currentDir.split('/');
                            const relativeParts = filePath.split('/');
                            for (const part of relativeParts) {
                                if (part === '..') {
                                    pathParts.pop();
                                } else if (part && part !== '.') {
                                    pathParts.push(part);
                                }
                            }
                            filePath = pathParts.join('/');
                        } else if (!filePath.startsWith('/')) {
                            // 相对路径，直接拼接
                            filePath = currentDir + '/' + filePath;
                        }
                    }
                }
                
                console.log('恢复SVG原图:', filePath);
                
                if (!confirm('确定要恢复SVG图到优化前的版本吗？\n\n注意：这将覆盖当前的优化版本。')) {
                    return;
                }
                
                // 显示恢复进行中的状态
                const originalText = btnEl.innerHTML;
                btnEl.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 恢复中...';
                btnEl.disabled = true;
                
                // 调用SVG恢复API
                fetch('/api/restore-svg', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': currentUser && currentUser !== 'default' ? currentUser : ''
                    },
                    body: JSON.stringify({
                        file_path: filePath,
                        api_key: currentUser && currentUser !== 'default' ? currentUser : ''
                    })
                })
                .then(response => response.json())
                .then(data => {
                    btnEl.innerHTML = originalText;
                    btnEl.disabled = false;
                    
                    if (data.success) {
                        alert(data.message || 'SVG文件已成功恢复到原始版本！');
                        
                        // 刷新markdown预览以显示恢复后的SVG
                        if (window.currentMarkdownContent && window.currentMarkdownContent.processed) {
                            // 触发重新渲染
                            const fake = { 
                                content: window.currentMarkdownContent.processed, 
                                type: 'markdown', 
                                size: 'N/A', 
                                file_path: window.currentOriginalFilePath || currentFilePath 
                            };
                            displayFileContent(fake, '');
                        }
                    } else {
                        alert(`SVG恢复失败: ${data.error}`);
                    }
                })
                .catch(error => {
                    btnEl.innerHTML = originalText;
                    btnEl.disabled = false;
                    console.error('SVG恢复错误:', error);
                    alert(`SVG恢复出错: ${error.message}`);
                });
                
            } catch (e) {
                console.warn('SVG恢复失败:', e);
                alert(`SVG恢复失败: ${e.message}`);
            }
        }

        // UTF-8 base64解码函数（支持中文）
        function decodeBase64UTF8(base64String) {
            try {
                // 使用标准的base64解码
                const binaryString = atob(base64String);
                // 将二进制字符串转换为UTF-8
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return new TextDecoder('utf-8').decode(bytes);
            } catch (e) {
                console.warn('UTF-8 base64解码失败，尝试Latin-1解码:', e);
                // 回退到标准的base64解码
                return atob(base64String);
            }
        }

        // 删除普通图片函数（PNG、JPG等）
        function removeImageFromMarkdown(btnEl) {
            try {
                const src = btnEl?.getAttribute('data-md-src');
                const href = btnEl?.getAttribute('data-md-href');
                const occStr = btnEl?.getAttribute('data-md-occurrence') || '0';
                const occIndex = parseInt(occStr, 10) || 0;
                
                if (!window.currentMarkdownContent || !window.currentMarkdownContent.processed) return;
                
                const mdText = window.currentMarkdownContent.processed;
                const targetUrl = href || src;
                
                if (!targetUrl) {
                    alert(I18N.cannot_get_image_path);
                    return;
                }
                
                if (!confirm(I18N.confirm_delete_image)) {
                    return;
                }
                
                console.log(I18N.delete_image + ':', targetUrl, 'Occurrence index:', occIndex);
                
                // 精确删除第 occIndex 次出现的该图片语法
                let count = 0;
                
                // 匹配 Markdown 语法 ![...](...) 
                const mdPattern = /!\[[^\]]*\]\(([^)]+)\)/g;
                let replaced = mdText.replace(mdPattern, (full, inner) => {
                    const url = inner.split(/\s+/)[0].trim();
                    const cur = count;
                    if (url === targetUrl || url === href || url === src) {
                        count += 1;
                        if (cur === occIndex) {
                            return ''; // 删除这个匹配
                        }
                    }
                    return full;
                });

                // 如果Markdown语法没找到，尝试HTML <img>语法
                if (count === 0 || count <= occIndex) {
                    let htmlCount = 0;
                    const imgPattern = /<img([^>]*)\ssrc=["']([^"']+)["']([^>]*)>/g;
                    replaced = replaced.replace(imgPattern, (full, beforeSrc, srcAttr, afterSrc) => {
                        const cur = htmlCount;
                        if (srcAttr === targetUrl || srcAttr === href || srcAttr === src) {
                            htmlCount += 1;
                            if (cur === occIndex) {
                                return ''; // 删除这个匹配
                            }
                        }
                        return full;
                    });
                }

                // 更新内容并重新渲染
                window.currentMarkdownContent.processed = replaced;
                const fake = { 
                    content: replaced, 
                    type: 'markdown', 
                    size: 'N/A', 
                    file_path: window.currentOriginalFilePath || currentFilePath 
                };
                displayFileContent(fake, '');
                
                // 自动保存
                autoSaveMarkdown().then(saved => {
                    if (saved) {
                        console.log(I18N.image_deleted_auto_save);
                    }
                }).catch(e => {
                    console.warn(I18N.auto_save_error + ':', e);
                });
                
            } catch (e) {
                console.warn(I18N.delete_image_failed + ':', e);
                alert(`${I18N.delete_image_failed}: ${e.message}`);
            }
        }

        async function saveCurrentMarkdown() {
            try {
                // 检查guest用户权限
                if (isGuest) {
                    alert(I18N.guest_cannot_save);
                    return;
                }
                
                // 优先从编辑器获取内容
                const editor = document.getElementById('markdownEditor');
                let contentToSave;
                if (editor && editor.parentElement.style.display !== 'none') {
                    contentToSave = editor.value;
                    // 更新当前内容
                    if (window.currentMarkdownContent) {
                        window.currentMarkdownContent.processed = contentToSave;
                    }
                } else if (window.currentMarkdownContent && window.currentMarkdownContent.processed) {
                    contentToSave = window.currentMarkdownContent.processed;
                } else {
                    alert(I18N.no_markdown_to_save);
                    return;
                }
                
                if (!window.currentOriginalFilePath && !currentFilePath) {
                    alert(I18N.cannot_determine_file_path);
                    return;
                }
                const headers = { 'Content-Type': 'application/json' };
                const body = {
                    path: window.currentOriginalFilePath || currentFilePath,
                    content: contentToSave
                };
                if (currentUser && currentUser !== 'default') {
                    headers['X-API-Key'] = currentUser;
                    body.api_key = currentUser;
                }
                const resp = await fetch('/api/save-markdown', { method: 'POST', headers, body: JSON.stringify(body) });
                const data = await resp.json();
                if (data && data.success) {
                    addMessage('Markdown已保存', 'success');
                } else {
                    addMessage(`保存失败: ${data && data.error ? data.error : '未知错误'}`, 'error');
                }
            } catch (e) {
                console.error('保存Markdown失败:', e);
                addMessage('保存失败: 网络或服务器错误', 'error');
            }
        }

        // 更新Markdown预览内容
        async function updateMarkdownPreview(markdownContent) {
            try {
                // 使用前端渲染而不是服务端渲染，以保持图片路径上下文
                const processedContent = processFileContent(markdownContent);
                
                // 配置marked.js以支持更好的渲染
                const renderer = new marked.Renderer();
                // 渲染前重置图片计数映射（用于精确替换第N次出现的链接）
                window._mdHrefOccurrenceMap = {};
                
                // 自定义图像渲染，处理相对路径（复用现有逻辑）
                renderer.image = function(href, title, text) {
                    let src = href;

                    // 使用原始文件路径进行图片路径计算（不包含用户目录前缀）
                    const originalFilePath = window.currentOriginalFilePath || currentFilePath;

                    // 只有在originalFilePath存在时才进行路径转换
                    if (originalFilePath && href && !href.startsWith('http') && !href.startsWith('data:') && !href.startsWith('/api/')) {
                        // 获取markdown文件的目录路径
                        const currentDir = originalFilePath.substring(0, originalFilePath.lastIndexOf('/'));

                        let imagePath;
                        if (href.startsWith('./')) {
                            imagePath = `${currentDir}/${href.substring(2)}`;
                        } else if (href.startsWith('../')) {
                            const pathParts = currentDir.split('/');
                            let relativeParts = href.split('/');
                            for (let part of relativeParts) {
                                if (part === '..') {
                                    pathParts.pop();
                                } else if (part !== '.' && part !== '') {
                                    pathParts.push(part);
                                }
                            }
                            imagePath = pathParts.join('/');
                        } else {
                            // 普通相对路径，直接拼接
                            imagePath = `${currentDir}/${href}`;
                        }

                        // Add API key parameter if available
                        const apiKeyParam = (currentUser && currentUser !== 'default') ? `?api_key=${currentUser}` : '';
                        // 为SVG文件添加时间戳参数，避免缓存
                        const isSvgFileForCache = imagePath && (
                            imagePath.toLowerCase().endsWith('.svg') ||
                            imagePath.includes('.svg') ||
                            imagePath.toLowerCase().includes('svg_')
                        );
                        const cacheBustParam = isSvgFileForCache ? `&t=${Date.now()}` : '';
                        src = `/api/file/${imagePath}${apiKeyParam}${cacheBustParam}`;
                        console.log('Markdown image converted:', href, 'to:', src);
                    }
                    
                    const titleAttr = title ? ` title="${title}"` : '';
                    // 计算当前href在markdown文本中的出现序号，用于后续仅替换对应一次
                    let occIndex = 0;
                    if (href) {
                        occIndex = window._mdHrefOccurrenceMap[href] || 0;
                        window._mdHrefOccurrenceMap[href] = occIndex + 1;
                    }

                    // 检查是否为SVG文件或SVG相关图片
                    const isSvgFile = src && (
                        src.toLowerCase().endsWith('.svg') || 
                        src.includes('.svg') ||
                        src.toLowerCase().includes('svg_') ||
                        (text && text.toLowerCase().includes('svg'))
                    );
                    
                    // 检查是否为其他图片格式（PNG、JPG等）
                    const isOtherImage = src && (
                        src.toLowerCase().endsWith('.png') || 
                        src.toLowerCase().endsWith('.jpg') || 
                        src.toLowerCase().endsWith('.jpeg') || 
                        src.toLowerCase().endsWith('.gif') || 
                        src.toLowerCase().endsWith('.bmp') || 
                        src.toLowerCase().endsWith('.webp')
                    );
                    
                    // 检查是否为网上下载的图片或需要显示控制按钮的图片
                    const isWebSearchImage = href && href.startsWith('web_search_result/images');
                    const shouldShowControls = isWebSearchImage || isSvgFile || isOtherImage;
                    
                    if (shouldShowControls) {
                        const originalFilePath = window.currentOriginalFilePath || currentFilePath || '';
                        const currentDir = originalFilePath && originalFilePath.includes('/') ? originalFilePath.substring(0, originalFilePath.lastIndexOf('/')) : '';
                        const containerStyle = 'display: flex; align-items: flex-start; gap: 8px; position: relative; width: 100%;';
                        const imgStyle = 'width: 85%; height: auto; border-radius: 4px; margin: 10px 0; object-fit: contain;';
                        const btnStyle = 'background: #007acc; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px; white-space: nowrap; height: fit-content; transition: background-color 0.2s;';
                        const btnDangerStyle = 'background: #d32f2f; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px; white-space: nowrap; height: fit-content; transition: background-color 0.2s;';
                        const btnOptimizeStyle = 'background: #28a745; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px; white-space: nowrap; height: fit-content; transition: background-color 0.2s;';
                        
                        let buttonsHtml = '';
                        
                        if (isWebSearchImage) {
                            // 网上下载的图片：显示上一张、下一张、删除按钮
                            buttonsHtml = `<button class=\"md-prev-btn\" style=\"${btnStyle}\" title=\"上一张\" onclick=\"prevWebSearchImage(this)\" data-md-href=\"${href}\" data-md-occurrence=\"${occIndex}\" data-md-basedir=\"${currentDir}\" onmouseover=\"this.style.backgroundColor='#005a9e'\" onmouseout=\"this.style.backgroundColor='#007acc'\"><i class=\\\"fas fa-chevron-left\\\"></i> 上一张</button>`
                                        + `<button class=\"md-next-btn\" style=\"${btnStyle}\" title=\"下一张\" onclick=\"nextWebSearchImage(this)\" data-md-href=\"${href}\" data-md-occurrence=\"${occIndex}\" data-md-basedir=\"${currentDir}\" onmouseover=\"this.style.backgroundColor='#005a9e'\" onmouseout=\"this.style.backgroundColor='#007acc'\"><i class=\\\"fas fa-chevron-right\\\"></i> 下一张</button>`
                                        + `<button class=\"md-remove-btn\" style=\"${btnDangerStyle}\" title=\"删除此图\" onclick=\"removeWebSearchImage(this)\" data-md-href=\"${href}\" data-md-occurrence=\"${occIndex}\" onmouseover=\"this.style.backgroundColor='#b71c1c'\" onmouseout=\"this.style.backgroundColor='#d32f2f'\"><i class=\\\"fas fa-trash\\\"></i> ${I18N.delete_svg || '删除'}</button>`;
                        } else if (isSvgFile) {
                            // SVG文件：显示编辑、润色、恢复、删除按钮
                            const btnEditStyle = 'background: #6f42c1; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px; white-space: nowrap; height: fit-content; transition: background-color 0.2s;';
                            const btnAiOptimizeStyle = 'background: #7c4dff; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px; white-space: nowrap; height: fit-content; transition: background-color 0.2s;';
                            buttonsHtml = `<button class=\"md-edit-svg-btn\" style=\"${btnEditStyle}\" title=\"${I18N.edit_svg_tooltip || '编辑SVG图'}\" onclick=\"editSvgImage(this)\" data-md-href=\"${href}\" data-md-src=\"${src}\" data-md-occurrence=\"${occIndex}\" onmouseover=\"this.style.backgroundColor='#5a2d91'\" onmouseout=\"this.style.backgroundColor='#6f42c1'\"><i class=\\\"fas fa-edit\\\"></i> ${I18N.edit_svg || '编辑'}</button>`
                                        + `<button class=\"md-ai-optimize-svg-btn\" style=\"${btnAiOptimizeStyle}\" title=\"${I18N.ai_optimize_svg_tooltip || 'AI智能重新设计SVG图'}\" onclick=\"optimizeSvgImageWithLLM(this)\" data-md-href=\"${href}\" data-md-src=\"${src}\" data-md-occurrence=\"${occIndex}\" onmouseover=\"this.style.backgroundColor='#5e35b1'\" onmouseout=\"this.style.backgroundColor='#7c4dff'\"><i class=\\\"fas fa-robot\\\"></i> ${I18N.ai_optimize_svg || 'AI润色'}</button>`
                                        + `<button class=\"md-restore-svg-btn\" style=\"background: #ff9800; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px; white-space: nowrap; height: fit-content; transition: background-color 0.2s;\" title=\"${I18N.restore_svg_tooltip || '恢复原图'}\" onclick=\"restoreSvgImage(this)\" data-md-href=\"${href}\" data-md-src=\"${src}\" data-md-occurrence=\"${occIndex}\" onmouseover=\"this.style.backgroundColor='#f57c00'\" onmouseout=\"this.style.backgroundColor='#ff9800'\"><i class=\\\"fas fa-undo\\\"></i> ${I18N.restore_svg || '恢复'}</button>`
                                        + `<button class=\"md-remove-svg-btn\" style=\"${btnDangerStyle}\" title=\"${I18N.delete_svg_tooltip || '删除SVG图'}\" onclick=\"removeSvgImage(this)\" data-md-href=\"${href}\" data-md-src=\"${src}\" data-md-occurrence=\"${occIndex}\" onmouseover=\"this.style.backgroundColor='#b71c1c'\" onmouseout=\"this.style.backgroundColor='#d32f2f'\"><i class=\\\"fas fa-trash\\\"></i> ${I18N.delete_svg || '删除'}</button>`;
                        } else if (isOtherImage) {
                            // PNG、JPG等其他图片：只显示删除按钮
                            buttonsHtml = `<button class=\"md-remove-image-btn\" style=\"${btnDangerStyle}\" title=\"删除此图\" onclick=\"removeImageFromMarkdown(this)\" data-md-href=\"${href}\" data-md-src=\"${src}\" data-md-occurrence=\"${occIndex}\" onmouseover=\"this.style.backgroundColor='#b71c1c'\" onmouseout=\"this.style.backgroundColor='#d32f2f'\"><i class=\\\"fas fa-trash\\\"></i> ${I18N.delete_svg || '删除'}</button>`;
                        }
                        
                        return `<div class=\"md-img-switch\" style=\"${containerStyle}\">`
                             + `<img src=\"${src}\" alt=\"${text || ''}\"${titleAttr} style=\"${imgStyle}\" data-md-href=\"${href}\" data-md-src=\"${src}\" data-md-occurrence=\"${occIndex}\">`
                             + `<div class=\"md-img-actions\" style=\"display: flex; flex-direction: column; gap: 8px; margin: 10px 0; flex: 1; padding: 8px; max-width: 15%;\">`
                             + buttonsHtml
                             + `</div>`
                             + `</div>`;
                    }

                    return `<img src="${src}" alt="${text || ''}"${titleAttr} style="width: 85%; height: auto; border-radius: 4px; margin: 10px 0; object-fit: contain;">`;
                };
                
                // 自定义代码块渲染
                renderer.code = function(code, language) {
                    const validLanguage = language && typeof language === 'string' ? language : 'text';
                    const escapedCode = escapeHtml(code);
                    
                    // 检查是否为mermaid代码块，直接在预览中渲染
                    if (validLanguage.toLowerCase() === 'mermaid') {
                        // 为mermaid图表生成唯一ID
                        const mermaidId = 'mermaid-' + Math.random().toString(36).substr(2, 9);
                        return `<div class="mermaid-container" style="background: #ffffff; border: 1px solid #e0e0e0; border-radius: 6px; padding: 16px; margin: 16px 0; text-align: center;">
                            <div class="mermaid" id="${mermaidId}">${code}</div>
                        </div>`;
                    }
                    
                    return `<pre class="language-${validLanguage}" style="background: #1e1e1e; border: 1px solid #404040; border-radius: 6px; padding: 16px; overflow-x: auto; margin: 16px 0;"><code class="language-${validLanguage}" style="color: #ffffff !important; font-weight: normal !important; font-size: 14px !important; background: transparent !important;">${escapedCode}</code></pre>`;
                };
                
                // 自定义链接渲染，确保链接正确闭合
                renderer.link = function(href, title, text) {
                    const titleAttr = title ? ` title="${title}"` : '';
                    const target = href.startsWith('http') ? ' target="_blank" rel="noopener noreferrer"' : '';
                    return `<a href="${href}"${titleAttr}${target}>${text}</a>`;
                };
                
                // 配置marked选项
                marked.setOptions({
                    renderer: renderer,
                    highlight: function(code, lang) {
                        if (typeof Prism !== 'undefined' && lang && Prism.languages[lang]) {
                            try {
                                return Prism.highlight(code, Prism.languages[lang], lang);
                            } catch (e) {
                                console.warn('Prism highlighting failed:', e);
                                return escapeHtml(code);
                            }
                        }
                        return escapeHtml(code);
                    },
                    breaks: true,
                    gfm: true
                });
                
                let htmlContent = marked.parse(processedContent);
                
                // 处理HTML中的img标签路径（处理HTML格式的图像引用）
                const originalFilePath = window.currentOriginalFilePath || currentFilePath;
                if (originalFilePath) {
                    htmlContent = htmlContent.replace(/<img([^>]*)\ssrc=["']([^"']+)["']([^>]*)>/g, function(match, beforeSrc, src, afterSrc) {
                        let newSrc = src;
                        
                        console.log('Processing image src:', src, 'in file:', originalFilePath);
                        
                        // 跳过已经处理过的URL（以/api/开头）或绝对URL
                        if (!src.startsWith('http') && !src.startsWith('data:') && !src.startsWith('/api/')) {
                            const currentDir = originalFilePath.substring(0, originalFilePath.lastIndexOf('/'));
                            
                            let imagePath;
                            if (src.startsWith('./')) {
                                imagePath = `${currentDir}/${src.substring(2)}`;
                            } else if (src.startsWith('../')) {
                                const pathParts = currentDir.split('/');
                                let relativeParts = src.split('/');
                                for (let part of relativeParts) {
                                    if (part === '..') {
                                        pathParts.pop();
                                    } else if (part !== '.' && part !== '') {
                                        pathParts.push(part);
                                    }
                                }
                                imagePath = pathParts.join('/');
                            } else {
                                // 普通相对路径，直接拼接
                                imagePath = `${currentDir}/${src}`;
                            }
                            
                            // Add API key parameter if available
                            const apiKeyParam = (currentUser && currentUser !== 'default') ? `?api_key=${currentUser}` : '';
                            newSrc = `/api/file/${imagePath}${apiKeyParam}`;
                            console.log('HTML image converted:', src, 'to:', newSrc);
                        }
                        
                        return `<img${beforeSrc} src="${newSrc}"${afterSrc}>`;
                    });
                }
                
                const previewDiv = document.getElementById('markdownPreview');
                if (previewDiv) {
                    previewDiv.innerHTML = htmlContent;
                    
                    // 重新触发渲染
                    setTimeout(() => {
                        // 触发Prism.js语法高亮
                        if (typeof Prism !== 'undefined') {
                            Prism.highlightAll();
                        }
                        
                        // 触发数学公式渲染
                        renderMath(previewDiv);
                        
                        // 触发Mermaid图表渲染
                        if (typeof mermaid !== 'undefined') {
                            try {
                                mermaid.initialize({ startOnLoad: false, theme: 'default' });
                                mermaid.run({ querySelector: '.mermaid' });
                                
                                // 检查是否为plan.md，如果是则不设置高度限制
                                const originalFilePath = window.currentOriginalFilePath || currentFilePath || '';
                                const isPlanMd = originalFilePath && (originalFilePath.endsWith('plan.md') || originalFilePath.endsWith('/plan.md'));
                                
                                if (isPlanMd) {
                                    // 为markdownPreview添加plan-md类
                                    if (previewDiv) {
                                        previewDiv.classList.add('plan-md');
                                    }
                                    
                                    // 等待mermaid渲染完成后，移除高度限制
                                    setTimeout(() => {
                                        const mermaidSvgs = previewDiv.querySelectorAll('.mermaid svg, svg');
                                        mermaidSvgs.forEach(svg => {
                                            svg.style.maxHeight = 'none';
                                            svg.style.width = 'auto';
                                            svg.style.height = 'auto';
                                        });
                                    }, 200);
                                }
                            } catch (e) {
                                console.warn('Mermaid rendering failed:', e);
                            }
                        }
                    }, 50);
                }
            } catch (e) {
                console.error('更新预览失败:', e);
            }
        }

        // 自动保存Markdown内容（静默保存，用于图片切换后）
        async function autoSaveMarkdown() {
            try {
                // 检查guest用户权限 - guest用户跳过保存
                if (isGuest) {
                    console.log(I18N.guest_skip_auto_save);
                    return false;
                }
                
                // 检查是否有可保存的内容
                if (!window.currentMarkdownContent || !window.currentMarkdownContent.processed) {
                    console.log(I18N.no_markdown_auto_save);
                    return false;
                }
                if (!window.currentOriginalFilePath && !currentFilePath) {
                    console.log(I18N.cannot_determine_path_auto_save);
                    return false;
                }

                const headers = { 'Content-Type': 'application/json' };
                const body = {
                    path: window.currentOriginalFilePath || currentFilePath,
                    content: window.currentMarkdownContent.processed
                };
                if (currentUser && currentUser !== 'default') {
                    headers['X-API-Key'] = currentUser;
                    body.api_key = currentUser;
                }
                
                const resp = await fetch('/api/save-markdown', { method: 'POST', headers, body: JSON.stringify(body) });
                const data = await resp.json();
                
                if (data && data.success) {
                    console.log(I18N.markdown_auto_saved);
                    return true;
                } else {
                    console.warn(I18N.auto_save_failed + ':', data && data.error ? data.error : I18N.unknown_error);
                    return false;
                }
            } catch (e) {
                console.error(I18N.auto_save_markdown_failed + ':', e);
                return false;
            }
        }

        // Mermaid编辑相关函数
        // 简化的函数，不再需要编辑模式切换
        function updateMermaidContent() {
            const editor = document.getElementById('mermaid-editor');
            if (editor) {
                window.currentMermaidContent = editor.value;
            }
        }

        async function saveMermaidFile() {
            try {
                if (isGuest) {
                    alert(I18N.guest_cannot_save);
                    return;
                }
                
                // 从编辑器获取内容
                const editor = document.getElementById('mermaid-editor');
                if (!editor) {
                    alert('未找到Mermaid编辑器');
                    return;
                }
                
                const contentToSave = editor.value;
                // 更新当前内容
                window.currentMermaidContent = contentToSave;
                
                if (!window.currentFilePath) {
                    alert(I18N.cannot_determine_mermaid_path);
                    return;
                }
                
                const headers = { 'Content-Type': 'application/json' };
                const body = {
                    path: window.currentFilePath,
                    content: contentToSave
                };
                if (currentUser && currentUser !== 'default') {
                    headers['X-API-Key'] = currentUser;
                    body.api_key = currentUser;
                }
                
                const resp = await fetch('/api/save-markdown', { 
                    method: 'POST', 
                    headers, 
                    body: JSON.stringify(body) 
                });
                const data = await resp.json();
                
                if (data && data.success) {
                    addMessage('Mermaid文件已保存', 'success');
                } else {
                    addMessage(`保存失败: ${data && data.error ? data.error : '未知错误'}`, 'error');
                }
            } catch (e) {
                console.error('保存Mermaid失败:', e);
                addMessage('保存失败: 网络或服务器错误', 'error');
            }
        }

        async function reloadCurrentMarkdown() {
            try {
                const path = window.currentOriginalFilePath || currentFilePath;
                if (!path) {
                    alert(I18N.cannot_determine_markdown_path);
                    return;
                }
                const apiKeyParam = (currentUser && currentUser !== 'default') ? `?api_key=${currentUser}` : '';
                const resp = await fetch(`/api/file/${encodeURIComponent(path)}${apiKeyParam}`);
                const data = await resp.json();
                if (!data || !data.success) {
                    addMessage(`重新加载失败: ${data && data.error ? data.error : '未知错误'}`, 'error');
                    return;
                }
                // 直接走现有渲染路径
                displayFileContent(data, '');
                addMessage('已从文件重新加载', 'success');
            } catch (e) {
                console.error('重新加载失败:', e);
                addMessage('重新加载失败: 网络或服务器错误', 'error');
            }
        }

        async function reparseMarkdownDiagrams() {
            try {
                // 检查guest用户权限
                if (isGuest) {
                    alert(I18N.guest_cannot_save);
                    return;
                }
                
                const path = window.currentOriginalFilePath || currentFilePath;
                if (!path) {
                    alert(I18N.cannot_determine_markdown_path || '无法确定Markdown文件路径');
                    return;
                }
                
                // 只支持markdown文件
                if (!path.toLowerCase().endsWith('.md')) {
                    alert('只支持Markdown文件的图表解析');
                    return;
                }
                
                // 显示处理中的提示
                const reparseBtn = document.getElementById('reparseMarkdownBtn');
                const originalBtnText = reparseBtn ? reparseBtn.innerHTML : '';
                if (reparseBtn) {
                    reparseBtn.disabled = true;
                    reparseBtn.innerHTML = '<i class="fas fa-spinner fa-spin" style="margin-right: 5px;"></i> 准备中...';
                }
                
                // 先保存markdown文档（用户可能已经修改了内容）
                addMessage('正在保存Markdown文档...', 'info');
                try {
                    // 优先从编辑器获取内容
                    const editor = document.getElementById('markdownEditor');
                    let contentToSave;
                    if (editor && editor.parentElement.style.display !== 'none') {
                        contentToSave = editor.value;
                        // 更新当前内容
                        if (window.currentMarkdownContent) {
                            window.currentMarkdownContent.processed = contentToSave;
                        }
                    } else if (window.currentMarkdownContent && window.currentMarkdownContent.processed) {
                        contentToSave = window.currentMarkdownContent.processed;
                    } else {
                        throw new Error('无法获取Markdown内容');
                    }
                    
                    const headers = { 'Content-Type': 'application/json' };
                    const body = {
                        path: path,
                        content: contentToSave
                    };
                    if (currentUser && currentUser !== 'default') {
                        headers['X-API-Key'] = currentUser;
                        body.api_key = currentUser;
                    }
                    
                    const saveResp = await fetch('/api/save-markdown', { method: 'POST', headers, body: JSON.stringify(body) });
                    const saveData = await saveResp.json();
                    
                    if (!saveData || !saveData.success) {
                        throw new Error(saveData && saveData.error ? saveData.error : '保存失败');
                    }
                    
                    addMessage('Markdown文档已保存', 'success');
                } catch (saveError) {
                    // 恢复按钮状态
                    if (reparseBtn) {
                        reparseBtn.disabled = false;
                        reparseBtn.innerHTML = originalBtnText;
                    }
                    addMessage('保存失败: ' + saveError.message, 'error');
                    return;
                }
                
                // 更新按钮状态为解析中
                if (reparseBtn) {
                    reparseBtn.innerHTML = '<i class="fas fa-spinner fa-spin" style="margin-right: 5px;"></i> 解析中...';
                }
                
                addMessage('正在解析Markdown中的Mermaid图表和SVG代码块...', 'info');
                
                // 调用后端API
                const headers = { 'Content-Type': 'application/json' };
                const body = { path: path };
                if (currentUser && currentUser !== 'default') {
                    headers['X-API-Key'] = currentUser;
                    body.api_key = currentUser;
                }
                
                const resp = await fetch('/api/reparse-markdown-diagrams', { 
                    method: 'POST', 
                    headers, 
                    body: JSON.stringify(body) 
                });
                const data = await resp.json();
                
                // 恢复按钮状态
                if (reparseBtn) {
                    reparseBtn.disabled = false;
                    reparseBtn.innerHTML = originalBtnText;
                }
                
                if (data && data.success) {
                    // 显示处理结果
                    let message = '图表解析完成！';
                    if (data.details) {
                        const mermaid = data.details.mermaid || {};
                        const svg = data.details.svg || {};
                        
                        let detailMsg = [];
                        if (mermaid.charts_found > 0) {
                            detailMsg.push(`Mermaid: ${mermaid.charts_processed || 0}/${mermaid.charts_found} 个图表已处理`);
                        }
                        if (svg.svg_blocks_found > 0) {
                            detailMsg.push(`SVG: ${svg.successful_conversions || 0}/${svg.svg_blocks_found} 个代码块已转换`);
                        }
                        
                        if (detailMsg.length > 0) {
                            message += '\n' + detailMsg.join('\n');
                        } else {
                            message = '未发现需要处理的Mermaid图表或SVG代码块';
                        }
                    }
                    
                    addMessage(message, 'success');
                    
                    // 重新加载文件以显示更新后的内容
                    await reloadCurrentMarkdown();
                } else {
                    const errorMsg = data && data.error ? data.error : '未知错误';
                    addMessage(`图表解析失败: ${errorMsg}`, 'error');
                }
            } catch (e) {
                console.error('解析图表失败:', e);
                addMessage('解析图表失败: 网络或服务器错误', 'error');
                
                // 恢复按钮状态
                const reparseBtn = document.getElementById('reparseMarkdownBtn');
                if (reparseBtn) {
                    reparseBtn.disabled = false;
                    reparseBtn.innerHTML = '<i class="fas fa-project-diagram" style="margin-right: 5px;"></i> 解析图表';
                }
            }
        }

        function renderAllPDFPages() {
            if (!window.currentPDF) return;
            
            const pagesContainer = document.getElementById('pdfPages');
            pagesContainer.innerHTML = `<div style="text-align: center; padding: 20px;"><i class="fas fa-spinner fa-spin"></i> ${I18N.pdf_loading}</div>`;
            
            const scale = 2.5;
            const promises = [];
            
            // 为每一页创建渲染任务
            for (let pageNum = 1; pageNum <= window.currentPDF.numPages; pageNum++) {
                promises.push(
                    window.currentPDF.getPage(pageNum).then(function(page) {
                        const viewport = page.getViewport({ scale: scale });
                        
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.height = viewport.height;
                        canvas.width = viewport.width;
                        canvas.style.cssText = 'width: 95%; height: auto; box-shadow: 0 4px 8px rgba(0,0,0,0.1); margin-bottom: 20px;';
                        
                        const renderContext = {
                            canvasContext: context,
                            viewport: viewport
                        };
                        
                        // 处理page.render()可能返回Promise或直接渲染的情况
                        const renderResult = page.render(renderContext);
                        if (renderResult && typeof renderResult.then === 'function') {
                            // 如果返回Promise，等待完成
                            return renderResult.then(() => {
                                return { canvas, pageNum };
                            });
                        } else {
                            // 如果直接渲染，立即返回结果
                            return Promise.resolve({ canvas, pageNum });
                        }
                    })
                );
            }
            
            // 等待所有页面渲染完成
            Promise.all(promises).then(function(results) {
                pagesContainer.innerHTML = '';
                
                // 按页码顺序添加所有页面
                results.forEach(function(result) {
                    const pageDiv = document.createElement('div');
                    pageDiv.style.cssText = 'margin-bottom: 20px; text-align: center; background: #f5f5f5; padding: 10px; width: 100%;';
                    
                    pageDiv.appendChild(result.canvas);
                    pagesContainer.appendChild(pageDiv);
                });
                
                // 更新页面信息
                const pagesInfo = document.getElementById('pdfPagesInfo');
                if (pagesInfo) {
                    pagesInfo.textContent = I18N.pdf_pages.replace('{pages}', window.currentPDF.numPages);
                }
            }).catch(function(error) {
                console.error('PDF页面渲染失败:', error);
                pagesContainer.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: red;">
                        <i class="fas fa-exclamation-triangle"></i> PDF页面渲染失败: ${error.message}
                    </div>
                `;
            });
        }

        // Office文档预览函数 - 云存储预览功能已移除，仅支持下载
        function previewOfficeCloud(filePath) {
            const container = document.getElementById('officeContainer');
            
            // 使用原始路径用于下载（后端会自动添加用户目录前缀）
            const downloadFilePath = window.currentOriginalFilePath || filePath;
            
            // 显示不支持在线预览的提示
            container.innerHTML = `
                <div style="background: #ffc107; color: #856404; padding: 10px; text-align: center; position: sticky; top: 0; z-index: 10;">
                    <span>${I18N.office_preview_title || 'Office Document Preview'}</span>
                    <button onclick="resetOfficePreview()" style="float: right; padding: 5px 10px; background: rgba(0,0,0,0.1); color: #856404; border: none; border-radius: 3px; cursor: pointer;">返回</button>
                </div>
                <div style="text-align: center; padding: 40px; color: #666;">
                    <div style="margin-bottom: 20px;">
                        <i class="fas fa-info-circle" style="font-size: 48px; color: #ffc107;"></i>
                    </div>
                    <h3 style="margin-bottom: 20px; color: #856404;">在线预览功能已禁用</h3>
                    <p style="margin-bottom: 20px; color: #666;">${I18N.office_offline_note || 'To support offline deployment, cloud storage preview functionality has been removed. Please download files for local viewing.'}</p>
                    <div class="preview-button-group" style="display: flex; justify-content: center; gap: 15px;">
                        <a href="/api/download-file/${downloadFilePath}${(currentUser && currentUser !== 'default') ? '?api_key=' + currentUser : ''}" download style="padding: 12px 24px; background: #007acc; color: white; text-decoration: none; border-radius: 5px; font-size: 21px; display: inline-block;">
                            <i class="fas fa-download"></i> ${I18N.download_file || 'Download File'}
                        </a>
                    </div>
                </div>
            `;
        }

        // 重置Office预览界面
        function resetOfficePreview() {
            const container = document.getElementById('officeContainer');
            if (container) {
                // 使用原始路径用于下载（后端会自动添加用户目录前缀）
                const downloadFilePath = window.currentOriginalFilePath || currentFilePath;
                
                // 重新显示选择界面
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #666;">
                        <i class="fas fa-file-alt" style="font-size: 48px; margin-bottom: 20px; color: #007acc;"></i>
                        <h3 style="margin-bottom: 20px;">${I18N.office_preview_title || 'Office Document Preview'}</h3>
                        <p style="margin-bottom: 20px;">选择以下方式预览Office文档：</p>
                        <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                            <button onclick="previewOfficeCloud('${downloadFilePath}')" style="padding: 12px 24px; background: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 21px; min-width: 200px;" disabled>
                                <i class="fas fa-ban"></i> 在线预览已禁用
                            </button>
                            <a href="/api/download-file/${downloadFilePath}${(currentUser && currentUser !== 'default') ? '?api_key=' + currentUser : ''}" download style="padding: 12px 24px; background: #6c757d; color: white; text-decoration: none; border-radius: 5px; font-size: 21px; min-width: 200px; text-align: center; display: inline-block;">
                                <i class="fas fa-download"></i> ${I18N.download_file || 'Download File'}
                            </a>
                        </div>
                    </div>
                `;
            }
        }

        // Mermaid相关函数
        let mermaidShowingChart = false;
        
        function toggleMermaidView() {
            const sourceView = document.getElementById('mermaid-source-view');
            const chartView = document.getElementById('mermaid-chart-view');
            const btnText = document.getElementById('mermaid-view-btn-text');
            
            if (!mermaidShowingChart) {
                // 更新当前内容
                updateMermaidContent();
                
                // 切换到图表视图
                sourceView.style.display = 'none';
                chartView.style.display = 'block';
                btnText.textContent = '显示源码';
                mermaidShowingChart = true;
                
                // 渲染mermaid图表
                renderMermaidChart();
            } else {
                // 切换到源码视图
                sourceView.style.display = 'block';
                chartView.style.display = 'none';
                btnText.textContent = '显示图表';
                mermaidShowingChart = false;
            }
        }
        
        
        function renderMermaidChart() {
            const container = document.getElementById('mermaid-chart-container');
            if (!container || !window.currentMermaidContent) return;
            
            // 确保mermaid库已加载
            if (typeof mermaid === 'undefined') {
                // 动态加载mermaid库
                const script = document.createElement('script');
                script.src = 'https://unpkg.com/mermaid@10/dist/mermaid.min.js';
                script.onload = function() {
                    mermaid.initialize({ 
                        startOnLoad: false,
                        theme: 'default',
                        fontFamily: 'Segoe UI, Tahoma, Geneva, Verdana, sans-serif'
                    });
                    doRenderMermaidChart();
                };
                script.onerror = function() {
                    container.innerHTML = '<div style="color: red; padding: 20px;"><i class="fas fa-exclamation-triangle"></i><br/>Mermaid库加载失败，无法渲染图表</div>';
                };
                document.head.appendChild(script);
            } else {
                doRenderMermaidChart();
            }
        }
        
        function doRenderMermaidChart() {
            const container = document.getElementById('mermaid-chart-container');
            if (!container || !window.currentMermaidContent) return;
            
            try {
                // 清空容器
                container.innerHTML = '';
                
                // 创建mermaid div
                const mermaidDiv = document.createElement('div');
                mermaidDiv.className = 'mermaid';
                mermaidDiv.textContent = window.currentMermaidContent;
                container.appendChild(mermaidDiv);
                
                // 渲染图表
                mermaid.init(undefined, mermaidDiv);
                
                // 为渲染后的SVG添加高度限制
                setTimeout(() => {
                    const svgElements = container.querySelectorAll('svg');
                    svgElements.forEach(svg => {
                        svg.style.maxHeight = '600px';
                        svg.style.width = 'auto';
                        svg.style.height = 'auto';
                    });
                }, 100); // 等待mermaid渲染完成
            } catch (error) {
                console.error('Mermaid渲染错误:', error);
                container.innerHTML = '<div style="color: red; padding: 20px;"><i class="fas fa-exclamation-triangle"></i><br/>图表渲染失败: ' + error.message + '</div>';
            }
        }
        
        function convertMermaidToImages() {
            // 检查guest用户权限
            if (isGuest) {
                alert(I18N.guest_cannot_convert);
                return;
            }
            
            if (!window.currentMermaidContent) {
                alert('没有找到Mermaid内容');
                return;
            }
            
            // 获取当前文件路径
            const filePath = window.currentFilePath || '';
            if (!filePath) {
                alert(I18N.cannot_get_file_path);
                return;
            }
            
            // 显示loading状态
            const convertBtn = event.target;
            const originalText = convertBtn.innerHTML;
            convertBtn.disabled = true;
            convertBtn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${I18N.converting}`;
            
            // 发送转换请求到后端
            const headers = {
                'Content-Type': 'application/json'
            };
            
            if (currentUser && currentUser !== 'default') {
                headers['X-API-Key'] = currentUser;
            }
            
            fetch('/api/convert-mermaid-to-images', {
                method: 'POST',
                headers: headers,
                body: JSON.stringify({
                    file_path: filePath,
                    mermaid_content: window.currentMermaidContent
                })
            })
            .then(response => response.json())
            .then(data => {
                convertBtn.disabled = false;
                convertBtn.innerHTML = originalText;
                
                if (data.success) {
                    let message = `✅ ${I18N.mermaid_conversion_success}\n\n`;
                    if (data.svg_path) {
                        message += `${I18N.svg_file}: ${data.svg_path}\n`;
                    }
                    if (data.png_path) {
                        message += `${I18N.png_file}: ${data.png_path}\n`;
                    }
                    if (data.message) {
                        message += `\n${data.message}`;
                    }
                    alert(message);
                } else {
                    alert(`❌ ${I18N.conversion_failed}: ` + (data.error || I18N.unknown_error));
                }
            })
            .catch(error => {
                convertBtn.disabled = false;
                convertBtn.innerHTML = originalText;
                console.error(I18N.conversion_request_failed + ':', error);
                alert(`❌ ${I18N.conversion_request_failed}: ` + error.message);
            });
        }

        // 存储当前文件路径，用于返回时重新构建界面
        let currentFilePath = '';

        // 用户目录现在由后端的认证系统自动处理

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // 处理文件内容中的转义字符
        function processFileContent(content) {
            return content
                .replace(/\\n/g, '\n')      // 换行符
                .replace(/\\t/g, '\t')      // 制表符
                .replace(/\\r/g, '\r')      // 回车符
                .replace(/\\\\/g, '\\');    // 反斜杠
        }

        // 关闭预览模态框的统一函数
        function closePreviewModal() {
            previewModal.style.display = 'none';
        }

        // 预览窗口拖拽功能变量
        let previewModalDragOffset = { x: 0, y: 0 };
        let previewModalDragging = false;
        let previewModalDragStart = { x: 0, y: 0 };

        // 初始化预览窗口拖拽功能
        function initPreviewModalDrag() {
            const modalContent = previewModal.querySelector('.modal-content');
            const modalHeader = previewModal.querySelector('.modal-header');
            
            if (!modalContent || !modalHeader) {
                console.error('预览窗口拖拽初始化失败: 找不到必要元素');
                return;
            }
            
            modalHeader.addEventListener('mousedown', function(e) {
                // 如果点击的是关闭按钮或其他按钮，不触发拖拽
                if (e.target.classList.contains('close') || e.target.closest('.close') ||
                    e.target.classList.contains('modal-button') || e.target.closest('.modal-button')) {
                    console.log('点击按钮，不触发拖拽');
                    return;
                }
                
                // 如果是最大化状态，不允许拖拽
                if (previewModal.classList.contains('maximized')) {
                    console.log('最大化状态，不允许拖拽');
                    return;
                }
                
                previewModalDragging = true;
                previewModalDragStart.x = e.clientX - previewModalDragOffset.x;
                previewModalDragStart.y = e.clientY - previewModalDragOffset.y;
                console.log('开始拖拽', { x: e.clientX, y: e.clientY });
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!previewModalDragging) return;
                
                e.preventDefault();
                
                previewModalDragOffset.x = e.clientX - previewModalDragStart.x;
                previewModalDragOffset.y = e.clientY - previewModalDragStart.y;
                
                if (modalContent) {
                    modalContent.style.transform = `translate(calc(-50% + ${previewModalDragOffset.x}px), calc(-50% + ${previewModalDragOffset.y}px))`;
                }
            });
            
            document.addEventListener('mouseup', function(e) {
                if (previewModalDragging) {
                    console.log('结束拖拽');
                    previewModalDragging = false;
                }
            });
        }

        // 预览窗口调整大小功能
        function initPreviewModalResize() {
            const modalContent = previewModal.querySelector('.modal-content');
            const resizerLeft = previewModal.querySelector('.modal-resizer-left');
            const resizerRight = previewModal.querySelector('.modal-resizer-right');
            const resizerTop = previewModal.querySelector('.modal-resizer-top');
            const resizerBottom = previewModal.querySelector('.modal-resizer-bottom');
            
            if (!modalContent || !resizerLeft || !resizerRight || !resizerTop || !resizerBottom) {
                console.error('预览窗口调整大小初始化失败: 找不到必要元素');
                return;
            }
            
            let isResizing = false;
            let resizeSide = null;
            let startX = 0;
            let startY = 0;
            let startWidth = 0;
            let startHeight = 0;
            let startLeft = 0;
            let startTop = 0;
            let startOffsetX = 0; // 记录开始调整大小时的位置偏移
            let startOffsetY = 0; // 记录开始调整大小时的位置偏移
            
            function startResize(e, side) {
                // 如果是最大化状态，不允许调整大小
                if (previewModal.classList.contains('maximized')) {
                    return;
                }
                
                isResizing = true;
                resizeSide = side;
                startX = e.clientX;
                startY = e.clientY;
                
                const rect = modalContent.getBoundingClientRect();
                startWidth = rect.width;
                startHeight = rect.height;
                startLeft = rect.left;
                startTop = rect.top;
                startOffsetX = previewModalDragOffset.x; // 记录初始位置偏移
                startOffsetY = previewModalDragOffset.y; // 记录初始位置偏移
                
                e.preventDefault();
                e.stopPropagation();
                
                console.log('开始调整大小', { side, startX, startY, startWidth, startHeight, startOffsetX, startOffsetY });
            }
            
            resizerLeft.addEventListener('mousedown', function(e) {
                startResize(e, 'left');
            });
            
            resizerRight.addEventListener('mousedown', function(e) {
                startResize(e, 'right');
            });
            
            resizerTop.addEventListener('mousedown', function(e) {
                startResize(e, 'top');
            });
            
            resizerBottom.addEventListener('mousedown', function(e) {
                startResize(e, 'bottom');
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isResizing) return;
                
                e.preventDefault();
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                let newWidth;
                let newHeight;
                
                if (resizeSide === 'left') {
                    // 左侧调整: 宽度减少，需要调整位置以保持右边缘不动
                    newWidth = startWidth - deltaX;
                    
                    // 限制最小和最大宽度
                    const minWidth = 400;
                    const maxWidth = window.innerWidth * 0.95;
                    if (newWidth < minWidth) {
                        newWidth = minWidth;
                    } else if (newWidth > maxWidth) {
                        newWidth = maxWidth;
                    }
                    
                    modalContent.style.width = newWidth + 'px';
                    
                    // 调整位置以保持右边缘不动
                    // 基于初始偏移值计算，而不是累加
                    const widthDiff = startWidth - newWidth;
                    const newOffsetX = startOffsetX + widthDiff / 2;
                    previewModalDragOffset.x = newOffsetX;
                    modalContent.style.transform = `translate(calc(-50% + ${newOffsetX}px), calc(-50% + ${previewModalDragOffset.y}px))`;
                    
                    // 当宽度被限制时，更新基准值以避免累积误差
                    if (newWidth === minWidth || newWidth === maxWidth) {
                        startX = e.clientX;
                        startWidth = newWidth;
                        startOffsetX = newOffsetX; // 同时更新初始偏移值
                    }
                    
                } else if (resizeSide === 'right') {
                    // 右侧调整: 宽度增加，需要调整位置以保持左边缘不动
                    newWidth = startWidth + deltaX;
                    
                    // 限制最小和最大宽度
                    const minWidth = 400;
                    const maxWidth = window.innerWidth * 0.95;
                    if (newWidth < minWidth) {
                        newWidth = minWidth;
                    } else if (newWidth > maxWidth) {
                        newWidth = maxWidth;
                    }
                    
                    modalContent.style.width = newWidth + 'px';
                    
                    // 调整位置以保持左边缘不动
                    // 基于初始偏移值计算，而不是累加
                    const widthDiff = newWidth - startWidth;
                    const newOffsetX = startOffsetX + widthDiff / 2;
                    previewModalDragOffset.x = newOffsetX;
                    modalContent.style.transform = `translate(calc(-50% + ${newOffsetX}px), calc(-50% + ${previewModalDragOffset.y}px))`;
                    
                    // 当宽度被限制时，更新基准值以避免累积误差
                    if (newWidth === minWidth || newWidth === maxWidth) {
                        startX = e.clientX;
                        startWidth = newWidth;
                        startOffsetX = newOffsetX; // 同时更新初始偏移值
                    }
                    
                } else if (resizeSide === 'top') {
                    // 上侧调整: 高度减少，需要调整位置以保持下边缘不动
                    newHeight = startHeight - deltaY;
                    
                    // 限制最小和最大高度
                    const minHeight = 300;
                    const maxHeight = window.innerHeight * 0.95;
                    if (newHeight < minHeight) {
                        newHeight = minHeight;
                    } else if (newHeight > maxHeight) {
                        newHeight = maxHeight;
                    }
                    
                    modalContent.style.height = newHeight + 'px';
                    
                    // 调整位置以保持下边缘不动
                    // 基于初始偏移值计算，而不是累加
                    const heightDiff = startHeight - newHeight;
                    const newOffsetY = startOffsetY + heightDiff / 2;
                    previewModalDragOffset.y = newOffsetY;
                    modalContent.style.transform = `translate(calc(-50% + ${previewModalDragOffset.x}px), calc(-50% + ${newOffsetY}px))`;
                    
                    // 当高度被限制时，更新基准值以避免累积误差
                    if (newHeight === minHeight || newHeight === maxHeight) {
                        startY = e.clientY;
                        startHeight = newHeight;
                        startOffsetY = newOffsetY; // 同时更新初始偏移值
                    }
                    
                } else if (resizeSide === 'bottom') {
                    // 下侧调整: 高度增加，需要调整位置以保持上边缘不动
                    newHeight = startHeight + deltaY;
                    
                    // 限制最小和最大高度
                    const minHeight = 300;
                    const maxHeight = window.innerHeight * 0.95;
                    if (newHeight < minHeight) {
                        newHeight = minHeight;
                    } else if (newHeight > maxHeight) {
                        newHeight = maxHeight;
                    }
                    
                    modalContent.style.height = newHeight + 'px';
                    
                    // 调整位置以保持上边缘不动
                    // 基于初始偏移值计算，而不是累加
                    const heightDiff = newHeight - startHeight;
                    const newOffsetY = startOffsetY + heightDiff / 2;
                    previewModalDragOffset.y = newOffsetY;
                    modalContent.style.transform = `translate(calc(-50% + ${previewModalDragOffset.x}px), calc(-50% + ${newOffsetY}px))`;
                    
                    // 当高度被限制时，更新基准值以避免累积误差
                    if (newHeight === minHeight || newHeight === maxHeight) {
                        startY = e.clientY;
                        startHeight = newHeight;
                        startOffsetY = newOffsetY; // 同时更新初始偏移值
                    }
                }
            });
            
            document.addEventListener('mouseup', function(e) {
                if (isResizing) {
                    console.log('结束调整大小');
                    isResizing = false;
                    resizeSide = null;
                }
            });
        }

        // 重置预览窗口位置
        function resetPreviewModalPosition() {
            const modalContent = previewModal.querySelector('.modal-content');
            if (modalContent) {
                previewModalDragOffset = { x: 0, y: 0 };
                modalContent.style.transform = 'translate(-50%, -50%)';
                modalContent.style.width = ''; // 重置宽度为默认值
                modalContent.style.height = ''; // 重置高度为默认值
            }
        }

        // 修改关闭预览模态框函数，添加位置重置
        const originalClosePreviewModal = closePreviewModal;
        closePreviewModal = function() {
            resetPreviewModalPosition();
            originalClosePreviewModal();
        };

        // 关闭预览模态框
        previewClose.onclick = function() {
            console.log('点击关闭按钮');
            closePreviewModal();
        }

        // 初始化拖拽功能
        initPreviewModalDrag();
        
        // 初始化调整大小功能
        initPreviewModalResize();

        // 预览窗口最大化/还原功能
        const previewMaximizeBtn = document.getElementById('previewMaximize');
        let isPreviewMaximized = false;
        let previewOriginalState = null;

        if (previewMaximizeBtn) {
            previewMaximizeBtn.onclick = function() {
                const modalContent = previewModal.querySelector('.modal-content');
                
                if (!isPreviewMaximized) {
                    // 最大化
                    console.log('最大化预览窗口');
                    
                    // 保存当前状态
                    previewOriginalState = {
                        transform: modalContent.style.transform,
                        width: modalContent.style.width,
                        dragOffset: { ...previewModalDragOffset }
                    };
                    
                    // 添加最大化类
                    previewModal.classList.add('maximized');
                    
                    // 禁用拖拽
                    previewModalDragging = false;
                    
                    // 更改图标
                    previewMaximizeBtn.innerHTML = '<i class="fas fa-compress"></i>';
                    previewMaximizeBtn.title = '还原';
                    
                    isPreviewMaximized = true;
                } else {
                    // 还原
                    console.log('还原预览窗口');
                    
                    // 移除最大化类
                    previewModal.classList.remove('maximized');
                    
                    // 恢复原来的位置和宽度
                    if (previewOriginalState) {
                        modalContent.style.transform = previewOriginalState.transform;
                        modalContent.style.width = previewOriginalState.width;
                        previewModalDragOffset = { ...previewOriginalState.dragOffset };
                    }
                    
                    // 更改图标
                    previewMaximizeBtn.innerHTML = '<i class="fas fa-expand"></i>';
                    previewMaximizeBtn.title = '最大化';
                    
                    isPreviewMaximized = false;
                }
            };
        }

        // 修改关闭函数，关闭时重置最大化状态
        const originalClosePreviewModal2 = closePreviewModal;
        closePreviewModal = function() {
            if (isPreviewMaximized && previewMaximizeBtn) {
                // 如果是最大化状态，先还原
                previewModal.classList.remove('maximized');
                previewMaximizeBtn.innerHTML = '<i class="fas fa-expand"></i>';
                previewMaximizeBtn.title = '最大化';
                isPreviewMaximized = false;
            }
            originalClosePreviewModal2();
        };

        // 重命名功能
        const renameModal = document.getElementById('renameModal');
        const renameClose = document.getElementById('renameClose');
        const currentDirName = document.getElementById('currentDirName');
        const newDirName = document.getElementById('newDirName');
        const renameConfirm = document.getElementById('renameConfirm');
        const renameCancel = document.getElementById('renameCancel');
        
        let currentRenamingDir = null;

        function showRenameDialog(dirName) {
            currentRenamingDir = dirName;
            currentDirName.textContent = dirName;
            newDirName.value = dirName; // 直接使用原名称，不做任何处理
            newDirName.focus();
            newDirName.select();
            renameModal.style.display = 'block';
        }

        function hideRenameDialog() {
            renameModal.style.display = 'none';
            currentRenamingDir = null;
            newDirName.value = '';
        }

        function performRename() {
            if (!currentRenamingDir) return;
            
            // 检查guest用户权限
            if (isGuest) {
                alert(I18N.guest_cannot_rename);
                return;
            }
            
            const newName = newDirName.value.trim();
            if (!newName) {
                alert('请输入新的目录名称');
                return;
            }
            
            // 显示加载状态
            renameConfirm.disabled = true;
            renameConfirm.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${I18N.renaming}`;
            
            const headers = {
                'Content-Type': 'application/json'
            };
            
            const body = {
                new_name: newName
            };
            
            if (currentUser && currentUser !== 'default') {
                headers['X-API-Key'] = currentUser;
                body.api_key = currentUser;
            }
            
            fetch(`/api/rename-directory/${encodeURIComponent(currentRenamingDir)}`, {
                method: 'PUT',
                headers: headers,
                body: JSON.stringify(body)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    addMessage(data.message, 'success');
                    
                    // 更新前端状态
                    if (selectedDirectory === currentRenamingDir) {
                        selectedDirectory = data.new_name;
                    }
                    
                    // 刷新目录列表
                    refreshDirectories();
                    hideRenameDialog();
                } else {
                    addMessage(`${I18N.rename_failed}: ${data.error}`, 'error');
                }
            })
            .catch(error => {
                console.error('❌ Rename error:', error);
                addMessage(`${I18N.rename_error}: ${error.message}`, 'error');
            })
            .finally(() => {
                // 恢复按钮状态
                renameConfirm.disabled = false;
                renameConfirm.innerHTML = `<i class="fas fa-check"></i> ${I18N.confirm_rename}`;
            });
        }

        // 重命名事件监听
        renameConfirm.onclick = performRename;
        renameCancel.onclick = hideRenameDialog;
        renameClose.onclick = hideRenameDialog;

        newDirName.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                performRename();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                hideRenameDialog();
            }
        });

        window.onclick = function(event) {
            // 预览窗口不会因为点击外部区域而关闭
            // if (event.target === previewModal) {
            //     previewModal.style.display = 'none';
            // }
            if (event.target === uploadModal) {
                uploadModal.style.display = 'none';
            }

            if (event.target === renameModal) {
                hideRenameDialog();
            }
        }

        // 配置页面执行轮次滑条逻辑
        const configRoundsSlider = document.getElementById('configRoundsSlider');
        const configRoundsValue = document.getElementById('configRoundsValue');
        
        if (configRoundsSlider && configRoundsValue) {
            // 初始化滑条值
            configRoundsValue.textContent = configRoundsSlider.value;
            
            // 滑条值变化事件
            configRoundsSlider.addEventListener('input', function() {
                configRoundsValue.textContent = this.value;
            });
            
            // 保存滑条值到localStorage
            configRoundsSlider.addEventListener('change', function() {
                localStorage.setItem('executionRounds', this.value);
            });
            
            // 从localStorage恢复滑条值
            const savedRounds = localStorage.getItem('executionRounds');
            if (savedRounds && savedRounds >= 1 && savedRounds <= 200) {
                configRoundsSlider.value = savedRounds;
                configRoundsValue.textContent = savedRounds;
            }
        }

        // 键盘快捷键
        document.addEventListener('keydown', function(e) {
            // Ctrl+R 或 F5 刷新目录
            if ((e.ctrlKey && e.key === 'r') || e.key === 'F5') {
                e.preventDefault();
                manualRefresh();
            }
            
            // Esc 键关闭预览模态框
            if (e.key === 'Escape' && previewModal.style.display === 'block') {
                closePreviewModal();
            }
            
            // End 键滚动到底部
            if (e.key === 'End' && e.target === chatMessages) {
                e.preventDefault();
                scrollToBottom(true);
            }
            
            // Ctrl+End 强制滚动到底部并启用自动滚动
            if (e.ctrlKey && e.key === 'End') {
                e.preventDefault();
                scrollToBottom(true);
            }
        });

        /**
         * 页面初始化函数
         * @description 页面加载完成后执行的初始化操作：
         * - 初始化用户界面状态
         * - 设置输入框焦点
         * - 更新任务模式信息
         * - 初始化分隔条拖拽功能
         * - 启动自动刷新定时器
         * - 滚动到聊天窗口底部
         */
        document.addEventListener('DOMContentLoaded', function() {
            // 加载应用信息（支持动态路径切换）
            // 注意：服务器端已经渲染了正确的应用信息，这里主要用于动态更新场景
            function updateAppInfo() {
                fetch('/api/app-info')
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // 更新页面标题
                            if (data.is_app_mode && 'app_name' in data) {
                                document.title = data.app_name;
                            } else if (!data.is_app_mode) {
                                document.title = I18N?.app_title?.replace(' GUI', '') || 'OfficeCowork';
                            }
                            
                            // 更新logo标题
                            const logoTitle = document.querySelector('.logo-title');
                            if (logoTitle) {
                                if (data.is_app_mode && 'app_name' in data) {
                                    logoTitle.textContent = data.app_name;
                                } else if (!data.is_app_mode) {
                                    logoTitle.textContent = I18N?.app_title?.replace(' GUI', '') || 'OfficeCowork';
                                }
                            }
                            
                            // 更新header中的标题
                            const headerH1 = document.querySelector('.header h1');
                            if (headerH1) {
                                const defaultLogoUrl = '{{ url_for("static", filename="logo.png") }}';
                                const logoUrl = data.logo_url || defaultLogoUrl;
                                let titleText = 'OfficeCowork';
                                if (data.is_app_mode && 'app_name' in data) {
                                    titleText = data.app_name;
                                } else if (!data.is_app_mode) {
                                    titleText = I18N?.app_title?.replace(' GUI', '') || 'OfficeCowork';
                                }
                                headerH1.innerHTML = '<img src="' + logoUrl + '" style="height: 1.8em; vertical-align: middle;" alt="Logo"> ' + titleText;
                            }
                            
                            // 更新logo图片（只在URL不同时更新）
                            if (data.logo_url) {
                                const logoImages = document.querySelectorAll('img[alt="Logo"]');
                                logoImages.forEach(img => {
                                    if (img.src !== window.location.origin + data.logo_url) {
                                        img.src = data.logo_url;
                                    }
                                });
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Failed to load app info:', error);
                    });
            }
            
            // 初始加载应用信息
            updateAppInfo();
            
            // 初始化用户状态
            updateUserStatus('disconnected', I18N.user_disconnected);
            enableUI(false);
            
            // 初始化手机界面下的聊天消息高度调整
            setTimeout(adjustChatMessagesHeightOnMobile, 200);
            
            // 检查sessionStorage中是否有注册后的API key（优先级最高）
            const registeredKeyFilled = checkRegisteredApiKey();
            
            // 如果没有注册的API key，检查localStorage中的保存会话
            if (!registeredKeyFilled) {
                const sessionRestored = checkSessionRestore();
                
                // 只有在没有自动填充和会话恢复时才设置输入框焦点
                if (!sessionRestored && !isConnected) {
                    setTimeout(() => {
                        apiKeyInput.focus();
                    }, 100);
                }
            }
            
            initResizer();
            initVerticalResizer();
            initDetailInfoToggle();
            initSidebarToggle();
            initFloatingRestoreTags();
            initLangToggle();
            initThemeToggle();
            initAppSelector();
            initFolderIconHint();
            initContactUs();
            
            // Terminal按钮点击事件
            const terminalBtn = document.getElementById('terminalBtn');
            if (terminalBtn) {
                terminalBtn.addEventListener('click', function() {
                    // 检查配置是否启用
                    if (!getGuiVirtualTerminalEnabled()) {
                        const lang = typeof I18N !== 'undefined' && I18N.lang === 'zh' ? 'zh' : 'en';
                        const message = lang === 'zh' 
                            ? '{{ i18n.get("virtual_terminal_disabled", "配置已禁用，请下载单机版并在config.txt中配置GUI_virtual_terminal=True") }}'
                            : '{{ i18n.get("virtual_terminal_disabled", "Configuration disabled. Please download the standalone version and set GUI_virtual_terminal=True in config.txt") }}';
                        alert(message);
                        return;
                    }
                    window.open('/terminal', '_blank', 'width=800,height=600');
                });
            }
            
            // 初始化GUI虚拟终端配置状态（从模板变量传递）
            window.guiVirtualTerminalEnabled = {{ 'true' if gui_virtual_terminal else 'false' }};
            
            // 动态调整容器高度（稍微延迟确保DOM完全渲染）
            setTimeout(function() {
                adjustContainerHeight();
            }, 50);
            
            // 监听窗口大小变化，重新计算容器高度
            let resizeTimer;
            window.addEventListener('resize', function() {
                // 使用防抖避免频繁计算
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(function() {
                    adjustContainerHeight();
                    adjustChatMessagesHeightOnMobile(); // 调整手机界面下的聊天消息高度
                }, 150);
            });
            
            // 设置GUI配置选项的默认值
            // 搜索网络按钮默认状态（已通过webSearchMode变量控制，默认为true，按钮初始样式已设置为激活状态）

            // 多智能体按钮默认状态（已通过multiAgentMode变量控制，默认为false）
            document.getElementById('enableLongTermMemory').checked = true;  // 启动长期记忆默认选择
            document.getElementById('enableMCP').checked = false;            // 启动MCP默认不选择
            document.getElementById('enableJieba').checked = true;           // 启用中文分词默认选择
            
            // 自动以Guest身份连接 (临时禁用用于调试)
            // connectUser();
            
            // 初始化配置选项切换功能
            initConfigToggle();

            // 初始化MCP服务器选择功能
            initMCPServerSelection();


            // 加载模型配置选项
            loadModelConfigs();
            
            // 初始化时滚动到底部（延迟100ms确保DOM渲染完成）
            setTimeout(() => {
                scrollToBottom(false);
            }, 100);
        });

        /**
         * 初始化配置选项切换功能
         */
        function initConfigToggle() {
            const toggleBtn = document.getElementById('configToggleBtn');
            const configModal = document.getElementById('configModal');
            const configModalClose = document.getElementById('configModalClose');
            const toggleIcon = document.getElementById('configToggleIcon');
            
            if (!toggleBtn || !configModal || !configModalClose) return;
            
            // 打开配置窗口
            function openConfigModal() {
                configModal.style.display = 'block';
                toggleIcon.style.transform = 'rotate(180deg)';
                toggleBtn.title = I18N.hide_config_options || '隐藏配置选项';
            }
            
            // 关闭配置窗口
            function closeConfigModal() {
                configModal.style.display = 'none';
                toggleIcon.style.transform = 'rotate(0deg)';
                toggleBtn.title = I18N.show_config_options || '显示配置选项';
            }
            
            // 点击配置按钮切换窗口
            toggleBtn.addEventListener('click', function() {
                if (configModal.style.display === 'block') {
                    closeConfigModal();
                } else {
                    openConfigModal();
                }
            });
            
            // 点击关闭按钮
            configModalClose.addEventListener('click', function() {
                closeConfigModal();
            });
            
            // 点击窗口外部关闭
            configModal.addEventListener('click', function(event) {
                if (event.target === configModal) {
                    closeConfigModal();
                }
            });
            
            // ESC键关闭
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && configModal.style.display === 'block') {
                    closeConfigModal();
                }
            });
            
            // 设置图标过渡效果
            if (toggleIcon) {
                toggleIcon.style.transition = 'transform 0.3s ease';
            }
            
            // 加载routine文件列表
            loadRoutineFiles();
        }

        /**
         * 加载routine文件列表
         */
        function loadRoutineFiles() {
            // 获取当前语言（优先从HTML lang属性获取，然后从URL参数或localStorage）
            const htmlLang = document.documentElement.getAttribute('lang');
            let currentLang = null;
            
            // 优先使用HTML lang属性（这是后端渲染时设置的真实语言）
            if (htmlLang && htmlLang.startsWith('zh')) {
                currentLang = 'zh';
            } else if (htmlLang) {
                currentLang = 'en';
            }
            
            // 如果HTML lang属性没有设置，从URL参数获取
            if (!currentLang) {
                const urlParams = new URLSearchParams(window.location.search);
                currentLang = urlParams.get('lang');
            }
            
            // 如果URL参数也没有，从localStorage获取
            if (!currentLang) {
                currentLang = localStorage.getItem('preferred_lang');
            }
            
            // 确保 currentLang 有值，默认为 'en'
            if (!currentLang || (currentLang !== 'zh' && currentLang !== 'en')) {
                currentLang = 'en';
            }
            
            // 构建API URL，包含语言参数
            const apiUrl = '/api/routine-files?lang=' + currentLang;
            
            fetch(apiUrl)
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.files && Array.isArray(data.files)) {
                        const routineSelect = document.getElementById('routineSelect');
                        // 清除现有选项（除了"无"选项）
                        routineSelect.innerHTML = '<option value="">' + (I18N.no_routine || '无') + '</option>';

                        // 添加routine文件选项
                        data.files.forEach(file => {
                            const option = document.createElement('option');
                            option.value = file.filename;
                            option.textContent = file.name;
                            // 为workspace文件添加特殊标识
                            if (file.type === 'workspace_file') {
                                const workspaceLabel = currentLang === 'zh' ? ' (工作区)' : ' (Workspace)';
                                option.textContent = file.name + workspaceLabel;
                            }
                            routineSelect.appendChild(option);
                        });
                    } else {
                        console.error('Failed to load routine files:', data.error || 'Invalid response format');
                        // 确保下拉列表至少有一个选项
                        const routineSelect = document.getElementById('routineSelect');
                        if (routineSelect) {
                            routineSelect.innerHTML = '<option value="">' + (I18N.no_routine || '无') + '</option>';
                        }
                    }
                })
                .catch(error => {
                    console.error('Error loading routine files:', error);
                    // 确保下拉列表至少有一个选项
                    const routineSelect = document.getElementById('routineSelect');
                    if (routineSelect) {
                        routineSelect.innerHTML = '<option value="">' + (I18N.no_routine || '无') + '</option>';
                    }
                });
        }

        /**
         * 初始化MCP服务器选择功能
         */
        function initMCPServerSelection() {
            const enableMCPCheckbox = document.getElementById('enableMCP');
            const mcpServerSelection = document.getElementById('mcpServerSelection');

            // 监听MCP开关变化
            enableMCPCheckbox.addEventListener('change', function() {
                if (this.checked) {
                    mcpServerSelection.style.display = 'block';
                } else {
                    mcpServerSelection.style.display = 'none';
                    // 取消选择所有MCP服务器
                    const checkboxes = mcpServerSelection.querySelectorAll('.mcp-server-checkbox');
                    checkboxes.forEach(checkbox => {
                        checkbox.checked = false;
                    });
                }
                
                // MCP服务器选择面板显示/隐藏后，重新计算容器高度
                setTimeout(function() {
                    adjustContainerHeight();
                }, 10);
            });

            // 默认隐藏MCP服务器选择区域
            mcpServerSelection.style.display = 'none';
        }

        /**
         * 获取选中的MCP服务器列表
         */
        function getSelectedMCPServers() {
            const selectedServers = [];
            const checkboxes = document.querySelectorAll('.mcp-server-checkbox:checked');

            checkboxes.forEach(checkbox => {
                selectedServers.push(checkbox.getAttribute('data-server'));
            });

            return selectedServers;
        }

        /**
         * 切换Markdown显示模式（预览模式 vs 源码模式）
         */
        function toggleMarkdownMode() {
            const previewDiv = document.getElementById('markdownPreview');
            const sourceDiv = document.getElementById('markdownSource');
            const toggleBtn = document.getElementById('markdownToggleBtn');
            const editor = document.getElementById('markdownEditor');
            
            if (!previewDiv || !sourceDiv || !toggleBtn) {
                console.error('Markdown toggle elements not found');
                return;
            }
            
            const isPreviewMode = previewDiv.style.display !== 'none';
            
            if (isPreviewMode) {
                // 切换到源码编辑模式
                previewDiv.style.display = 'none';
                sourceDiv.style.display = 'block';
                toggleBtn.innerHTML = '<i class="fas fa-eye-slash"></i> ' + (I18N.preview_mode || 'Preview Mode');
                toggleBtn.title = I18N.toggle_to_preview_title || 'Switch to preview mode';
                // 保存用户偏好
                localStorage.setItem('markdownDisplayMode', 'source');
                
                // 聚焦到编辑器
                if (editor) {
                    setTimeout(() => editor.focus(), 100);
                }
            } else {
                // 从编辑模式切换到预览模式，需要更新内容
                if (editor && window.currentMarkdownContent) {
                    const editedContent = editor.value;
                    // 更新当前内容
                    window.currentMarkdownContent.processed = editedContent;
                    
                    // 重新渲染HTML
                    updateMarkdownPreview(editedContent);
                }
                
                previewDiv.style.display = 'block';
                sourceDiv.style.display = 'none';
                toggleBtn.innerHTML = '<i class="fas fa-eye"></i> ' + (I18N.source_mode || 'Source Mode');
                toggleBtn.title = I18N.toggle_to_source_title || 'Switch to source mode';
                // 保存用户偏好
                localStorage.setItem('markdownDisplayMode', 'preview');
            }
        }

        /**
         * 转换Markdown文件为Word文档
         */
        function convertMarkdownToWord() {
            // 检查guest用户权限
            if (isGuest) {
                alert(I18N.guest_cannot_convert);
                return;
            }
            
            if (!currentFilePath) {
                alert(I18N.cannot_get_current_file_path);
                return;
            }
            
            const wordBtn = document.getElementById('convertWordBtn');
            if (wordBtn) {
                wordBtn.disabled = true;
                wordBtn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${I18N.converting}`;
            }
            
            const headers = {};
            if (currentUser && currentUser !== 'default') {
                headers['X-API-Key'] = currentUser;
            }
            
            fetch('/api/convert-markdown', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    ...headers
                },
                body: JSON.stringify({
                    file_path: currentFilePath,
                    format: 'word'
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const wordConversion = data.conversions?.word;
                    if (wordConversion && wordConversion.status === 'success') {
                        // 转换成功，自动下载文件
                        const fileName = wordConversion.file;
                        const downloadUrl = `/api/download-file/${fileName}${(currentUser && currentUser !== 'default') ? '?api_key=' + currentUser : ''}`;
                        
                        // 创建隐藏的下载链接并触发下载
                        const downloadLink = document.createElement('a');
                        downloadLink.href = downloadUrl;
                        downloadLink.download = fileName.split('/').pop(); // 获取文件名
                        downloadLink.style.display = 'none';
                        document.body.appendChild(downloadLink);
                        downloadLink.click();
                        document.body.removeChild(downloadLink);
                        
                        // 显示成功消息
                        addMessage(`✅ ${I18N.word_conversion_success}${I18N.file_label}: ${fileName.split('/').pop()}, ${I18N.size_label}: ${wordConversion.size_kb}`, 'success');
                    } else {
                        alert(`❌ ${I18N.word_conversion_failed}: ${wordConversion?.error || I18N.unknown_error}`);
                    }
                } else {
                    alert(`❌ ${I18N.conversion_failed}: ${data.error}`);
                }
            })
            .catch(error => {
                console.error(I18N.conversion_error + ':', error);
                alert(`❌ ${I18N.error_during_conversion}: ${error.message}`);
            })
            .finally(() => {
                if (wordBtn) {
                    wordBtn.disabled = false;
                    wordBtn.innerHTML = '<i class="fas fa-file-word"></i> Word';
                }
            });
        }

        /**
         * 转换Markdown文件为PDF文档
         */
        function convertMarkdownToPdf() {
            // 检查guest用户权限
            if (isGuest) {
                alert(I18N.guest_cannot_convert);
                return;
            }
            
            if (!currentFilePath) {
                alert(I18N.cannot_get_current_file_path);
                return;
            }
            
            const pdfBtn = document.getElementById('convertPdfBtn');
            if (pdfBtn) {
                pdfBtn.disabled = true;
                pdfBtn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${I18N.converting}`;
            }
            
            const headers = {};
            if (currentUser && currentUser !== 'default') {
                headers['X-API-Key'] = currentUser;
            }
            
            fetch('/api/convert-markdown', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    ...headers
                },
                body: JSON.stringify({
                    file_path: currentFilePath,
                    format: 'pdf'
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const pdfConversion = data.conversions?.pdf;
                    if (pdfConversion && pdfConversion.status === 'success') {
                        // 转换成功，自动下载文件
                        const fileName = pdfConversion.file;
                        const downloadUrl = `/api/download-file/${fileName}${(currentUser && currentUser !== 'default') ? '?api_key=' + currentUser : ''}`;
                        
                        // 创建隐藏的下载链接并触发下载
                        const downloadLink = document.createElement('a');
                        downloadLink.href = downloadUrl;
                        downloadLink.download = fileName.split('/').pop(); // 获取文件名
                        downloadLink.style.display = 'none';
                        document.body.appendChild(downloadLink);
                        downloadLink.click();
                        document.body.removeChild(downloadLink);
                        
                        // 显示成功消息
                        addMessage(`✅ ${I18N.pdf_conversion_success}${I18N.file_label}: ${fileName.split('/').pop()}, ${I18N.size_label}: ${pdfConversion.size_kb}`, 'success');
                        
                        // 如果有警告（部分转换失败），也显示
                        if (data.warnings && data.warnings.length > 0) {
                            data.warnings.forEach(warning => {
                                addMessage(`⚠️ ${warning}`, 'warning');
                            });
                        }
                    } else if (pdfConversion) {
                        // PDF转换失败，显示详细错误信息
                        const errorDetails = [];
                        errorDetails.push(`❌ ${I18N.pdf_conversion_failed || 'PDF转换失败'}`);
                        
                        if (pdfConversion.error) {
                            errorDetails.push(`\n错误详情: ${pdfConversion.error}`);
                        }
                        
                        if (pdfConversion.stderr) {
                            errorDetails.push(`\n详细错误输出:\n${pdfConversion.stderr}`);
                        }
                        
                        if (pdfConversion.stdout) {
                            errorDetails.push(`\n标准输出:\n${pdfConversion.stdout}`);
                        }
                        
                        if (pdfConversion.return_code !== undefined && pdfConversion.return_code !== null) {
                            errorDetails.push(`\n返回码: ${pdfConversion.return_code}`);
                        }
                        
                        // 显示错误消息
                        const errorMessage = errorDetails.join('\n');
                        addMessage(errorMessage, 'error');
                        
                        // 构建alert消息（包含简要错误和可能的建议）
                        let alertMessage = errorDetails.slice(0, 3).join('\n');
                        if (data.warnings && data.warnings.length > 0) {
                            alertMessage += '\n\n建议:\n' + data.warnings.join('\n');
                        }
                        alert(alertMessage);
                        
                        // 如果有警告，也显示
                        if (data.warnings && data.warnings.length > 0) {
                            data.warnings.forEach(warning => {
                                addMessage(`⚠️ ${warning}`, 'warning');
                            });
                        }
                    } else {
                        // PDF转换未执行或未返回结果
                        addMessage(`❌ ${I18N.pdf_conversion_failed || 'PDF转换失败'}: 未获取到转换结果`, 'error');
                        alert(`❌ ${I18N.pdf_conversion_failed || 'PDF转换失败'}: 未获取到转换结果`);
                    }
                } else {
                    // 整体转换失败，显示详细错误信息
                    const errorDetails = [];
                    errorDetails.push(`❌ ${I18N.conversion_failed || '转换失败'}`);
                    
                    if (data.error) {
                        errorDetails.push(`\n错误: ${data.error}`);
                    }
                    
                    if (data.original_error && data.original_error !== data.error) {
                        errorDetails.push(`\n原始错误: ${data.original_error}`);
                    }
                    
                    if (data.suggestions && data.suggestions.length > 0) {
                        errorDetails.push(`\n建议:`);
                        data.suggestions.forEach((suggestion, index) => {
                            errorDetails.push(`  ${index + 1}. ${suggestion}`);
                        });
                    }
                    
                    if (data.traceback) {
                        errorDetails.push(`\n详细堆栈信息:\n${data.traceback}`);
                    }
                    
                    // 显示错误消息
                    const errorMessage = errorDetails.join('\n');
                    addMessage(errorMessage, 'error');
                    
                    // 同时用alert显示简要错误和建议
                    const alertMessage = errorDetails.slice(0, data.suggestions ? 3 + data.suggestions.length : 3).join('\n');
                    alert(alertMessage);
                }
            })
            .catch(error => {
                console.error(I18N.conversion_error + ':', error);
                alert(`❌ ${I18N.error_during_conversion}: ${error.message}`);
            })
            .finally(() => {
                if (pdfBtn) {
                    pdfBtn.disabled = false;
                    pdfBtn.innerHTML = '<i class="fas fa-file-pdf"></i> PDF';
                }
            });
        }

        function convertMarkdownToLatex() {
            // 检查guest用户权限
            if (isGuest) {
                alert(I18N.guest_cannot_convert);
                return;
            }
            
            if (!currentFilePath) {
                alert(I18N.cannot_get_current_file_path);
                return;
            }
            
            const latexBtn = document.getElementById('convertLatexBtn');
            if (latexBtn) {
                latexBtn.disabled = true;
                latexBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 生成中...';
            }
            
            const headers = {};
            if (currentUser && currentUser !== 'default') {
                headers['X-API-Key'] = currentUser;
            }
            
            fetch('/api/convert-markdown', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    ...headers
                },
                body: JSON.stringify({
                    file_path: currentFilePath,
                    format: 'latex'
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const latexConversion = data.conversions?.latex;
                    if (latexConversion && latexConversion.status === 'success') {
                        // 转换成功，自动下载文件
                        const fileName = latexConversion.file;
                        const downloadUrl = `/api/download-file/${fileName}${(currentUser && currentUser !== 'default') ? '?api_key=' + currentUser : ''}`;
                        
                        // 创建隐藏的下载链接并触发下载
                        const downloadLink = document.createElement('a');
                        downloadLink.href = downloadUrl;
                        downloadLink.download = fileName.split('/').pop(); // 获取文件名
                        downloadLink.style.display = 'none';
                        document.body.appendChild(downloadLink);
                        downloadLink.click();
                        document.body.removeChild(downloadLink);
                        
                        // 显示成功消息
                        addMessage(`✅ ${I18N.latex_generation_success}${I18N.file_label}: ${fileName.split('/').pop()}, ${I18N.size_label}: ${latexConversion.size_kb}`, 'success');
                    } else {
                        alert(`❌ ${I18N.latex_generation_failed}: ${latexConversion?.error || I18N.unknown_error}`);
                    }
                } else {
                    alert(`❌ ${I18N.generation_failed}: ${data.error}`);
                }
            })
            .catch(error => {
                console.error(I18N.generation_error + ':', error);
                alert(`❌ ${I18N.error_during_generation}: ${error.message}`);
            })
            .finally(() => {
                if (latexBtn) {
                    latexBtn.disabled = false;
                    latexBtn.innerHTML = '<i class="fas fa-file-code"></i> LaTeX';
                }
            });
        }

        /**
         * 应用用户保存的Markdown显示模式偏好
         * 默认显示预览模式，不再自动切换到源码模式
         */
        function applyMarkdownModePreference() {
            // 默认显示预览模式，不应用之前保存的源码模式偏好
            // 用户可以通过按钮手动切换到源码模式
            const previewDiv = document.getElementById('markdownPreview');
            const sourceDiv = document.getElementById('markdownSource');
            const toggleBtn = document.getElementById('markdownToggleBtn');
            
            if (previewDiv && sourceDiv && toggleBtn) {
                // 确保默认显示预览模式
                previewDiv.style.display = 'block';
                sourceDiv.style.display = 'none';
                toggleBtn.innerHTML = '<i class="fas fa-eye"></i> ' + (I18N.source_mode || 'Source Mode');
                toggleBtn.title = I18N.toggle_to_source_title || 'Switch to source mode';
            }
        }

        // 动态调整容器高度以适应顶部区域的实际高度
        function adjustContainerHeight() {
            const authArea = document.querySelector('.user-auth-area');
            const container = document.querySelector('.container');
            
            if (authArea && container) {
                // 获取顶部区域的实际高度
                const authAreaHeight = authArea.offsetHeight;
                
                // 动态设置容器高度
                container.style.height = `calc(100vh - ${authAreaHeight}px)`;
            }
        }

        // 调整手机界面下聊天消息区域的高度，防止被工具调用窗口遮挡
        function adjustChatMessagesHeightOnMobile() {
            // 只在手机界面下执行（宽度小于768px）
            if (window.innerWidth >= 768) {
                const chatMessages = document.querySelector('.chat-messages');
                if (chatMessages) {
                    chatMessages.style.maxHeight = '';
                }
                return;
            }
            
            const chatMessages = document.querySelector('.chat-messages');
            const detailInfoContainer = document.getElementById('detailInfoContainer');
            const chatContainer = document.querySelector('.chat-container');
            const chatHeader = document.querySelector('.chat-header');
            const chatWrapper = document.querySelector('.chat-wrapper');
            const inputContainer = document.querySelector('.input-container');
            const mainContent = document.querySelector('.main-content');
            
            if (!chatMessages || !chatContainer) return;
            
            // 如果工具调用窗口是隐藏的，恢复默认高度
            if (!detailInfoContainer || detailInfoContainer.classList.contains('hidden')) {
                chatMessages.style.maxHeight = '400px';
                return;
            }
            
            // 使用更准确的方法：计算从聊天消息区域顶部到视口底部的可用空间
            const chatMessagesRect = chatMessages.getBoundingClientRect();
            const viewportHeight = window.innerHeight;
            
            // 获取工具调用窗口的位置和高度
            const detailInfoRect = detailInfoContainer.getBoundingClientRect();
            const detailInfoTop = detailInfoRect.top;
            
            // 计算可用高度：从聊天消息区域顶部到工具调用窗口顶部的距离
            const availableHeight = detailInfoTop - chatMessagesRect.top - 20; // 保留20px缓冲
            
            // 确保最小高度为250px，最大高度为400px
            const maxHeight = Math.max(250, Math.min(400, availableHeight));
            
            chatMessages.style.maxHeight = maxHeight + 'px';
        }
        
        // 调整chat-wrapper内部布局的全局辅助函数
        function adjustChatWrapperLayout() {
            const chatWrapper = document.querySelector('.chat-wrapper');
            const chatContainer = document.querySelector('.chat-container');
            const detailInfoContainer = document.getElementById('detailInfoContainer');
            const verticalResizer = document.getElementById('verticalResizer');
            
            if (!chatWrapper || !chatContainer || !detailInfoContainer) return;
            
            // 在手机界面下调整聊天消息高度
            adjustChatMessagesHeightOnMobile();
            
            // 如果细节窗口是隐藏状态，清除chat-container的固定宽度，让它自动填充
            if (detailInfoContainer.classList.contains('hidden')) {
                chatContainer.style.flex = '1';
                chatContainer.style.minWidth = '';
                return;
            }
            
            const wrapperWidth = chatWrapper.offsetWidth;
            const resizerWidth = verticalResizer ? (verticalResizer.offsetWidth || 5) : 5;
            const availableWidth = wrapperWidth - resizerWidth;
            
            const currentDetailWidth = detailInfoContainer.offsetWidth;
            const currentChatWidth = chatContainer.offsetWidth;
            
            const minChatWidth = 300;
            const minDetailWidth = 200;
            const maxDetailWidth = 800;
            
            // 检查当前总宽度是否超过可用宽度，或者是否有空白
            const totalWidth = currentChatWidth + currentDetailWidth;
            const needsAdjustment = totalWidth > availableWidth || totalWidth < availableWidth - 5; // 允许5px的误差
            
            let newDetailWidth;
            if (needsAdjustment) {
                // 如果需要调整，基于视口宽度重新计算（与CSS保持一致：min(400px, 30vw)）
                const viewportWidth = window.innerWidth;
                const cssBasedWidth = Math.min(400, viewportWidth * 0.3);
                newDetailWidth = Math.max(minDetailWidth, Math.min(maxDetailWidth, cssBasedWidth));
            } else {
                // 如果不需要调整，保持当前宽度，但确保在合理范围内
                newDetailWidth = Math.max(minDetailWidth, Math.min(maxDetailWidth, currentDetailWidth));
            }
            
            // 确保有足够空间给chat窗口
            const maxAllowedDetailWidth = availableWidth - minChatWidth;
            if (newDetailWidth > maxAllowedDetailWidth) {
                newDetailWidth = Math.max(minDetailWidth, maxAllowedDetailWidth);
            }
            
            // 计算chat窗口的宽度
            let newChatWidth = availableWidth - newDetailWidth;
            
            // 确保chat窗口不小于最小宽度
            if (newChatWidth < minChatWidth) {
                newChatWidth = minChatWidth;
                newDetailWidth = Math.max(minDetailWidth, availableWidth - newChatWidth);
            }
            
            // 设置固定宽度，确保两个容器充满整个可用空间，不留空白
            chatContainer.style.flex = '0 0 ' + newChatWidth + 'px';
            chatContainer.style.minWidth = '';
            detailInfoContainer.style.width = newDetailWidth + 'px';
            detailInfoContainer.style.flexShrink = '0';
        }

        // 分隔条拖拽功能
        function initResizer() {
            const resizer = document.getElementById('resizer');
            const sidebar = document.getElementById('sidebar');
            const container = document.querySelector('.container');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;
            let animationFrameId = null;

            resizer.addEventListener('mousedown', function(e) {
                e.preventDefault();
                isResizing = true;
                startX = e.clientX;
                startWidth = parseInt(document.defaultView.getComputedStyle(sidebar).width, 10);
                
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                
                // 添加视觉反馈
                resizer.style.background = '#007acc';
            });

            function handleMouseMove(e) {
                if (!isResizing) return;
                e.preventDefault();
                
                const dx = startX - e.clientX; // 向左拖拽为正值
                const newWidth = startWidth + dx;
                
                // 限制侧边栏宽度
                const minWidth = 250;
                const maxWidth = 600;
                const constrainedWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
                
                sidebar.style.width = constrainedWidth + 'px';
                
                // 使用requestAnimationFrame节流，避免频繁调整
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                animationFrameId = requestAnimationFrame(() => {
                    adjustChatWrapperLayout();
                    animationFrameId = null;
                });
            }

            function handleMouseUp(e) {
                if (!isResizing) return;
                e.preventDefault();
                
                isResizing = false;
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                
                // 移除视觉反馈
                resizer.style.background = '';
                
                // 取消待处理的动画帧
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                
                // 最终调整一次以确保布局正确
                adjustChatWrapperLayout();
            }
        }

        function initVerticalResizer() {
            const verticalResizer = document.getElementById('verticalResizer');
            const chatContainer = document.querySelector('.chat-container');
            const detailInfoContainer = document.getElementById('detailInfoContainer');
            let isResizing = false;
            let startX = 0;
            let startChatWidth = 0;
            let startDetailWidth = 0;

            if (!verticalResizer || !chatContainer || !detailInfoContainer) return;

            verticalResizer.addEventListener('mousedown', function(e) {
                // 如果分隔板处于隐藏状态，不响应拖动
                if (verticalResizer.classList.contains('hidden')) {
                    return;
                }
                e.preventDefault();
                isResizing = true;
                startX = e.clientX;
                const chatWrapper = document.querySelector('.chat-wrapper');
                const chatWrapperWidth = chatWrapper.offsetWidth;
                startChatWidth = chatContainer.offsetWidth;
                startDetailWidth = detailInfoContainer.offsetWidth;
                
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                
                // 添加视觉反馈
                verticalResizer.style.background = '#007acc';
            });

            function handleMouseMove(e) {
                if (!isResizing) return;
                e.preventDefault();
                
                const dx = e.clientX - startX; // 向右拖拽为正值
                const chatWrapper = document.querySelector('.chat-wrapper');
                const chatWrapperWidth = chatWrapper.offsetWidth;
                const resizerWidth = verticalResizer.offsetWidth || 5; // 分隔条宽度
                
                // 可用的总宽度
                const availableWidth = chatWrapperWidth - resizerWidth;
                
                // 计算新的宽度
                let newChatWidth = startChatWidth + dx;
                let newDetailWidth = startDetailWidth - dx;
                
                // 限制最小和最大宽度
                const minChatWidth = 300;
                const minDetailWidth = 200;
                const maxDetailWidth = 800;
                
                // 首先应用最小宽度限制
                if (newChatWidth < minChatWidth) {
                    newChatWidth = minChatWidth;
                    newDetailWidth = availableWidth - newChatWidth;
                }
                if (newDetailWidth < minDetailWidth) {
                    newDetailWidth = minDetailWidth;
                    newChatWidth = availableWidth - newDetailWidth;
                }
                
                // 应用最大宽度限制
                if (newDetailWidth > maxDetailWidth) {
                    newDetailWidth = maxDetailWidth;
                    newChatWidth = availableWidth - newDetailWidth;
                }
                
                // 确保总宽度不超过可用宽度
                const totalWidth = newChatWidth + newDetailWidth;
                if (totalWidth > availableWidth) {
                    // 按比例缩小，保持拖动方向的意图
                    const scale = availableWidth / totalWidth;
                    newChatWidth = Math.floor(newChatWidth * scale);
                    newDetailWidth = availableWidth - newChatWidth;
                }
                
                // 最终检查并应用宽度
                if (newChatWidth >= minChatWidth && newDetailWidth >= minDetailWidth) {
                    chatContainer.style.flex = '0 0 ' + newChatWidth + 'px';
                    detailInfoContainer.style.width = newDetailWidth + 'px';
                }
            }

            function handleMouseUp(e) {
                if (!isResizing) return;
                e.preventDefault();
                
                isResizing = false;
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                
                // 移除视觉反馈
                verticalResizer.style.background = '';
            }
        }

        function initDetailInfoToggle() {
            const toggleBtn = document.getElementById('detailInfoToggleBtn');
            const detailInfoContainer = document.getElementById('detailInfoContainer');
            const verticalResizer = document.getElementById('verticalResizer');
            const chatContainer = document.querySelector('.chat-container');
            const detailInfoRestoreTag = document.getElementById('detailInfoRestoreTag');
            
            if (!toggleBtn || !detailInfoContainer || !verticalResizer) return;

            // 保存调整后的宽度值，以便在显示时恢复
            let savedChatWidth = null;
            let savedDetailWidth = null;

            function hideDetailInfo() {
                // 保存当前的宽度设置（如果存在）
                if (chatContainer && chatContainer.style.flex) {
                    const flexMatch = chatContainer.style.flex.match(/(\d+)px/);
                    if (flexMatch) {
                        savedChatWidth = flexMatch[1];
                    }
                }
                if (detailInfoContainer && detailInfoContainer.style.width) {
                    const widthMatch = detailInfoContainer.style.width.match(/(\d+)px/);
                    if (widthMatch) {
                        savedDetailWidth = widthMatch[1];
                    }
                }
                
                // 重置chatContainer的flex样式，让它自动填充空间
                if (chatContainer) {
                    chatContainer.style.flex = '';
                }
                
                // 清除detailInfoContainer的内联宽度样式，让CSS的width:0生效
                if (detailInfoContainer) {
                    detailInfoContainer.style.width = '';
                }
                
                detailInfoContainer.classList.add('hidden');
                verticalResizer.classList.add('hidden');
                verticalResizer.style.cursor = 'pointer';
                
                if (detailInfoRestoreTag) {
                    detailInfoRestoreTag.classList.add('visible');
                }
                
                // 调整手机界面下的聊天消息高度
                setTimeout(adjustChatMessagesHeightOnMobile, 100);
            }

            function showDetailInfo() {
                detailInfoContainer.classList.remove('hidden');
                verticalResizer.classList.remove('hidden');
                verticalResizer.style.cursor = 'col-resize';
                
                // 获取当前页面宽度
                const chatWrapper = document.querySelector('.chat-wrapper');
                const currentWrapperWidth = chatWrapper ? chatWrapper.offsetWidth : window.innerWidth;
                
                // 计算合适的细节窗口宽度
                let targetDetailWidth = savedDetailWidth ? parseInt(savedDetailWidth) : null;
                
                // 如果没有保存的宽度，或者保存的宽度不合适，则重新计算
                const minDetailWidth = 200;
                const maxDetailWidth = 800;
                const defaultDetailWidth = Math.min(400, currentWrapperWidth * 0.3);
                
                if (!targetDetailWidth || targetDetailWidth < minDetailWidth || targetDetailWidth > maxDetailWidth) {
                    targetDetailWidth = Math.max(minDetailWidth, Math.min(maxDetailWidth, defaultDetailWidth));
                }
                
                // 确保细节窗口宽度不会让聊天区域过窄
                const minChatWidth = 300;
                const maxAllowedDetailWidth = currentWrapperWidth - minChatWidth - 10; // 10px for resizer
                targetDetailWidth = Math.min(targetDetailWidth, maxAllowedDetailWidth);
                
                // 应用宽度设置
                if (savedChatWidth && chatContainer && targetDetailWidth === parseInt(savedDetailWidth)) {
                    // 如果细节宽度没有变化，恢复原来的聊天宽度
                    chatContainer.style.flex = '0 0 ' + savedChatWidth + 'px';
                } else {
                    // 否则重新计算聊天宽度
                    const newChatWidth = currentWrapperWidth - targetDetailWidth - 10;
                    chatContainer.style.flex = '0 0 ' + newChatWidth + 'px';
                }
                
                detailInfoContainer.style.width = targetDetailWidth + 'px';
                
                if (detailInfoRestoreTag) {
                    detailInfoRestoreTag.classList.remove('visible');
                }
                
                // 调整手机界面下的聊天消息高度
                setTimeout(adjustChatMessagesHeightOnMobile, 100);
            }

            toggleBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                if (detailInfoContainer.classList.contains('hidden')) {
                    showDetailInfo();
                } else {
                    hideDetailInfo();
                }
            });

            // 当分隔板处于隐藏状态时，点击分隔板可以显示细节信息框
            verticalResizer.addEventListener('click', function(e) {
                if (verticalResizer.classList.contains('hidden')) {
                    e.preventDefault();
                    showDetailInfo();
                }
            });

            if (detailInfoRestoreTag) {
                detailInfoRestoreTag.addEventListener('click', function(e) {
                    if (detailInfoRestoreTag.dataset.justDragged === 'true') {
                        e.preventDefault();
                        return;
                    }
                    e.preventDefault();
                    e.stopPropagation();
                    showDetailInfo();
                });
            }
            
            // 监听窗口大小变化，自动调整细节窗口宽度
            let resizeTimer;
            window.addEventListener('resize', function() {
                // 使用防抖避免频繁调整
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(function() {
                    // 只在细节窗口可见时调整
                    if (!detailInfoContainer.classList.contains('hidden')) {
                        const chatWrapper = document.querySelector('.chat-wrapper');
                        const currentWrapperWidth = chatWrapper ? chatWrapper.offsetWidth : window.innerWidth;
                        const resizerWidth = verticalResizer ? (verticalResizer.offsetWidth || 5) : 5;
                        
                        const minDetailWidth = 200;
                        const maxDetailWidth = 800;
                        const minChatWidth = 300;
                        
                        // 可用的总宽度
                        const availableWidth = currentWrapperWidth - resizerWidth;
                        
                        // 基于视口宽度计算目标detail宽度（与CSS保持一致：min(400px, 30vw)）
                        // 但需要考虑可用空间和最小宽度限制
                        const viewportWidth = window.innerWidth;
                        const cssBasedWidth = Math.min(400, viewportWidth * 0.3);
                        let targetDetailWidth = Math.max(minDetailWidth, Math.min(maxDetailWidth, cssBasedWidth));
                        
                        // 计算聊天窗口的目标宽度
                        let targetChatWidth = availableWidth - targetDetailWidth;
                        
                        // 确保聊天窗口不小于最小宽度
                        if (targetChatWidth < minChatWidth) {
                            targetChatWidth = minChatWidth;
                            targetDetailWidth = Math.max(minDetailWidth, availableWidth - targetChatWidth);
                        }
                        
                        // 确保细节窗口不超过最大宽度
                        if (targetDetailWidth > maxDetailWidth) {
                            targetDetailWidth = maxDetailWidth;
                            targetChatWidth = availableWidth - targetDetailWidth;
                        }
                        
                        // 应用计算出的宽度，确保两个容器充满整个可用空间，不留空白
                        if (chatContainer) {
                            chatContainer.style.flex = '0 0 ' + targetChatWidth + 'px';
                            chatContainer.style.minWidth = '';
                        }
                        detailInfoContainer.style.width = targetDetailWidth + 'px';
                        detailInfoContainer.style.flexShrink = '0';
                        
                        // 更新保存的宽度值
                        savedDetailWidth = targetDetailWidth.toString();
                        savedChatWidth = targetChatWidth.toString();
                    }
                    
                    // 调整手机界面下的聊天消息高度
                    adjustChatMessagesHeightOnMobile();
                }, 150); // 150ms防抖延迟
            });
        }

        function initSidebarToggle() {
            const toggleBtn = document.getElementById('sidebarToggleBtn');
            const sidebar = document.getElementById('sidebar');
            const resizer = document.getElementById('resizer');
            const sidebarRestoreTag = document.getElementById('sidebarRestoreTag');
            
            if (!toggleBtn || !sidebar || !resizer) return;

            const icon = toggleBtn.querySelector('i');
            
            // 保存调整后的宽度值，以便在显示时恢复
            let savedSidebarWidth = null;

            function hideSidebar() {
                // 保存当前的宽度设置（如果存在）
                if (sidebar && sidebar.style.width) {
                    const widthMatch = sidebar.style.width.match(/(\d+)px/);
                    if (widthMatch) {
                        savedSidebarWidth = widthMatch[1];
                    }
                }
                
                sidebar.classList.add('hidden');
                // 清除内联样式，确保CSS的hidden类生效
                sidebar.style.width = '';
                
                resizer.classList.add('hidden');
                resizer.style.cursor = 'pointer';
                // 确保resizer在隐藏时宽度为0，避免空白区域
                resizer.style.width = '0';
                
                if (sidebarRestoreTag) {
                    sidebarRestoreTag.classList.add('visible');
                }
                
                // 更新图标方向
                if (icon) {
                    icon.className = 'fas fa-chevron-left';
                }
                toggleBtn.title = (I18N && I18N.lang === 'zh') ? '显示' : 'Show';
                
                // 隐藏sidebar后，main-content宽度会增加，需要调整内部布局
                setTimeout(adjustChatWrapperLayout, 50);
            }

            function showSidebar() {
                sidebar.classList.remove('hidden');
                resizer.classList.remove('hidden');
                resizer.style.cursor = 'col-resize';
                // 恢复resizer的默认宽度
                resizer.style.width = '';
                
                // 如果之前保存了宽度值，恢复它
                if (savedSidebarWidth && sidebar) {
                    sidebar.style.width = savedSidebarWidth + 'px';
                }
                
                if (sidebarRestoreTag) {
                    sidebarRestoreTag.classList.remove('visible');
                }
                
                // 更新图标方向
                if (icon) {
                    icon.className = 'fas fa-chevron-right';
                }
                toggleBtn.title = (I18N && I18N.lang === 'zh') ? '隐藏' : 'Hide';
                
                // 显示sidebar后，main-content宽度会减少，需要调整内部布局
                setTimeout(adjustChatWrapperLayout, 50);
            }

            toggleBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                if (sidebar.classList.contains('hidden')) {
                    showSidebar();
                } else {
                    hideSidebar();
                }
            });

            // 当分隔板处于隐藏状态时，点击分隔板可以显示工作目录
            resizer.addEventListener('click', function(e) {
                if (resizer.classList.contains('hidden')) {
                    e.preventDefault();
                    showSidebar();
                }
            });

            if (sidebarRestoreTag) {
                sidebarRestoreTag.addEventListener('click', function(e) {
                    if (sidebarRestoreTag.dataset.justDragged === 'true') {
                        e.preventDefault();
                        return;
                    }
                    e.preventDefault();
                    e.stopPropagation();
                    showSidebar();
                });
            }
        }

        function makeFloatingTagDraggable(tag, boundaryElement) {
            if (!tag || !boundaryElement) return;

            let isDragging = false;
            let startX = 0;
            let startY = 0;
            let offsetX = 0;
            let offsetY = 0;

            function pointerDown(e) {
                if (e.type === 'mousedown' && e.button !== 0) return;
                const pointer = e.touches ? e.touches[0] : e;
                startX = pointer.clientX;
                startY = pointer.clientY;
                isDragging = false;

                document.addEventListener('mousemove', pointerMove);
                document.addEventListener('mouseup', pointerUp);
                document.addEventListener('touchmove', pointerMove, { passive: false });
                document.addEventListener('touchend', pointerUp);
                document.addEventListener('touchcancel', pointerUp);
            }

            function pointerMove(e) {
                const pointer = e.touches ? e.touches[0] : e;
                const dx = pointer.clientX - startX;
                const dy = pointer.clientY - startY;

                if (!isDragging) {
                    if (Math.abs(dx) < 4 && Math.abs(dy) < 4) {
                        return;
                    }
                    beginDrag(pointer);
                }

                e.preventDefault();
                setPosition(pointer.clientX, pointer.clientY);
            }

            function beginDrag(pointer) {
                isDragging = true;
                const boundaryRect = boundaryElement.getBoundingClientRect();
                const tagRect = tag.getBoundingClientRect();
                offsetX = pointer.clientX - tagRect.left;
                offsetY = pointer.clientY - tagRect.top;
                tag.style.left = (tagRect.left - boundaryRect.left) + 'px';
                tag.style.top = (tagRect.top - boundaryRect.top) + 'px';
                tag.style.right = 'auto';
                tag.classList.add('dragging');
                document.body.style.userSelect = 'none';
            }

            function setPosition(clientX, clientY) {
                const boundaryRect = boundaryElement.getBoundingClientRect();
                let newLeft = clientX - boundaryRect.left - offsetX;
                let newTop = clientY - boundaryRect.top - offsetY;

                const maxLeft = boundaryRect.width - tag.offsetWidth;
                const maxTop = boundaryRect.height - tag.offsetHeight;

                newLeft = Math.min(Math.max(0, newLeft), Math.max(0, maxLeft));
                newTop = Math.min(Math.max(0, newTop), Math.max(0, maxTop));

                tag.style.left = newLeft + 'px';
                tag.style.top = newTop + 'px';
                tag.style.right = 'auto';
            }

            function pointerUp() {
                document.removeEventListener('mousemove', pointerMove);
                document.removeEventListener('mouseup', pointerUp);
                document.removeEventListener('touchmove', pointerMove);
                document.removeEventListener('touchend', pointerUp);
                document.removeEventListener('touchcancel', pointerUp);

                if (isDragging) {
                    tag.classList.remove('dragging');
                    document.body.style.userSelect = '';
                    tag.dataset.justDragged = 'true';
                    setTimeout(() => {
                        if (tag.dataset.justDragged === 'true') {
                            delete tag.dataset.justDragged;
                        }
                    }, 200);
                }

                isDragging = false;
            }

            tag.addEventListener('mousedown', pointerDown);
            tag.addEventListener('touchstart', pointerDown, { passive: false });
        }

        function initFloatingRestoreTags() {
            const detailTag = document.getElementById('detailInfoRestoreTag');
            const sidebarTag = document.getElementById('sidebarRestoreTag');
            const chatWrapper = document.querySelector('.chat-wrapper');
            const container = document.querySelector('.container');

            if (detailTag && chatWrapper) {
                makeFloatingTagDraggable(detailTag, chatWrapper);
            }
            if (sidebarTag && container) {
                makeFloatingTagDraggable(sidebarTag, container);
            }
        }

        /**
         * 初始化文件夹图标提示功能
         */
        function initFolderIconHint() {
            const folderIcon = document.getElementById('folderIconHint');
            const folderHintModal = document.getElementById('folderHintModal');
            const folderHintClose = document.getElementById('folderHintClose');
            
            if (!folderIcon || !folderHintModal) return;

            // 点击图标显示提示
            folderIcon.addEventListener('click', function(e) {
                e.stopPropagation();
                folderHintModal.style.display = 'block';
            });

            // 点击关闭按钮关闭提示
            if (folderHintClose) {
                folderHintClose.addEventListener('click', function() {
                    folderHintModal.style.display = 'none';
                });
            }

            // 点击模态框外部关闭提示
            folderHintModal.addEventListener('click', function(e) {
                if (e.target === folderHintModal) {
                    folderHintModal.style.display = 'none';
                }
            });
        }

        /**
         * 初始化联系我们功能
         */
        function initContactUs() {
            const contactUsBtn = document.getElementById('contactUsBtn');
            const contactUsModal = document.getElementById('contactUsModal');
            const contactUsClose = document.getElementById('contactUsClose');
            const contactCancel = document.getElementById('contactCancel');
            const contactSubmit = document.getElementById('contactSubmit');
            const contactMessage = document.getElementById('contactMessage');
            const contactCurrentDir = document.getElementById('contactCurrentDir');
            const contactInfo = document.getElementById('contactInfo');
            
            if (!contactUsBtn || !contactUsModal) return;

            // 获取I18N对象
            const I18N = window.I18N || JSON.parse(document.getElementById('i18nData')?.textContent || '{}');
            // 从HTML元素的lang属性获取语言，或从I18N对象获取，默认为'en'
            const htmlLang = document.documentElement.lang || '';
            const lang = htmlLang.startsWith('zh') ? 'zh' : (I18N.lang || 'en');

            // 生成格式化的session_id：日期时间戳+用户名+随机数字（用于后台记录）
            function getCurrentSessionId() {
                // 生成日期时间戳 (YYYYMMDDHHmmss格式)
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                const timestamp = `${year}${month}${day}${hours}${minutes}${seconds}`;
                
                // 获取用户名（优先使用currentUser，如果没有则使用currentUserName，都没有则使用'guest'）
                let username = 'guest';
                if (typeof currentUser !== 'undefined' && currentUser && currentUser !== 'default') {
                    username = currentUser;
                } else if (typeof currentUserName !== 'undefined' && currentUserName) {
                    username = currentUserName;
                }
                
                // 生成4位随机数字
                const randomNum = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
                
                // 组合：日期时间戳+用户名+随机数字
                return `${timestamp}_${username}_${randomNum}`;
            }

            // 打开留言框
            function openContactModal() {
                // 清空留言内容和联系方式
                if (contactMessage) {
                    contactMessage.value = '';
                }
                if (contactInfo) {
                    contactInfo.value = '';
                }
                
                // 显示当前选中的目录
                if (contactCurrentDir) {
                    const currentDir = typeof selectedDirectory !== 'undefined' && selectedDirectory ? selectedDirectory : '-';
                    contactCurrentDir.textContent = currentDir;
                }
                
                contactUsModal.style.display = 'block';
            }

            // 关闭留言框
            function closeContactModal() {
                contactUsModal.style.display = 'none';
            }

            // 提交留言
            function submitContactMessage() {
                const message = contactMessage ? contactMessage.value.trim() : '';
                if (!message) {
                    const alertMsg = I18N.contact_message_empty || (lang === 'zh' ? '请输入留言内容' : 'Please enter your message');
                    alert(alertMsg);
                    return;
                }

                const sessionId = getCurrentSessionId();
                const currentDir = typeof selectedDirectory !== 'undefined' && selectedDirectory ? selectedDirectory : '';
                const contactInfoValue = contactInfo ? contactInfo.value.trim() : '';
                
                // 发送留言到服务器
                fetch('/api/contact-us', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        session_id: sessionId,
                        message: message,
                        current_dir: currentDir,
                        contact_info: contactInfoValue
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        const successMsg = I18N.contact_submit_success || (lang === 'zh' ? '留言已提交，感谢您的反馈！' : 'Message submitted, thank you for your feedback!');
                        alert(successMsg);
                        closeContactModal();
                    } else {
                        const errorMsg = (I18N.contact_submit_error || (lang === 'zh' ? '提交失败：' : 'Submission failed: ')) + (data.error || (lang === 'zh' ? '未知错误' : 'Unknown error'));
                        alert(errorMsg);
                    }
                })
                .catch(error => {
                    const errorMsg = lang === 'zh' ? '网络错误，请稍后重试' : 'Network error, please try again later';
                    alert(errorMsg);
                    console.error('Contact us error:', error);
                });
            }

            // 绑定事件
            contactUsBtn.addEventListener('click', openContactModal);
            
            if (contactUsClose) {
                contactUsClose.addEventListener('click', closeContactModal);
            }
            
            if (contactCancel) {
                contactCancel.addEventListener('click', closeContactModal);
            }
            
            if (contactSubmit) {
                contactSubmit.addEventListener('click', submitContactMessage);
            }

            // 点击模态框外部关闭
            contactUsModal.addEventListener('click', function(e) {
                if (e.target === contactUsModal) {
                    closeContactModal();
                }
            });

            // ESC键关闭
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && contactUsModal.style.display === 'block') {
                    closeContactModal();
                }
            });
        }


        /**
         * 初始化语言切换功能
         */
        function initLangToggle() {
            const langToggleBtn = document.getElementById('langToggleBtn');
            const langToggleText = document.getElementById('langToggleText');
            if (!langToggleBtn || !langToggleText) return;

            // 从URL参数或localStorage读取当前语言
            const urlParams = new URLSearchParams(window.location.search);
            let currentLang = urlParams.get('lang');
            
            if (currentLang) {
                // 如果URL中有语言参数，保存到localStorage
                localStorage.setItem('preferred_lang', currentLang);
            } else {
                // 从localStorage读取保存的语言
                currentLang = localStorage.getItem('preferred_lang');
            }
            
            // 如果没有保存的语言，从页面数据属性获取
            if (!currentLang) {
                const htmlLang = document.documentElement.getAttribute('lang');
                if (htmlLang && htmlLang.startsWith('zh')) {
                    currentLang = 'zh';
                } else {
                    currentLang = 'en';
                }
                // 保存到localStorage
                localStorage.setItem('preferred_lang', currentLang);
            }

            // 更新按钮文本
            if (currentLang === 'zh') {
                langToggleText.textContent = 'EN';
            } else {
                langToggleText.textContent = '中文';
            }

            // 切换语言
            langToggleBtn.addEventListener('click', function() {
                // 重新获取当前语言（从URL参数或localStorage）
                const urlParams = new URLSearchParams(window.location.search);
                let currentLang = urlParams.get('lang');
                
                if (!currentLang) {
                    currentLang = localStorage.getItem('preferred_lang');
                }
                
                if (!currentLang) {
                    const htmlLang = document.documentElement.getAttribute('lang');
                    currentLang = (htmlLang && htmlLang.startsWith('zh')) ? 'zh' : 'en';
                }
                
                const newLang = currentLang === 'zh' ? 'en' : 'zh';
                
                // 保存到localStorage
                localStorage.setItem('preferred_lang', newLang);
                
                // 重新加载页面并带上语言参数
                const url = new URL(window.location.href);
                url.searchParams.set('lang', newLang);
                window.location.href = url.toString();
            });
        }

        /**
         * 初始化主题切换功能
         */
        function initThemeToggle() {
            const themeToggleBtn = document.getElementById('themeToggleBtn');
            if (!themeToggleBtn) return;

            const html = document.documentElement;
            
            // 读取当前主题（已经在head中设置过了，如果没有则从localStorage读取或默认为light）
            let currentTheme = html.getAttribute('data-theme');
            if (!currentTheme) {
                // 如果head中的脚本没有执行，这里作为后备
                currentTheme = localStorage.getItem('theme') || 'light';
                html.setAttribute('data-theme', currentTheme);
            }
            
            // 根据当前主题同步按钮图标
            // 如果当前是light主题，显示月亮图标（表示点击后会切换到dark）
            // 如果当前是dark主题，显示太阳图标（表示点击后会切换到light）
            const icon = themeToggleBtn.querySelector('i');
            if (currentTheme === 'light') {
                icon.className = 'fas fa-moon';
            } else {
                icon.className = 'fas fa-sun';
            }

            // 切换主题
            themeToggleBtn.addEventListener('click', function() {
                const currentTheme = html.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                
                // 更新主题
                html.setAttribute('data-theme', newTheme);
                
                // 更新图标（显示点击后会切换到的主题图标）
                const icon = themeToggleBtn.querySelector('i');
                if (newTheme === 'light') {
                    icon.className = 'fas fa-moon';
                } else {
                    icon.className = 'fas fa-sun';
                }
                
                // 保存到localStorage
                localStorage.setItem('theme', newTheme);
            });
        }

        /**
         * 从路径中提取当前平台名称
         * @returns {string|null} 平台名称，如果是根路径则返回null
         */
        function getCurrentAppFromPath() {
            const path = window.location.pathname;
            // 移除首尾斜杠
            const cleanPath = path.replace(/^\/|\/$/g, '');
            // 如果路径为空，返回null（默认平台）
            if (!cleanPath) return null;
            // 排除保留路径
            const reservedPaths = ['terminal', 'register', 'agent-status-visualizer', 'api', 'static'];
            if (reservedPaths.includes(cleanPath)) return null;
            // 返回路径作为app_name
            return cleanPath;
        }

        /**
         * 初始化平台选择器
         */
        function initAppSelector() {
            const appSelect = document.getElementById('appSelect');
            if (!appSelect) return;

            // 加载可用平台列表
            fetch('/api/app-list')
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.apps) {
                        // 清空现有选项（保留加载中选项）
                        appSelect.innerHTML = '';
                        
                        // 添加默认平台选项
                        const defaultOption = document.createElement('option');
                        defaultOption.value = '';
                        const I18N = window.I18N || JSON.parse(document.getElementById('i18nData')?.textContent || '{}');
                        defaultOption.textContent = (typeof I18N !== 'undefined' && I18N.default_platform) ? I18N.default_platform : 'Default Platform';
                        appSelect.appendChild(defaultOption);
                        
                        // 添加可用平台选项
                        data.apps.forEach(app => {
                            const option = document.createElement('option');
                            option.value = app.name;
                            option.textContent = app.display_name || app.name;
                            appSelect.appendChild(option);
                        });
                        
                        // 根据当前路径设置选中项
                        const currentApp = getCurrentAppFromPath();
                        if (currentApp) {
                            // 检查当前应用是否在列表中
                            const appExists = Array.from(appSelect.options).some(option => option.value === currentApp);
                            if (appExists) {
                                appSelect.value = currentApp;
                            } else {
                                // 如果当前应用不在列表中，设置为默认平台
                                // 注意：隐藏应用不会显示平台选择器，所以这里不会执行
                                appSelect.value = '';
                            }
                        } else {
                            appSelect.value = '';
                        }
                    } else {
                        console.error('Failed to load app list:', data.error || 'Unknown error');
                    }
                })
                .catch(error => {
                    console.error('Error loading app list:', error);
                });

            // 监听选择器变化
            appSelect.addEventListener('change', function() {
                const selectedApp = this.value;
                let targetPath = '/';
                
                if (selectedApp) {
                    targetPath = `/${selectedApp}`;
                }
                
                // 保持查询参数（如lang参数）
                const url = new URL(window.location.href);
                url.pathname = targetPath;
                window.location.href = url.toString();
            });
        }

        // 手动刷新目录 - 保持展开状态和滚动位置
        function manualRefresh() {
            const refreshBtn = document.querySelector('.sidebar-header .action-btn');
            const icon = refreshBtn.querySelector('i');

            // 添加旋转动画
            icon.classList.add('fa-spin');
            refreshBtn.disabled = true;

            // 保存当前展开状态
            // 🔧 修复：不仅从expandedDirectories Set中读取，还要从DOM中读取当前真实的展开状态
            // 这样可以确保即使expandedDirectories没有及时更新，也能正确保存展开状态
            const currentExpanded = new Set(expandedDirectories);
            
            // 从DOM中读取所有当前展开的目录（通过检查tree元素是否有'show'类）
            // 🔧 修复：确保在读取DOM状态时，directoryList存在且包含有效的目录项
            if (directoryList && directoryList.children.length > 0) {
                const allDirectoryItems = directoryList.querySelectorAll('[data-dir]');
                allDirectoryItems.forEach(item => {
                    const dirName = item.getAttribute('data-dir');
                    if (dirName) {
                        const treeElement = document.getElementById(`tree-${dirName}`);
                        // 🔧 修复：同时检查'show'类和'expanded'类，确保状态读取完整
                        if (treeElement && (treeElement.classList.contains('show') || item.classList.contains('expanded'))) {
                            // 如果DOM中显示为展开，添加到展开集合中
                            currentExpanded.add(dirName);
                            // 同时更新expandedDirectories Set，确保状态同步
                            expandedDirectories.add(dirName);
                        }
                    }
                });
            }

            // 保存当前滚动位置
            const currentScrollTop = directoryList ? directoryList.scrollTop : 0;

            // 保存所有展开目录的文件树滚动位置
            const fileTreeScrollPositions = {};
            currentExpanded.forEach(dirName => {
                const treeElement = document.getElementById(`tree-${dirName}`);
                if (treeElement) {
                    fileTreeScrollPositions[dirName] = treeElement.scrollTop;
                }
            });

            const headers = {
                'Content-Type': 'application/json'
            };

            const body = {};
            if (currentUser && currentUser !== 'default') {
                headers['X-API-Key'] = currentUser;
                body.api_key = currentUser;
            }

            fetch('/api/refresh-dirs', {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(body)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // 恢复展开状态 - 只保留仍然存在的目录
                    const validExpanded = new Set();
                    const directoryNames = new Set(data.directories.map(dir => dir.name));
                    currentExpanded.forEach(dirName => {
                        if (directoryNames.has(dirName)) {
                            validExpanded.add(dirName);
                        }
                    });
                    // 🔧 修复：确保在调用renderDirectories之前，expandedDirectories已经更新
                    expandedDirectories = validExpanded;
                    renderDirectories(data.directories);

                    // 恢复滚动位置和展开状态
                    // 🔧 修复：使用requestAnimationFrame确保DOM完全渲染后再恢复状态
                    requestAnimationFrame(() => {
                        setTimeout(() => {
                            if (directoryList) {
                                directoryList.scrollTop = currentScrollTop;
                            }

                            // 恢复每个展开目录的文件树滚动位置，并确保展开状态正确应用
                            validExpanded.forEach(dirName => {
                                const treeElement = document.getElementById(`tree-${dirName}`);
                                if (treeElement) {
                                    // 确保展开状态正确应用
                                    if (!treeElement.classList.contains('show')) {
                                        treeElement.classList.add('show');
                                    }
                                    const directoryItem = document.querySelector(`[data-dir="${dirName}"]`);
                                    if (directoryItem) {
                                        if (!directoryItem.classList.contains('expanded')) {
                                            directoryItem.classList.add('expanded');
                                        }
                                        // 恢复滚动位置
                                        if (fileTreeScrollPositions[dirName] !== undefined) {
                                            treeElement.scrollTop = fileTreeScrollPositions[dirName];
                                        }
                                        // 更新按钮图标
                                        const button = directoryItem.querySelector('.directory-actions button:first-child');
                                        const icon = button ? button.querySelector('i') : null;
                                        if (icon) {
                                            icon.className = 'fas fa-chevron-up';
                                        }
                                    }
                                }
                            });
                        }, 0);
                    });

                    // 显示成功消息（更简洁）
                    console.log('Directory refreshed');
                } else {
                    addMessage(`${I18N.refresh_failed}: ${data.error}`, 'error');
                }
            })
            .catch(error => {
                addMessage(`${I18N.refresh_failed}: ${error.message}`, 'error');
            })
            .finally(() => {
                // 移除旋转动画
                icon.classList.remove('fa-spin');
                refreshBtn.disabled = false;
            });
        }

        // 文件监测功能
        function startFileMonitoring() {
            // 清除现有的定时器
            if (fileMonitoringTimer) {
                clearInterval(fileMonitoringTimer);
                fileMonitoringTimer = null;
            }
            
            // 如果没有选择目录，不启动监测
            if (!selectedDirectory) {
                console.log('No directory selected, file monitoring stopped');
                return;
            }
            
            // 立即检查一次文件数量（checkFileCount会在第一次检查时也检查out文件）
            checkFileCount();
            
            // 设置定时器，每10秒检查一次
            fileMonitoringTimer = setInterval(() => {
                if (selectedDirectory) {
                    checkFileCount();
                } else {
                    stopFileMonitoring();
                }
            }, fileMonitoringInterval);
        }
        
        function stopFileMonitoring() {
            if (fileMonitoringTimer) {
                clearInterval(fileMonitoringTimer);
                fileMonitoringTimer = null;
                console.log('File monitoring stopped');
            }
            lastFileCount = null;
        }
        
        function checkFileCount() {
            if (!selectedDirectory) {
                return;
            }
            
            const headers = {
                'Content-Type': 'application/json'
            };
            
            let url = `/api/file-count/${encodeURIComponent(selectedDirectory)}`;
            if (currentUser && currentUser !== 'default') {
                headers['X-API-Key'] = currentUser;
                url += `?api_key=${encodeURIComponent(currentUser)}`;
            }
            
            fetch(url, {
                method: 'GET',
                headers: headers
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const currentFileCount = data.file_count;
                    
                    // 如果这是第一次检查，只记录文件数量，不触发刷新
                    if (lastFileCount === null) {
                        lastFileCount = currentFileCount;
                        // 第一次检查时也检查out文件
                        checkOutFiles();
                        return;
                    }
                    
                    // 如果文件数量发生变化，触发刷新
                    if (currentFileCount !== lastFileCount) {
                        console.log(`File count changed in ${selectedDirectory}: ${lastFileCount} -> ${currentFileCount}`);
                        lastFileCount = currentFileCount;
                        
                        // 触发目录刷新
                        manualRefresh();
                        // 同时检查out文件（文件变化可能包括新的.out文件）
                        checkOutFiles();
                    } else {
                        // 即使文件数量没变化，也定期检查out文件（可能新创建了.out文件）
                        // 注意：这里只在文件数量没变化时检查，避免频繁调用
                        checkOutFiles();
                    }
                } else {
                    console.warn(`Failed to get file count for ${selectedDirectory}:`, data.error);
                }
            })
            .catch(error => {
                console.warn(`Error checking file count for ${selectedDirectory}:`, error.message);
            });
        }
        
        /**
         * 检查当前选定目录的.out文件并更新agent选项框
         */
        function checkOutFiles() {
            if (!selectedDirectory) {
                return;
            }
            
            const headers = {
                'Content-Type': 'application/json'
            };
            
            let url = `/api/out-files/${encodeURIComponent(selectedDirectory)}`;
            if (currentUser && currentUser !== 'default') {
                headers['X-API-Key'] = currentUser;
                url += `?api_key=${encodeURIComponent(currentUser)}`;
            }
            
            fetch(url, {
                method: 'GET',
                headers: headers
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // 更新agent选项框
                    updateAgentSelectDropdown(data.out_files || []);
                } else {
                    console.warn(`Failed to get out files for ${selectedDirectory}:`, data.error);
                }
            })
            .catch(error => {
                console.warn(`Error checking out files for ${selectedDirectory}:`, error.message);
            });
        }

        // 上传功能
        function showUploadModal(dirName) {
            currentUploadDir = dirName;
            uploadTitle.textContent = `${I18N.upload_to} ${dirName}${I18N.workspace}`;
            uploadResult.innerHTML = '';
            uploadProgress.style.display = 'none';
            progressFill.style.width = '0%';
            uploadModal.style.display = 'block';
        }

        // 关闭上传模态框
        uploadClose.onclick = function() {
            uploadModal.style.display = 'none';
        }

        // 文件选择处理
        fileInput.addEventListener('change', function(e) {
            if (e.target.files.length > 0) {
                uploadFiles(Array.from(e.target.files));
            }
        });

        // 无限执行按钮点击处理
        const infiniteExecuteButton = document.getElementById('infiniteExecuteButton');
        if (infiniteExecuteButton) {
            infiniteExecuteButton.addEventListener('click', function() {
                infiniteExecuteMode = !infiniteExecuteMode;
                // 更新按钮样式以显示激活状态
                if (infiniteExecuteMode) {
                    infiniteExecuteButton.style.background = 'var(--color-accent)';
                    infiniteExecuteButton.style.color = 'white';
                    infiniteExecuteButton.style.borderColor = 'var(--color-accent)';
                } else {
                    infiniteExecuteButton.style.background = 'transparent';
                    infiniteExecuteButton.style.color = 'var(--color-accent)';
                    infiniteExecuteButton.style.borderColor = 'var(--color-accent)';
                }
            });
        }

        // 多智能体按钮点击处理
        const multiAgentButton = document.getElementById('multiAgentButton');
        if (multiAgentButton) {
            multiAgentButton.addEventListener('click', function() {
                multiAgentMode = !multiAgentMode;
                // 如果任务正在运行，更新按钮显示状态
                if (isTaskRunning) {
                    setTaskRunning(true);
                }
                // 更新按钮样式以显示激活状态
                if (multiAgentMode) {
                    multiAgentButton.style.background = 'var(--color-accent)';
                    multiAgentButton.style.color = 'white';
                    multiAgentButton.style.borderColor = 'var(--color-accent)';
                } else {
                    multiAgentButton.style.background = 'transparent';
                    multiAgentButton.style.color = 'var(--color-accent)';
                    multiAgentButton.style.borderColor = 'var(--color-accent)';
                }
            });
        }

        // 搜索网络按钮点击处理
        const webSearchButton = document.getElementById('webSearchButton');
        if (webSearchButton) {
            webSearchButton.addEventListener('click', function() {
                webSearchMode = !webSearchMode;
                // 更新按钮样式以显示激活状态
                if (webSearchMode) {
                    webSearchButton.style.background = 'var(--color-accent)';
                    webSearchButton.style.color = 'white';
                    webSearchButton.style.borderColor = 'var(--color-accent)';
                } else {
                    webSearchButton.style.background = 'transparent';
                    webSearchButton.style.color = 'var(--color-accent)';
                    webSearchButton.style.borderColor = 'var(--color-accent)';
                }
            });
        }

        // Thinking按钮点击处理
        const thinkingButton = document.getElementById('thinkingButton');
        let thinkingMode = false; // 默认关闭
        if (thinkingButton) {
            thinkingButton.addEventListener('click', function() {
                thinkingMode = !thinkingMode;
                // 更新按钮样式以显示激活状态
                if (thinkingMode) {
                    thinkingButton.style.background = 'var(--color-accent)';
                    thinkingButton.style.color = 'white';
                    thinkingButton.style.borderColor = 'var(--color-accent)';
                } else {
                    thinkingButton.style.background = 'transparent';
                    thinkingButton.style.color = 'var(--color-accent)';
                    thinkingButton.style.borderColor = 'var(--color-accent)';
                }
            });
        }

        // 快速上传按钮点击处理
        // 等待DOM加载完成后再设置事件监听器
        const quickUploadButton = document.getElementById('quickUploadButton');
        const quickFileInput = document.getElementById('quickFileInput');
        
        if (quickUploadButton && quickFileInput) {
            quickUploadButton.addEventListener('click', function() {
                // 检查guest用户权限
                if (isGuest) {
                    addMessage(I18N.guest_cannot_upload || 'Guest用户无法上传文件', 'error');
                    return;
                }

                // 如果没有选择工作目录，先创建新目录
                if (!selectedDirectory) {
                    // 先触发文件选择，文件会保存在pendingUploadFiles中
                    quickFileInput.click();
                    // 注意：文件选择是异步的，我们会在change事件中处理
                } else {
                    // 有工作目录，直接触发文件选择
                    quickFileInput.click();
                }
            });

            // 快速上传文件选择处理
            quickFileInput.addEventListener('change', function(e) {
                const files = Array.from(e.target.files);
                if (files.length === 0) {
                    return;
                }

                // 如果没有选择工作目录，先创建新目录
                if (!selectedDirectory) {
                    pendingUploadFiles = files; // 保存待上传的文件
                    // 创建新目录
                    createNewDirectory();
                } else {
                    // 有工作目录，直接上传
                    quickUploadFiles(files, selectedDirectory);
                }
            });
        }

        // 工作目录文件输入处理
        const directoryFileInput = document.getElementById('directoryFileInput');
        if (directoryFileInput) {
            directoryFileInput.addEventListener('change', function(e) {
                const files = Array.from(e.target.files);
                if (files.length === 0) {
                    return;
                }

                // 直接上传到当前设置的目录
                quickUploadFiles(files, currentUploadDir);

                // 清空文件输入
                directoryFileInput.value = '';
            });
        }

        // 快速上传文件函数（不显示模态框，直接在聊天中显示消息）
        function quickUploadFiles(files, dirName) {
            if (!dirName) {
                addMessage(I18N.select_directory_error || '请先选择工作目录', 'error');
                return;
            }

            const formData = new FormData();
            files.forEach(file => {
                formData.append('files', file);
            });
            
            // Add API key to form data
            if (currentUser && currentUser !== 'default') {
                formData.append('api_key', currentUser);
            }

            // 显示上传开始消息
            const fileNames = files.map(f => f.name).join(', ');
            const uploadingMsg = I18N.uploading_files ? I18N.uploading_files.replace('{0}', files.length) : (CURRENT_LANG === 'zh' ? '正在上传文件' : 'Uploading files');
            addMessage(`${uploadingMsg}: ${fileNames}...`, 'info');

            // 创建XMLHttpRequest以支持进度监控
            const xhr = new XMLHttpRequest();
            
            xhr.upload.addEventListener('progress', function(e) {
                if (e.lengthComputable) {
                    const percentComplete = Math.round((e.loaded / e.total) * 100);
                    // 可以在这里更新进度消息，但为了简洁，我们只在完成后显示
                }
            });

            xhr.addEventListener('load', function() {
                if (xhr.status === 200) {
                    const response = JSON.parse(xhr.responseText);
                    if (response.success) {
                        // 显示上传成功消息
                        const filesStr = response.files.join(', ');
                        const successMsg = CURRENT_LANG === 'zh' ? `成功上传文件: ${filesStr}` : `Successfully uploaded files: ${filesStr}`;
                        addMessage(successMsg, 'success');
                        // 清空文件输入
                        quickFileInput.value = '';
                        // 刷新目录
                        refreshDirectories();
                        
                        // 自动在需求框添加文件名引用
                        if (response.files && response.files.length > 0) {
                            const fileReferences = response.files.map(file => `@${file}`).join(' ');
                            const fileRefText = response.files.length === 1 ? `${fileReferences}：` : `${fileReferences}:`;
                            
                            // 获取当前输入框内容
                            const currentText = userInput.value.trim();
                            
                            // 如果输入框不为空，在末尾添加空格和文件引用
                            // 如果输入框为空，直接添加文件引用
                            if (currentText) {
                                userInput.value = currentText + ' ' + fileRefText;
                            } else {
                                userInput.value = fileRefText;
                            }
                            
                            // 触发输入框的resize事件，确保高度自适应
                            if (typeof resizeTextarea === 'function') {
                                resizeTextarea();
                            }
                            
                            // 聚焦到输入框
                            userInput.focus();
                            // 将光标移动到末尾
                            const length = userInput.value.length;
                            userInput.setSelectionRange(length, length);
                        }
                    } else {
                        const failedMsg = I18N.upload_failed || (CURRENT_LANG === 'zh' ? '上传失败' : 'Upload failed');
                        addMessage(`${failedMsg}: ${response.error}`, 'error');
                    }
                } else {
                    const failedMsg = I18N.upload_failed || (CURRENT_LANG === 'zh' ? '上传失败' : 'Upload failed');
                    addMessage(`${failedMsg}: HTTP ${xhr.status}`, 'error');
                }
            });

            xhr.addEventListener('error', function() {
                addMessage(I18N.upload_network_error || (CURRENT_LANG === 'zh' ? '网络错误，上传失败' : 'Network error, upload failed'), 'error');
            });

            xhr.open('POST', `/api/upload/${dirName}`);
            xhr.send(formData);
        }

        // 拖拽功能
        uploadArea.addEventListener('dragover', function(e) {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', function(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', function(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            
            const files = Array.from(e.dataTransfer.files);
            if (files.length > 0) {
                uploadFiles(files);
            }
        });

        // 上传文件函数
        function uploadFiles(files) {
            // 检查guest用户权限
            if (isGuest) {
                uploadResult.innerHTML = `<div class="error">${I18N.guest_cannot_upload}</div>`;
                return;
            }
            
            if (!currentUploadDir) {
                uploadResult.innerHTML = `<div class="error">${I18N.select_directory_error}</div>`;
                return;
            }

            const formData = new FormData();
            files.forEach(file => {
                formData.append('files', file);
            });
            
            // Add API key to form data
            if (currentUser && currentUser !== 'default') {
                formData.append('api_key', currentUser);
            }

            // 显示进度条
            uploadProgress.style.display = 'block';
            uploadResult.innerHTML = '';
            progressText.textContent = I18N.uploading_files.replace('{0}', files.length);

            // 创建XMLHttpRequest以支持进度监控
            const xhr = new XMLHttpRequest();
            
            xhr.upload.addEventListener('progress', function(e) {
                if (e.lengthComputable) {
                    const percentComplete = (e.loaded / e.total) * 100;
                    progressFill.style.width = percentComplete + '%';
                    if (percentComplete >= 100) {
                        progressText.textContent = I18N.upload_completed;
                    } else {
                        progressText.textContent = I18N.upload_progress.replace('{0}', Math.round(percentComplete));
                    }
                }
            });

            xhr.addEventListener('load', function() {
                if (xhr.status === 200) {
                    const response = JSON.parse(xhr.responseText);
                    if (response.success) {
                        // 显示上传完成信息
                        progressText.textContent = I18N.upload_completed;
                        uploadResult.innerHTML = `
                            <div class="success">
                                <i class="fas fa-check-circle"></i> ${response.message}
                                <br><small>文件: ${response.files.join(', ')}</small>
                            </div>
                        `;
                        
                        // 清空文件输入
                        fileInput.value = '';
                        
                        // 2秒后自动关闭对话框并刷新目录
                        setTimeout(() => {
                            uploadModal.style.display = 'none';
                            uploadProgress.style.display = 'none';
                            uploadResult.innerHTML = '';
                            progressFill.style.width = '0%';
                            refreshDirectories();
                        }, 2000);
                    } else {
                        uploadProgress.style.display = 'none';
                        uploadResult.innerHTML = `<div class="error"><i class="fas fa-exclamation-triangle"></i> ${response.error}</div>`;
                    }
                } else {
                    uploadProgress.style.display = 'none';
                    uploadResult.innerHTML = `<div class="error"><i class="fas fa-exclamation-triangle"></i> ${I18N.upload_failed_http.replace('{0}', xhr.status)}</div>`;
                }
            });

            xhr.addEventListener('error', function() {
                uploadProgress.style.display = 'none';
                uploadResult.innerHTML = `<div class="error"><i class="fas fa-exclamation-triangle"></i> ${I18N.upload_network_error}</div>`;
            });

            xhr.open('POST', `/api/upload/${currentUploadDir}`);
            xhr.send(formData);
        }

        // 工作目录快速上传功能（直接弹出文件选择框，不显示模态框）
        function quickUploadToDirectory(dirName) {
            // 检查guest用户权限
            if (isGuest) {
                addMessage(I18N.guest_cannot_upload || 'Guest用户无法上传文件', 'error');
                return;
            }

            // 设置当前上传目录
            currentUploadDir = dirName;

            // 触发文件选择框
            const directoryFileInput = document.getElementById('directoryFileInput');
            directoryFileInput.click();
        }

        // 删除文件功能
        let currentDeleteFilePath = '';
        let currentDeleteFileName = '';

        function showDeleteFileModal(filePath, fileName) {
            currentDeleteFilePath = filePath;
            currentDeleteFileName = fileName;
            document.getElementById('deleteFileName').textContent = fileName;
            document.getElementById('deleteFileModal').style.display = 'block';
        }

        // 删除文件夹功能
        let currentDeleteFolderPath = '';
        let currentDeleteFolderName = '';

        function showDeleteFolderModal(folderPath, folderName) {
            currentDeleteFolderPath = folderPath;
            currentDeleteFolderName = folderName;
            document.getElementById('deleteFolderName').textContent = folderName;
            document.getElementById('deleteFolderModal').style.display = 'block';
        }

        // 关闭删除文件模态框
        document.getElementById('deleteFileClose').onclick = function() {
            document.getElementById('deleteFileModal').style.display = 'none';
        }

        // 取消删除
        document.getElementById('cancelDeleteFile').onclick = function() {
            document.getElementById('deleteFileModal').style.display = 'none';
        }

        // 确认删除文件
        document.getElementById('confirmDeleteFile').onclick = function() {
            // 立即关闭对话框
            document.getElementById('deleteFileModal').style.display = 'none';
            // 执行删除操作
            deleteFile(currentDeleteFilePath, currentDeleteFileName);
        }

        function deleteFile(filePath, fileName) {
            const requestData = {
                file_path: filePath,
                api_key: currentUser
            };

            fetch('/api/delete-file', {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                    'X-API-Key': currentUser
                },
                body: JSON.stringify(requestData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    addMessage(data.message || `File "${fileName}" deleted successfully`, 'success');
                    
                    refreshDirectories();
                } else {
                    addMessage(data.error || 'Failed to delete file', 'error');
                }
            })
            .catch(error => {
                addMessage(' Network error while deleting file', 'error');
            });
        }

        // 关闭删除文件夹模态框
        document.getElementById('deleteFolderClose').onclick = function() {
            document.getElementById('deleteFolderModal').style.display = 'none';
        }

        // 取消删除文件夹
        document.getElementById('cancelDeleteFolder').onclick = function() {
            document.getElementById('deleteFolderModal').style.display = 'none';
        }

        // 确认删除文件夹
        document.getElementById('confirmDeleteFolder').onclick = function() {
            // 立即关闭对话框
            document.getElementById('deleteFolderModal').style.display = 'none';
            // 执行删除操作
            deleteFolder(currentDeleteFolderPath, currentDeleteFolderName);
        }

        function deleteFolder(folderPath, folderName) {
            const requestData = {
                file_path: folderPath,
                api_key: currentUser
            };

            fetch('/api/delete-file', {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                    'X-API-Key': currentUser
                },
                body: JSON.stringify(requestData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    addMessage(data.message || `Folder "${folderName}" deleted successfully`, 'success');
                    
                    refreshDirectories();
                } else {
                    addMessage(data.error || 'Failed to delete folder', 'error');
                }
            })
            .catch(error => {
                addMessage('Network error while deleting folder', 'error');
            });
        }

        // CSV表格相关功能
        function sortCSVTable(columnIndex) {
            if (!window.csvData) return;
            
            const { headers, currentData, sortColumn, sortDirection } = window.csvData;
            
            // 确定排序方向
            let newDirection = 'asc';
            if (sortColumn === columnIndex) {
                newDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            }
            
            // 排序数据
            const sortedData = [...currentData].sort((a, b) => {
                const aVal = (a[columnIndex] || '').toString().toLowerCase();
                const bVal = (b[columnIndex] || '').toString().toLowerCase();
                
                // 尝试数字比较
                const aNum = parseFloat(aVal);
                const bNum = parseFloat(bVal);
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return newDirection === 'asc' ? aNum - bNum : bNum - aNum;
                }
                
                // 字符串比较
                if (newDirection === 'asc') {
                    return aVal.localeCompare(bVal);
                } else {
                    return bVal.localeCompare(aVal);
                }
            });
            
            // 更新状态
            window.csvData.currentData = sortedData;
            window.csvData.sortColumn = columnIndex;
            window.csvData.sortDirection = newDirection;
            
            // 重新渲染表格
            renderCSVTableBody(sortedData);
            
            // 更新表头排序指示器
            updateSortIndicators(columnIndex, newDirection);
        }
        
        function updateSortIndicators(sortColumn, sortDirection) {
            const headers = document.querySelectorAll('#csvTable th');
            headers.forEach((th, index) => {
                const span = th.querySelector('span');
                if (span) {
                    if (index === sortColumn) {
                        span.textContent = sortDirection === 'asc' ? '↑' : '↓';
                        span.style.color = '#007acc';
                    } else {
                        span.textContent = '⇅';
                        span.style.color = '#6c757d';
                    }
                }
            });
        }
        
        function renderCSVTableBody(data) {
            if (!window.csvData) return;
            
            const tbody = document.getElementById('csvTableBody');
            const { headers } = window.csvData;
            
            if (!tbody || !headers) return;
            
            let html = '';
            if (data && data.length > 0) {
                data.forEach((row, rowIndex) => {
                    const rowStyle = rowIndex % 2 === 0 ? 'background: #ffffff;' : 'background: #f8f9fa;';
                    html += `<tr style="${rowStyle}">`;
                    
                    const maxCols = Math.max(headers.length, row.length);
                    for (let i = 0; i < maxCols; i++) {
                        const cellValue = row[i] || '';
                        const escapedValue = escapeHtml(cellValue);
                        html += `<td style="border: 1px solid #dee2e6; padding: 8px; vertical-align: top; word-break: break-word; max-width: 300px; color: #333;" title="${escapedValue}">${escapedValue}</td>`;
                    }
                    html += '</tr>';
                });
            } else {
                html = `<tr><td colspan="${headers.length}" style="text-align: center; padding: 40px; color: #6c757d; font-style: italic;">无匹配结果</td></tr>`;
            }
            
            tbody.innerHTML = html;
        }
        
        function filterCSVTable() {
            if (!window.csvData) return;
            
            const searchInput = document.getElementById('csvSearchInput');
            const searchTerm = searchInput.value.toLowerCase().trim();
            
            if (!searchTerm) {
                // 显示所有数据
                window.csvData.currentData = window.csvData.originalData;
                renderCSVTableBody(window.csvData.originalData);
                return;
            }
            
            // 过滤数据
            const filteredData = window.csvData.originalData.filter(row => {
                return row.some(cell => {
                    const cellValue = (cell || '').toString().toLowerCase();
                    return cellValue.includes(searchTerm);
                });
            });
            
            window.csvData.currentData = filteredData;
            renderCSVTableBody(filteredData);
        }
        
        function exportCSVTable() {
            if (!window.csvData) return;
            
            const { headers, currentData } = window.csvData;
            
            // 创建CSV内容
            let csvContent = '';
            
            // 添加表头
            if (headers && headers.length > 0) {
                csvContent += headers.map(header => `"${(header || '').replace(/"/g, '""')}"`).join(',') + '\n';
            }
            
            // 添加数据行
            currentData.forEach(row => {
                const csvRow = row.map(cell => {
                    const cellValue = (cell || '').toString();
                    return `"${cellValue.replace(/"/g, '""')}"`;
                }).join(',');
                csvContent += csvRow + '\n';
            });
            
            // 创建下载链接
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', 'exported_data.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } else {
                // 后备方案：打开新窗口显示CSV内容
                const newWindow = window.open();
                newWindow.document.write('<pre>' + escapeHtml(csvContent) + '</pre>');
            }
        }

        // 页面加载完成后的初始化
        document.addEventListener('DOMContentLoaded', function() {
            updateAutoScrollIndicator(); // 初始化自动滚动状态指示器
        });

        // 全局变量存储所有配置信息
        let allModelConfigs = [];
        let customModelConfig = null; // 存储用户自定义配置

        /**
         * 加载模型配置选项
         */
        function loadModelConfigs() {
            const modelSelect = document.getElementById('modelSelect');
            
            if (!modelSelect) {
                console.error('Model select element not found');
                return;
            }

            // 添加超时控制（30秒）
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000);

            fetch('/api/gui-configs', {
                signal: controller.signal
            })
                .then(response => {
                    clearTimeout(timeoutId);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success && data.configs && data.configs.length > 0) {
                        // 保存所有配置信息到全局变量
                        allModelConfigs = data.configs;
                        
                        // 清空现有选项
                        modelSelect.innerHTML = '';
                        
                        // 确定默认选择的配置ID
                        let defaultConfigId = null;
                        if (data.current_model && data.current_api_base) {
                            // 查找匹配当前激活配置的选项
                            const currentConfigId = `${data.current_model}__${data.current_api_base}`;
                            const matchingConfig = data.configs.find(c => c.value === currentConfigId);
                            if (matchingConfig) {
                                defaultConfigId = currentConfigId;
                            }
                        }
                        
                        // 如果没有找到匹配的配置，使用第一个非custom配置
                        if (!defaultConfigId) {
                            const firstNonCustom = data.configs.find(c => c.value !== 'custom');
                            if (firstNonCustom) {
                                defaultConfigId = firstNonCustom.value;
                            } else if (data.configs.length > 0) {
                                defaultConfigId = data.configs[0].value;
                            }
                        }
                        
                        // 添加所有配置选项
                        data.configs.forEach((config, index) => {
                            const option = document.createElement('option');
                            option.value = config.value;
                            option.textContent = config.label;
                            
                            // 设置匹配的配置为默认选择
                            if (config.value === defaultConfigId) {
                                option.selected = true;
                            }
                            
                            modelSelect.appendChild(option);
                        });
                        
                        // 移除之前的事件监听器（如果存在）
                        modelSelect.removeEventListener('change', handleModelSelectionChange);
                        modelSelect.removeEventListener('click', handleModelSelectClick);
                        
                        // 添加模型选择变更事件监听器
                        modelSelect.addEventListener('change', handleModelSelectionChange);
                        
                        // 添加点击事件监听器来处理重复选择自定义选项的情况
                        modelSelect.addEventListener('click', handleModelSelectClick);
                    } else {
                        // 如果没有配置或加载失败，显示默认选项
                        allModelConfigs = [];
                        modelSelect.innerHTML = '<option value="" disabled selected>' + (I18N && I18N.lang === 'zh' ? '无可用配置' : 'No configurations available') + '</option>';
                        console.warn('No model configurations found or loading failed');
                    }
                })
                .catch(error => {
                    clearTimeout(timeoutId);
                    console.error('Error loading model configurations:', error);
                    allModelConfigs = [];
                    
                    // 根据错误类型显示不同的错误信息
                    let errorMessage = I18N && I18N.lang === 'zh' ? '配置加载失败' : 'Failed to load configurations';
                    if (error.name === 'AbortError') {
                        errorMessage = I18N && I18N.lang === 'zh' ? '配置加载超时，请刷新页面重试' : 'Configuration loading timeout, please refresh and try again';
                    } else if (error.message && error.message.includes('HTTP error')) {
                        errorMessage = I18N && I18N.lang === 'zh' ? '配置加载失败，请检查服务器连接' : 'Failed to load configurations, please check server connection';
                    }
                    
                    // 显示错误状态
                    modelSelect.innerHTML = '<option value="" disabled selected>' + errorMessage + '</option>';
                });
        }

        /**
         * 处理模型选择变更事件
         */
        function handleModelSelectionChange() {
            const modelSelect = document.getElementById('modelSelect');
            const selectedValue = modelSelect.value;
            
            if (selectedValue === 'custom') {
                // 如果选择了自定义，显示自定义配置对话框
                showCustomConfigDialog();
            }
        }

        /**
         * 处理模型选择框点击事件（用于处理重复选择自定义的情况）
         */
        function handleModelSelectClick() {
            // 延迟检查，确保选择框的值已经更新
            setTimeout(() => {
                const modelSelect = document.getElementById('modelSelect');
                const selectedValue = modelSelect.value;
                
                console.log('Model select clicked, value:', selectedValue);
                
                if (selectedValue === 'custom') {
                    // 如果点击的是自定义选项，显示配置对话框
                    // 这样即使用户重复选择自定义选项，也会弹出对话框
                    console.log('Showing custom config dialog from click event');
                    showCustomConfigDialog();
                }
            }, 50);
        }

        /**
         * 显示自定义配置对话框
         */
        function showCustomConfigDialog() {
            const modal = document.getElementById('customConfigModal');
            if (modal) {
                // 清空错误信息
                hideCustomConfigError();
                
                // 更新对话框标题
                const title = modal.querySelector('.modal-header h3');
                if (title) {
                    const hasExistingConfig = customModelConfig && customModelConfig.api_key;
                    if (hasExistingConfig) {
                        title.innerHTML = '<i class="fas fa-edit"></i> ' + (I18N.custom_config_title || '自定义模型配置') + ' (编辑)';
                    } else {
                        title.innerHTML = '<i class="fas fa-cog"></i> ' + (I18N.custom_config_title || '自定义模型配置');
                    }
                }
                
                // 如果之前有自定义配置，填充表单
                if (customModelConfig) {
                    document.getElementById('customApiKey').value = customModelConfig.api_key || '';
                    document.getElementById('customApiBase').value = customModelConfig.api_base || '';
                    document.getElementById('customModel').value = customModelConfig.model || '';
                    document.getElementById('customMaxTokens').value = customModelConfig.max_tokens || 8192;
                } else {
                    // 清空表单
                    document.getElementById('customApiKey').value = '';
                    document.getElementById('customApiBase').value = '';
                    document.getElementById('customModel').value = '';
                    document.getElementById('customMaxTokens').value = 8192;
                }
                
                modal.style.display = 'block';
                
                // 聚焦到第一个输入框
                const firstInput = customModelConfig ? 
                    document.getElementById('customApiKey') : 
                    document.getElementById('customApiKey');
                if (firstInput) {
                    setTimeout(() => firstInput.focus(), 100);
                }
            }
        }

        /**
         * 隐藏自定义配置对话框
         */
        function hideCustomConfigDialog() {
            const modal = document.getElementById('customConfigModal');
            if (modal) {
                modal.style.display = 'none';
                
                // 如果用户取消了自定义配置，且没有之前的自定义配置，则重置为第一个选项
                if (!customModelConfig) {
                    const modelSelect = document.getElementById('modelSelect');
                    if (modelSelect && allModelConfigs.length > 0) {
                        modelSelect.value = allModelConfigs[0].value;
                    }
                }
            }
        }

        /**
         * 保存自定义配置
         */
        async function saveCustomConfig() {
            const apiKey = document.getElementById('customApiKey').value.trim();
            const apiBase = document.getElementById('customApiBase').value.trim();
            const model = document.getElementById('customModel').value.trim();
            let maxTokens = document.getElementById('customMaxTokens').value.trim();
            
            // 验证必填字段
            if (!apiKey || !apiBase || !model) {
                showCustomConfigError(I18N.custom_config_required || '所有字段都是必填的');
                return;
            }
            
            // 验证并处理max_tokens
            if (!maxTokens) {
                maxTokens = 8192;
            } else {
                maxTokens = parseInt(maxTokens);
                if (isNaN(maxTokens) || maxTokens <= 0) {
                    showCustomConfigError('Max Output Tokens必须是大于0的数字');
                    return;
                }
            }
            
            // 保存自定义配置到JavaScript变量
            customModelConfig = {
                api_key: apiKey,
                api_base: apiBase,
                model: model,
                max_tokens: maxTokens,
                display_name: '自定义'
            };
            
            console.log('已保存自定义模型配置:', customModelConfig);
            hideCustomConfigDialog();
            
            // 弹出确认对话框询问是否保存为长期配置
            const confirmMessage = I18N.save_to_config_confirm || 
                '是否将此配置保存到 config/config.txt 作为长期配置？\n\n这将更新配置文件中的默认模型设置。';
            
            if (confirm(confirmMessage)) {
                try {
                    // 调用API保存到config.txt
                    const response = await fetch('/api/save-to-config', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            api_key: apiKey,
                            api_base: apiBase,
                            model: model,
                            max_tokens: maxTokens
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        addMessage('✅ ' + (I18N.save_to_config_success || '配置已成功保存到 config.txt'), 'success');
                    } else {
                        addMessage('❌ ' + (I18N.save_to_config_failed || '保存到 config.txt 失败') + ': ' + result.error, 'error');
                    }
                } catch (error) {
                    console.error('保存配置到config.txt时出错:', error);
                    addMessage('❌ ' + (I18N.save_to_config_error || '保存到 config.txt 时发生错误') + ': ' + error.message, 'error');
                }
            }
        }

        /**
         * 显示自定义配置错误信息
         */
        function showCustomConfigError(message) {
            const errorDiv = document.getElementById('customConfigError');
            const errorText = document.getElementById('customConfigErrorText');
            if (errorDiv && errorText) {
                errorText.textContent = message;
                errorDiv.style.display = 'block';
            }
        }

        /**
         * 隐藏自定义配置错误信息
         */
        function hideCustomConfigError() {
            const errorDiv = document.getElementById('customConfigError');
            if (errorDiv) {
                errorDiv.style.display = 'none';
            }
        }

        /**
         * 根据选择的配置ID获取配置信息（异步，需要从服务器获取敏感信息）
         */
        async function getSelectedModelConfig() {
            const modelSelect = document.getElementById('modelSelect');
            if (!modelSelect || !modelSelect.value) {
                return null;
            }
            
            const selectedValue = modelSelect.value;
            
            // 如果选择的是自定义配置
            if (selectedValue === 'custom') {
                return customModelConfig;
            }
            
            // 查找内置配置的基本信息
            const config = allModelConfigs.find(c => c.value === selectedValue);
            
            if (!config) {
                console.error('Selected model configuration not found:', selectedValue);
                return null;
            }
            
            // 对于内置配置，需要从服务器获取api_key和api_base
            try {
                const response = await fetch('/api/get-model-config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        config_id: selectedValue
                    })
                });
                
                const result = await response.json();
                
                if (result.success && result.config) {
                    return {
                        value: result.config.value,
                        model: result.config.model,
                        api_key: result.config.api_key,
                        api_base: result.config.api_base,
                        max_tokens: result.config.max_tokens || 8192,
                        display_name: result.config.display_name || config.display_name
                    };
                } else {
                    console.error('Failed to get model config details:', result.error);
                    // 返回基本信息（不包含敏感信息）
                    return {
                        value: config.value,
                        model: config.model,
                        max_tokens: config.max_tokens || 8192,
                        display_name: config.display_name
                    };
                }
            } catch (error) {
                console.error('Error fetching model config details:', error);
                // 返回基本信息（不包含敏感信息）
                return {
                    value: config.value,
                    model: config.model,
                    max_tokens: config.max_tokens || 8192,
                    display_name: config.display_name
                };
            }
        }

        /**
         * 切换密码输入框的可见性
         */
        function togglePasswordVisibility(inputId) {
            const input = document.getElementById(inputId);
            const toggleButton = document.getElementById(inputId + 'Toggle') || 
                                 document.querySelector(`button[onclick*="${inputId}"]`);
            
            if (!input || !toggleButton) {
                console.error('Password input or toggle button not found:', inputId);
                return;
            }
            
            const icon = toggleButton.querySelector('i');
            
            if (input.type === 'password') {
                // 显示密码
                input.type = 'text';
                icon.className = 'fas fa-eye-slash';
                toggleButton.title = (I18N && I18N.lang === 'zh') ? '隐藏密码' : 'Hide password';
            } else {
                // 隐藏密码
                input.type = 'password';
                icon.className = 'fas fa-eye';
                toggleButton.title = (I18N && I18N.lang === 'zh') ? '显示密码' : 'Show password';
            }
        }

        // 将函数声明为全局函数，确保可以在控制台访问
        window.loadModelConfigs = loadModelConfigs;
        window.getSelectedModelConfig = getSelectedModelConfig;
        window.showCustomConfigDialog = showCustomConfigDialog;
        window.hideCustomConfigDialog = hideCustomConfigDialog;
        window.saveCustomConfig = saveCustomConfig;
        window.togglePasswordVisibility = togglePasswordVisibility;

        // 设置自定义配置对话框事件监听器
        document.addEventListener('DOMContentLoaded', function() {
            // 保存按钮
            const saveBtn = document.getElementById('customConfigSave');
            if (saveBtn) {
                saveBtn.addEventListener('click', saveCustomConfig);
            }
            
            // 取消按钮
            const cancelBtn = document.getElementById('customConfigCancel');
            if (cancelBtn) {
                cancelBtn.addEventListener('click', hideCustomConfigDialog);
            }
            
            // 关闭按钮
            const closeBtn = document.getElementById('customConfigClose');
            if (closeBtn) {
                closeBtn.addEventListener('click', hideCustomConfigDialog);
            }
            
            // 点击模态框外部关闭
            const modal = document.getElementById('customConfigModal');
            if (modal) {
                window.addEventListener('click', function(event) {
                    if (event.target === modal) {
                        hideCustomConfigDialog();
                    }
                });
            }
            
            // ESC键关闭
            document.addEventListener('keydown', function(event) {
                if (event.key === 'Escape' && modal && modal.style.display === 'block') {
                    hideCustomConfigDialog();
                }
            });
        });

    </script>
</body>
</html> 
